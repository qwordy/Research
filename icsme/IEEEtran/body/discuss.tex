\section{Discussion and Future Work}
\label{sec:discuss}
%\noindent
%\textbf{The causes of reverted commits.} We find that programmers can revert a previous change in the follow-up commits. For example,
%
%
%\zhong{List the previous commit:}
%
%\zhong{Explain the commit}
%
%However, in a follow-up commit, we find that the above commit is reverted as follow:
%
%
%\begin{lstlisting}
%commit f5fab1f64ba11e04e52bd6251ca62fc854e9578c
%Whoops. Fix regression in r1724015.
%Code was used although I can't see why a simple AtomicInteger wasn't sufficient.
%
%+    private final AtomicInteger aprPoolDestroyed = new AtomicInteger(0);
%-    private static final AtomicIntegerFieldUpdater<OpenSSLContext> DESTROY_UPDATER = AtomicIntegerFieldUpdater.newUpdater(OpenSSLContext.class, "aprPoolDestroyed");
%\end{lstlisting}
%
%\zhong{Explain the above commit.}
%\zhong{Explain why programmers revert the commit, why it matters?}

\noindent
\textbf{The causes of opposite commits.} We find that different programmers can make opposite changes. Here is a pair of opposite commits. The first commit\footnote{\url{https://github.com/apache/tomcat/commit/f5fab1f64ba11e04e52bd6251ca62fc854e9578c}} is from Cassandra:

%id: 95, 250
\begin{lstlisting}
-private final AtomicInteger references = new AtomicInteger(1);
+private volatile int references = 1;
+private static final AtomicIntegerFieldUpdater<RefCountedMemory> UPDATER = AtomicIntegerFieldUpdater.newUpdater(RefCountedMemory.class, "references");
...
-  int n = references.get();
+  int n = UPDATER.get(this);
...
-  if (references.compareAndSet(n, n + 1))
+  if (UPDATER.compareAndSet(this, n, n + 1))
...
-  if (references.decrementAndGet() == 0)
+  if (UPDATER.decrementAndGet(this) == 0)
\end{lstlisting}

The second commit\footnote{\url{https://github.com/apache/cassandra/commit/7918718c8ce53c6d0958aa969fc813e586463d08}} is from Tomcat:

\begin{lstlisting}
-private static final AtomicIntegerFieldUpdater<OpenSSLContext> DESTROY_UPDATER = AtomicIntegerFieldUpdater.newUpdater(OpenSSLContext.class, "aprPoolDestroyed");
+private final AtomicInteger aprPoolDestroyed = new AtomicInteger(0);
...
-  if (DESTROY_UPDATER.compareAndSet(this, 0, 1))
+  if (aprPoolDestroyed.compareAndSet(0, 1))
\end{lstlisting}

The first commit uses \CodeIn{AtomicIntegerFieldUpdater} to replace \CodeIn{AtomicInteger}. The programmer says it can save memory by doing this. However, in the second commit, the programmer uses \CodeIn{AtomicInteger} to replace \CodeIn{AtomicIntegerFieldUpdater}. He says that he cannot see why a simple \CodeIn{AtomicInteger} is not sufficient. Different programmers have different opinons. Another reason of this phenomenon is that a change has a strong correlation with its context. So opposite changes are possible.

\noindent
\textbf{The extension of existing tools.} Our patterns and findings can help improving existing program transformation tools. Many transformation tools can only handle certain conditions. For example, Asynchronizer \cite{conf/sigsoft/LinRD14} focus on \CodeIn{AsyncTask}. Tools can utilize rules which contains the contexts and the corresponding change patterns to enhance their ablitilies. It is beneficial if IDEs can support automatic transformation of some common change patterns.\zhong{Explain how to improve existing tools with your findings. Discuss how to implement a tool that, for example, that can replace self-written code with existing parallel APIs.}

\noindent
\textbf{The usefulness of our other findings.} Our result of the trend of change frequency can help programmers understand what concurrent classes are heavily used and what concurrent classes are gradually abandoned.% We can pay more attention to the active classes.
\zhong{More details.}
