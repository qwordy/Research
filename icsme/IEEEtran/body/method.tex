\section{Methodology}
This section presents data set of our study, research questions and tool support.

\subsection{Data set} We investigate 8 Java open-source projects from Github including Hadoop\footnote{http://hadoop.apache.org/}, Tomcat\footnote{http://tomcat.apache.org/}, Cassandra\footnote{http://cassandra.apache.org/}, Lucene-solr\footnote{http://lucene.apache.org/}, Netty\footnote{http://netty.io/}, Flink\footnote{https://flink.apache.org/} and Mahout\footnote{http://mahout.apache.org/} as shown in Table 1. Some projects are mirrored in Github. They are all popular, large-scale, active, representative Java open-source projects and cover different areas like distributed computing, web server, database, information retrieval, I/O and machine learning. The Hadoop project develops open-source software for reliable, scalable, distributed computing and has become one of the most famous Java open-source software for many years. Tomcat is the most popular implementation of the Java Servlet, JavaServer Pages, Java Expression Language and Java WebSocket technologies. Cassandra \cite{journals/sigops/LakshmanM10} is a database system which can Manage massive amounts of data, fast, without losing sleep. Lucene-solr is two projects together in one respository in Github. Lucene is a search engine library and solr is a search engine server which uses lucene. Netty is an event-driven asynchronous network application framework. Flink is an open source stream processing framework with powerful stream- and batch-processing capabilities. Mahout is a machine learning project. Table I shows the lines of code in Java, the number of Java files and the number of commits of each project. All the projects are checked out for our study in December 2016.

\begin{table}
	\centering
	\caption{Projects Information (LOC and \#Files are both of Java files)}
	\begin{tabular}{|c|c|c|c|}\hline
		Project&LOC&\#Files&\#Commits\\\hline
		Hadoop&1202764&7701&14930\\\hline
		Tomcat&301173&2192&17731\\\hline
		Cassandra&387980&2143&21982\\\hline
		Lucene-solr&918398&6310&26152\\\hline
		Netty&218131&2054&7759\\\hline
		Flink&414264&4068&9771\\\hline
		Guava&251205&1672&3850\\\hline
		Mahout&109584&1215&3703\\\hline
	\end{tabular}
\end{table}

\subsection{Research questions}
In order to understand the evolution of concurrent code and guide the future development better, we proposed 4 research questions:

\textbf{RQ1.} What are change patterns in concurrent programming?

Researchers found that many code changes are similar \cite{conf/icse/KimN09}. Similar changes of code can be extracted into change patterns \cite{conf/icsm/MartinezDM13}. Some change patterns are project-specific while others are global, which can be considered as knowledge. Developers made numerous commits to the project repository during software's whole lifetime. There are a great many change patterns in software history. On the other hand, concurrent programming is very popular in today's Java development with the rapid developments of multi-core techniques which help exploit the power of concurrent programming. It is very meaningful to understand change patterns in concurrent programming. What are these change patterns and how many types of these change patterns are there?

\textbf{RQ2.} How frequent do concurrent related code modification appear in different kinds of Java open-source projects?

Java programming language provides convenient built-in concurrent libraries and users can also invoke third-party libraries like Apache Commons and Guava, which are both very famous libraries providing reusable conponents. Although developers can use their own concurrent related classes or third-party libraries, they are always using the facilities provided by Java standard libraries in most cases except they are facing special and rigour requirement. Previous researches \cite{journals/jss/PintoTFFB15, journals/infsof/WuCZX16, conf/sigsoft/OkurD12} investigated the usage of concurrent libraries. We want to know how frequent do concurrent related code change occur in software projects. What are the differences of frequency in different kinds of software projects?

\textbf{RQ3.} What is the trend of concurrent programming construct usage statistically?

Java programming language offers many handy facilities for building concurrent programs. For example, there are language level constructs like \texttt{synchronized} and \texttt{volatile}. They are keywords of Java. There are also API level constructs like notify method of an object and some concurrent related convenient classes such as the \texttt{java.util.concurrent} package. There are always more than one ways to finish a task in Java and the preferences of developers evolves fast. We are interested in the trend of some common concurrent related constructs and the reasons hidden behind the phenomenon.

\textbf{RQ4.} Can these change patterns be applied to real world projects?

In order to better demonstrate these change patterns can really help developers understand concurrent programming practice and apply the practice to their projects, we are going to find the appropriate context in open-source projects and pull requests of applying the change patterns. We are insterested to see that how developers will accept our code change suggestions.

\subsection{Tool support}
We have developed a tool to collect and analyze data. The tool has the following parts.

\subsubsection{Collecting commits}
All the projects of our study are under git which is one of the most popular version control systems in the world. Some projects of the study used svn or some other version control systems before because they have long histories, but they all support git \cite{books/daglib/0022839} now. We employ JGit, a lightweight, pure Java library implementation of git, to retrieve all the commit logs in projects' histories. A typical commit log contains commit id which is a 20-character-long string uniquely identifying a commit, author, date and message. Once we get a commit id, we use \texttt{git show} command to show the log message and textual \texttt{diff}. The \texttt{diff} result contains one or more change files which contain one or more change hunks.

\subsubsection{Classification}
There are many commits which are not concurrent related in the commits which we have collected.  We need to select concurrent related commits. Tian \textit{et al}. gave a successful example of identifing bug fixing patches using machine learning \cite{conf/icse/TianLL12}. We use machine learning to train and predict whether a commit is concurrent related. We adopt both text analysis and code analysis to extract features. A commit log uses natural language to present what was changed and why the change was made in most cases. We treat each commit log as a bag of words then match the words to a set of concurrent keywords which we have defined as the Java concurrent keywords like \texttt{synchronized}, \texttt{volatile} and names of common classes or interfaces in Java libraries which are related to concurrency. We also do a code analysis based on the \texttt{diff} result. 12 features are extracted for each commit, which is shown in Table II. The first column shows the feature names and the second column shows the explanations.

We use the SVM \cite{journals/ml/CortesV95} algorithm to train and classify commits as concurrent-related or not. SVM is a supervised classification algorithm which needs both positive and negative labeled data for training. In our tool, we use an implementation of SVM, LIBSVM \cite{libsvm}. We manually label some data as a training data set first then train a model. The trained classifier selects 135 positive instances from all the commits which we have collected.

\subsection{Threats to Validity}

\textbf{Threats to internal validity}

%All the change patterns are summarized from real commits of projects. Different developers may have different taste and preference. Their behavior on similar conditions may be different, sometimes contradictory. We indeed find that some changes are contradictory.

Some change patterns are complex. They span many files and versions. We cannot easily identify them without explanation and documentation from developers. They usually need rigorous analysis based on the relevant code. So we might omit some change patterns.

We collect all the commits from the initialization of projects. The time range of them is very wide. Some changes are not very recent. The development of software is very fast, so some change patterns which are not very recent might not be suitable for the newest software.

\textbf{Threats to external validity}

We analyze 7 Java open-source projects. The number of the projects we select is small compared to the huge amount of open-source projects. These 7 projects may not contains all change patterns in concurrent programming. Concurrent programming is a concept not only in Java but many other programming languages can support concurrent programming. The projects of our study are all written in Java. The change patterns may be different among different programming languages.

\begin{table}
	\centering
	\caption{Features of Data}
	\begin{tabular}{|c|c|}\hline
		Feature&Explanation\\\hline
		msgKey&Number of keywords in commit message\\\hline
		file&Number of files in a commit\\\hline
		hunk&Number of hunks in a commit\\\hline
		lineAdd&Number of added lines in a commit\\\hline
		lineRemove&Number of removed lines in a commit\\\hline
		lineSub&lineAdd - lineRemove\\\hline
		lineSum&lineAdd + lineRemove\\\hline
		keyAdd&Number of added keywords in a commit\\\hline
		keyRemove&Number of removed keywords in a commit\\\hline
		keySub&keyAdd - keyRemove\\\hline
		keySum&keyAdd + keyRemove\\\hline
		contextKey&Number of keywords in context code\\\hline
	\end{tabular}
\end{table}