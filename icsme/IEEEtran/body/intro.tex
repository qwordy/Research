\section{Introduction}
Many practitioners and researchers believe that the software maintenance phase is one of the most expensive phases, in the life cycle of a software system. Some reports (\emph{e.g.}, \cite{ahn2003software}) claim that the software maintenance phase accounts for almost 80\% of the whole budget. With the maintenance of software, many revision histories are accumulated~\cite{conf/icsm/Borges16}. Based on such revision histories, researchers have conducted various empirical studies to understand how programmers maintain code (\emph{e.g.}, evolution of design patterns~\cite{aversano2007empirical}, fine-grained modifications~\cite{german2006empirical}, and the evolution of APIs~\cite{mcdonnell2013empirical}). These empirical studies deepen our understanding on software maintenance, and provide valuable insights on how to maintain code for programmer. 



In recent years, to fully leverage the potential of multi-core CPUs, concurrency programming becomes increasingly popular~\cite{journals/jss/PintoTFFB15}. For example, Pinto \textit{et al}. \cite{journals/jss/PintoTFFB15} investigated 2,227 projects, and their results show that more than 75\% of their investigated projects employ some concurrency control mechanism. Despite of its popularity, many programmers find that concurrent programming is difficult \cite{journals/corr/McKenney17}, and often introduce relevant bugs in their code~\cite{conf/asplos/LuPSZ08}. As it is difficult to maintain concurrency code, there is a strong need for a thorough empirical study on how programmers maintain such code. Despite of its importance, the topic is still rarely explored. To the best of our knowledge, only a recent study~\cite{conf/sigsoft/GuJSZL15} was conducted to understand how programmers maintain concurrency code. Although the study is insightful and explores many aspects of concurrency programming, it is still incomplete. For example, the study mainly focuses on code changes within critical sections, but maintaining concurrency code involves more code elements outside critical sections. As a result, many relevant questions are still open. For example, are there any patterns, when programmers maintain concurrency code?



\textbf{Limitations} Many empirical studies have been conducted in concurrent programming. Gu \textit{et al}. \cite{conf/sigsoft/GuJSZL15} studied change history of thread synchronization. They checked 250,000 revisions of four open-source projects to figure out how critical sections change. They also conducted case studies to understand how the changes solve performance problems and correctness problems. However, concurrency is not only reflected by critical sections, but also some other programming constructs like concurrent libirary usage, thread resource management. Study on critical sections are not enough to understand real-world thread synchronization. Pinto \textit{et al}. \cite{journals/jss/PintoTFFB15} did a large-scale study on the usage of Java concurrent programming constructs. They checked the usage of concurrent programming constructs in a large base of code. They had many findings such as more than 75\% of the projects create threads of do some concurrency control and the adoption of concurrent package of Java is moderate (23\% concurrent projects use it). But we all know that software is changing every day. Numerous commits are submitted per day. We want to know not only the usage of concurrent programming, but also how concurrent programs are changed.

Santos \textit{et al}. \cite{conf/icsm/SantosAEDV15} studied system specific, source code transformations. They found some sequences of changes are systematic. They defined them as transformation patterns. They identified some transformation patterns in real world software and studied their properties like they are system specific, or they were applied in a manual way. However, the change patterns of concurrent programs are less studied.

\textbf{Benefits} We study concurrent programs from a perspective of software evolution history and find many change patterns about concurrent programming. Understanding concurrent program change patterns is very beneficial.

1) Developers are facing many concurrent programming requirements now. But concurrent programming is notoriously error-prone \cite{conf/asplos/LuPSZ08} because of the complexity of thread synchronization and scheduling. Even experienced developers might also be confused sometimes. Our study gives developers some guidelines of writing concurrent programs such as using handy concurrent libraries to finish the job instead of rewriting them by yourself unless all the available concurrent libraries cannot satisfy your requirement and you are absolutely confident of your concurrent programming skills.

%Using existing libraries allows you to  write less code to finish the same work and enjoy the high quality of implementation which is always reliable, strong and fast.

2) Automatic tools are needed to help developers inspect and revise concurrent programs with the help of history information. We can learn from existing change patterns \cite{conf/pldi/MengKM11}. There has already been some tools \cite{conf/ppopp/SamakR14, conf/sigsoft/EslamimehrP14, conf/pldi/BiswasHSB14}, but they usually look for concurrent bugs such as race detection, deadlock detection and atomicity violation without considering software evolution history.

\lstset{numbers=left, breaklines=true,  basicstyle=\ttfamily\tiny,  xleftmargin=3em, tabsize=2}
%keywordstyle=\color{blue}\bf\ttfamily, language=java,
\begin{lstlisting}
commit a6092d771ec50cf9aa434c75455b842f3ac6c628
Threading / initialisation issues. Not all were valid. Make them volatile anyway so FindBugs doesn't complain.
\end{lstlisting}

This is a commit message of Mark Thomas. He is a member of the Apache Tomcat Project Management Committee, and senior software engineer at the Covalent division of SpringSource. He has submitted more than 10,000 commits to Tomcat. He said that he made the changes anyway to eliminate FindBugs' warning. This indicates that a experienced programmer also feels bothered with these problems.

Both project specific and project independent transformation patterns exist in real-world software projects. So we need some concurrent code refactoring tools to give advice of what code need change and perform the transformations automatically. It is a chance for IDE manufacturer to make the IDE more intelligent in inspecting and modifying the code. Developers will benefit a lot if such kind of automatic tools can actually help them with automating their development and maintenance.

\textbf{Challenges} However, this work has to face several challenges:

1) The scale of open source software is increasing explosively as a result of some open source code platforms have become more and more popular. The change history of the open source software is also vast. Our interest is concurrent related commit, but they are hidden in the massive commit history. It requires much time and effort to identify whether a commit is concurrent related or not if doing it manually. We would like to adopt some automatic methods. Simple keyword matching algorithm will not work well because some commits just add or remove functionalities rather than modify original code.

2) The changes of code usually have complex relationship with the context not only in the file where change happens but also other files. Some change patterns have implicit dependency on the existing code. This raises a challenge to identify real change patterns which can be applied to other context correctly.

\textbf{Contributions} Our main contributions are:

\begin{itemize}
	\item We identify and classify change patterns into ? types in concurrent programs from 102,028 commits of 7 open-source projects. The most common types of change patterns are thread-safe class replacement, changing critical sections.
	\item We find some interesting findings: Some changes are contrary. Different developers may modify their code in an opposite direction. Developers are using some code-checking tools like findbugs to help them inspect their code, but sometimes these tools are not enough.
	\item We affirm that our change patterns can be applied to appropriate  contexts from real world open-source projects.
	\item We give some inspirations to concurrent program or library developers and analysis tool developers. Automated tools can be improved to help developers with program transformations.
\end{itemize}

The rest of paper is organized as follows: Section 2 presents the methodology of our study. Section 3 presents our result and discussion. Section 4 presents related work. Section 5 presents future work and Section 6 concludes.\input
