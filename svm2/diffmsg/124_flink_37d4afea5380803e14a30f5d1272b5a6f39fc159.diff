commit 37d4afea5380803e14a30f5d1272b5a6f39fc159
Author: sewen <stephan.ewen@tu-berlin.de>
Date:   Sun Apr 14 03:49:40 2013 +0200

    Reworked Nephele Mini Cluster to start more reliably.
    Fixed Local Executor.
    Fixed Bug in Delimited Input Formats.
    Reworked KMeans tests (both single step and iterative).
    
    Removed Pact Testing Framework for now.

diff --git a/nephele/nephele-common/src/main/java/eu/stratosphere/nephele/configuration/ConfigConstants.java b/nephele/nephele-common/src/main/java/eu/stratosphere/nephele/configuration/ConfigConstants.java
index 0703226..7c0f417 100644
--- a/nephele/nephele-common/src/main/java/eu/stratosphere/nephele/configuration/ConfigConstants.java
+++ b/nephele/nephele-common/src/main/java/eu/stratosphere/nephele/configuration/ConfigConstants.java
@@ -68,6 +68,11 @@ public final class ConfigConstants {
 	public static final String MEMORY_MANAGER_AVAILABLE_MEMORY_SIZE_KEY = "taskmanager.memory.size";
 
 	/**
+	 * The key defining the amount polling interval (in seconds) for the JobClient.
+	 */
+	public static final String JOBCLIENT_POLLING_INTERVAL_KEY = "jobclient.polling.internval";
+	
+	/**
 	 * The key for the config parameter defining flag to terminate a job at job-client shutdown.
 	 */
 	public static final String JOBCLIENT_SHUTDOWN_TERMINATEJOB_KEY = "jobclient.shutdown.terminatejob";
@@ -112,6 +117,11 @@ public final class ConfigConstants {
 	public static final String DEFAULT_TASK_MANAGER_TMP_PATH = System.getProperty("java.io.tmpdir");
 
 	/**
+	 * The default value for the JobClient's polling interval. 5 Seconds.
+	 */
+	public static final int DEFAULT_JOBCLIENT_POLLING_INTERVAL = 5;
+	
+	/**
 	 * The default value for the flag to terminate a job on job-client shutdown.
 	 */
 	public static final boolean DEFAULT_JOBCLIENT_SHUTDOWN_TERMINATEJOB = true;
diff --git a/nephele/nephele-server/src/main/java/eu/stratosphere/nephele/discovery/DiscoveryService.java b/nephele/nephele-server/src/main/java/eu/stratosphere/nephele/discovery/DiscoveryService.java
index 3bcc55f..c2d7f83 100644
--- a/nephele/nephele-server/src/main/java/eu/stratosphere/nephele/discovery/DiscoveryService.java
+++ b/nephele/nephele-server/src/main/java/eu/stratosphere/nephele/discovery/DiscoveryService.java
@@ -270,7 +270,7 @@ public class DiscoveryService implements Runnable {
 
 		this.isRunning = true;
 
-		this.listeningThread = new Thread(this);
+		this.listeningThread = new Thread(this, "Discovery Service Thread");
 		this.listeningThread.start();
 	}
 
diff --git a/nephele/nephele-server/src/main/java/eu/stratosphere/nephele/instance/local/LocalTaskManagerThread.java b/nephele/nephele-server/src/main/java/eu/stratosphere/nephele/instance/local/LocalTaskManagerThread.java
index 4bd1964..a820760 100644
--- a/nephele/nephele-server/src/main/java/eu/stratosphere/nephele/instance/local/LocalTaskManagerThread.java
+++ b/nephele/nephele-server/src/main/java/eu/stratosphere/nephele/instance/local/LocalTaskManagerThread.java
@@ -31,11 +31,9 @@ public class LocalTaskManagerThread extends Thread {
 
 	/**
 	 * Constructs a new thread to run the task manager in Nephele's local mode.
-	 * 
-	 * @param configDir
-	 *        the configuration directory to pass on to the task manager instance
 	 */
 	public LocalTaskManagerThread() {
+		super("Local Taskmanager IO Loop");
 
 		TaskManager tmpTaskManager = null;
 		try {
@@ -70,7 +68,6 @@ public class LocalTaskManagerThread extends Thread {
 	 * @return <code>true</code> if the task manager is completely shut down, <code>false</code> otherwise
 	 */
 	public boolean isTaskManagerShutDown() {
-
 		return this.taskManager.isShutDown();
 	}
 }
diff --git a/nephele/nephele-server/src/main/java/eu/stratosphere/nephele/jobmanager/JobManager.java b/nephele/nephele-server/src/main/java/eu/stratosphere/nephele/jobmanager/JobManager.java
index 46d9309..4aae0d3 100644
--- a/nephele/nephele-server/src/main/java/eu/stratosphere/nephele/jobmanager/JobManager.java
+++ b/nephele/nephele-server/src/main/java/eu/stratosphere/nephele/jobmanager/JobManager.java
@@ -208,7 +208,8 @@ public class JobManager implements DeploymentManager, ExtendedManagementProtocol
 		}
 
 		// Read the suggested client polling interval
-		this.recommendedClientPollingInterval = GlobalConfiguration.getInteger("jobclient.polling.internval", 5);
+		this.recommendedClientPollingInterval = GlobalConfiguration.getInteger(
+			ConfigConstants.JOBCLIENT_POLLING_INTERVAL_KEY, ConfigConstants.DEFAULT_JOBCLIENT_POLLING_INTERVAL);
 
 		// Load the job progress collector
 		this.eventCollector = new EventCollector(this.recommendedClientPollingInterval);
@@ -430,7 +431,6 @@ public class JobManager implements DeploymentManager, ExtendedManagementProtocol
 	 */
 	@Override
 	public JobSubmissionResult submitJob(JobGraph job) throws IOException {
-
 		// First check if job is null
 		if (job == null) {
 			JobSubmissionResult result = new JobSubmissionResult(AbstractJobResult.ReturnCode.ERROR,
diff --git a/pact/pact-clients/pom.xml b/pact/pact-clients/pom.xml
index ec32ca1..b1515f0 100644
--- a/pact/pact-clients/pom.xml
+++ b/pact/pact-clients/pom.xml
@@ -28,6 +28,13 @@
       <artifactId>pact-compiler</artifactId>
       <version>${project.version}</version>
     </dependency>
+    
+    <dependency>
+      <groupId>eu.stratosphere</groupId>
+      <artifactId>pact-examples</artifactId>
+      <version>${project.version}</version>
+      <scope>test</scope>
+    </dependency>
 
     <dependency>
     	<groupId>commons-cli</groupId>
diff --git a/pact/pact-clients/src/main/java/eu/stratosphere/pact/client/LocalExecutor.java b/pact/pact-clients/src/main/java/eu/stratosphere/pact/client/LocalExecutor.java
index ccd33a0..cf21e43 100644
--- a/pact/pact-clients/src/main/java/eu/stratosphere/pact/client/LocalExecutor.java
+++ b/pact/pact-clients/src/main/java/eu/stratosphere/pact/client/LocalExecutor.java
@@ -20,6 +20,7 @@ import eu.stratosphere.nephele.jobgraph.JobGraph;
 import eu.stratosphere.pact.client.minicluster.NepheleMiniCluster;
 import eu.stratosphere.pact.common.plan.Plan;
 import eu.stratosphere.pact.common.plan.PlanAssembler;
+import eu.stratosphere.pact.compiler.DataStatistics;
 import eu.stratosphere.pact.compiler.PactCompiler;
 import eu.stratosphere.pact.compiler.plan.candidate.OptimizedPlan;
 import eu.stratosphere.pact.compiler.plantranslate.NepheleJobGraphGenerator;
@@ -74,7 +75,7 @@ public class LocalExecutor {
 				throw new Exception("The local executor has not been started.");
 			}
 
-			PactCompiler pc = new PactCompiler();
+			PactCompiler pc = new PactCompiler(new DataStatistics());
 			OptimizedPlan op = pc.compile(plan);
 			
 			NepheleJobGraphGenerator jgg = new NepheleJobGraphGenerator();
diff --git a/pact/pact-clients/src/main/java/eu/stratosphere/pact/client/minicluster/NepheleMiniCluster.java b/pact/pact-clients/src/main/java/eu/stratosphere/pact/client/minicluster/NepheleMiniCluster.java
index 0002349..c93f425 100644
--- a/pact/pact-clients/src/main/java/eu/stratosphere/pact/client/minicluster/NepheleMiniCluster.java
+++ b/pact/pact-clients/src/main/java/eu/stratosphere/pact/client/minicluster/NepheleMiniCluster.java
@@ -134,9 +134,22 @@ public class NepheleMiniCluster {
 				GlobalConfiguration.includeConfiguration(conf);
 			}
 			
+			// before we start the jobmanager, we need to make sure that there are no lingering IPC threads from before
+			// check that all threads are done before we return
+			Thread[] allThreads = new Thread[Thread.activeCount()];
+			int numThreads = Thread.enumerate(allThreads);
+			
+			for (int i = 0; i < numThreads; i++) {
+				Thread t = allThreads[i];
+				String name = t.getName();
+				if (name.equals("Local Taskmanager IO Loop") || name.equals("Discovery Service") || name.startsWith("IPC")) {
+					t.join();
+				}
+			}
+			
 			// start the job manager
 			jobManager = new JobManager(ExecutionMode.LOCAL);
-			runner = new Thread() {
+			runner = new Thread("JobManager Task Loop") {
 				@Override
 				public void run() {
 					// run the main task loop
@@ -187,6 +200,9 @@ public class NepheleMiniCluster {
 		config.setInteger(ConfigConstants.TASK_MANAGER_IPC_PORT_KEY, taskManagerRpcPort);
 		config.setInteger(ConfigConstants.TASK_MANAGER_DATA_PORT_KEY, taskManagerDataPort);
 		
+		// polling interval
+		config.setInteger(ConfigConstants.JOBCLIENT_POLLING_INTERVAL_KEY, 2);
+		
 		// enable / disable features
 		config.setInteger(ConfigConstants.JOB_EXECUTION_RETRIES_KEY, 0);
 		config.setBoolean("taskmanager.setup.usediscovery", false);
diff --git a/pact/pact-clients/src/main/java/eu/stratosphere/pact/client/web/GUIServletStub.java b/pact/pact-clients/src/main/java/eu/stratosphere/pact/client/web/GUIServletStub.java
index e45994f..a5a3408 100644
--- a/pact/pact-clients/src/main/java/eu/stratosphere/pact/client/web/GUIServletStub.java
+++ b/pact/pact-clients/src/main/java/eu/stratosphere/pact/client/web/GUIServletStub.java
@@ -145,6 +145,7 @@ public abstract class GUIServletStub extends HttpServlet {
 			.println("    <h1><img src=\"img/StratosphereLogo.png\" width=\"326\" height=\"100\" alt=\"Stratosphere Logo\" align=\"middle\"/>Nephele and PACTs Query Interface</h1>");
 		writer.println("  </div>");
 
+		@SuppressWarnings("unchecked")
 		Map<String, String[]> m = (Map<String, String[]>) req.getParameterMap();
 
 		// let the content be printed by the child class
diff --git a/pact/pact-clients/src/main/java/eu/stratosphere/pact/common/plan/ContractUtil.java b/pact/pact-clients/src/main/java/eu/stratosphere/pact/common/plan/ContractUtil.java
deleted file mode 100644
index 64a97e3..0000000
--- a/pact/pact-clients/src/main/java/eu/stratosphere/pact/common/plan/ContractUtil.java
+++ /dev/null
@@ -1,191 +0,0 @@
-/***********************************************************************************************************************
- *
- * Copyright (C) 2010 by the Stratosphere project (http://stratosphere.eu)
- *
- * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with
- * the License. You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on
- * an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
- * specific language governing permissions and limitations under the License.
- *
- **********************************************************************************************************************/
-
-package eu.stratosphere.pact.common.plan;
-
-import java.util.ArrayList;
-import java.util.Collections;
-import java.util.Iterator;
-import java.util.LinkedHashMap;
-import java.util.List;
-import java.util.Map;
-import java.util.Map.Entry;
-
-import eu.stratosphere.pact.common.contract.CoGroupContract;
-import eu.stratosphere.pact.common.contract.CrossContract;
-import eu.stratosphere.pact.common.contract.FileDataSink;
-import eu.stratosphere.pact.common.contract.FileDataSource;
-import eu.stratosphere.pact.common.contract.GenericDataSink;
-import eu.stratosphere.pact.common.contract.GenericDataSource;
-import eu.stratosphere.pact.common.contract.MapContract;
-import eu.stratosphere.pact.common.contract.MatchContract;
-import eu.stratosphere.pact.common.contract.ReduceContract;
-import eu.stratosphere.pact.common.io.FileInputFormat;
-import eu.stratosphere.pact.common.io.FileOutputFormat;
-import eu.stratosphere.pact.common.stubs.CoGroupStub;
-import eu.stratosphere.pact.common.stubs.CrossStub;
-import eu.stratosphere.pact.common.stubs.MapStub;
-import eu.stratosphere.pact.common.stubs.MatchStub;
-import eu.stratosphere.pact.common.stubs.ReduceStub;
-import eu.stratosphere.pact.generic.contract.Contract;
-import eu.stratosphere.pact.generic.contract.DualInputContract;
-import eu.stratosphere.pact.generic.contract.SingleInputContract;
-import eu.stratosphere.pact.generic.io.InputFormat;
-import eu.stratosphere.pact.generic.io.OutputFormat;
-
-/**
- * Convenience methods when dealing with {@link Contract}s.
- * 
- * @author Arvid Heise
- */
-public class ContractUtil {
-	private final static Map<Class<?>, Class<? extends Contract>> STUB_CONTRACTS =
-		new LinkedHashMap<Class<?>, Class<? extends Contract>>();
-
-	static {
-		STUB_CONTRACTS.put(MapStub.class, MapContract.class);
-		STUB_CONTRACTS.put(ReduceStub.class, ReduceContract.class);
-		STUB_CONTRACTS.put(CoGroupStub.class, CoGroupContract.class);
-		STUB_CONTRACTS.put(CrossStub.class, CrossContract.class);
-		STUB_CONTRACTS.put(MatchStub.class, MatchContract.class);
-		STUB_CONTRACTS.put(FileInputFormat.class, FileDataSource.class);
-		STUB_CONTRACTS.put(FileOutputFormat.class, FileDataSink.class);
-		STUB_CONTRACTS.put(InputFormat.class, GenericDataSource.class);
-		STUB_CONTRACTS.put(OutputFormat.class, GenericDataSink.class);
-	}
-
-	/**
-	 * Returns the associated {@link Contract} type for the given {@link Stub} class.
-	 * 
-	 * @param stubClass
-	 *        the stub class
-	 * @return the associated Contract type
-	 */
-	@SuppressWarnings({ "unchecked" })
-	public static Class<? extends Contract> getContractClass(final Class<?> stubClass) {
-		if (stubClass == null)
-			return null;
-		final Class<?> contract = STUB_CONTRACTS.get(stubClass);
-		if (contract != null)
-			return (Class<? extends Contract>) contract;
-		Iterator<Entry<Class<?>, Class<? extends Contract>>> stubContracts = STUB_CONTRACTS.entrySet().iterator();
-		while (stubContracts.hasNext()) {
-			Map.Entry<Class<?>, Class<? extends Contract>> entry = stubContracts.next();
-			if (entry.getKey().isAssignableFrom(stubClass))
-				return entry.getValue();
-		}
-		return null;
-
-	}
-
-	/**
-	 * Returns the number of inputs for the given {@link Contract} type.<br>
-	 * Currently, it can be 0, 1, or 2.
-	 * 
-	 * @param contractClass
-	 *        the type of the Contract
-	 * @return the number of input contracts
-	 */
-	public static int getNumInputs(final Class<? extends Contract> contractType) {
-
-		if (GenericDataSource.class.isAssignableFrom(contractType))
-			return 0;
-		if (GenericDataSink.class.isAssignableFrom(contractType)
-			|| SingleInputContract.class.isAssignableFrom(contractType))
-			return 1;
-		if (DualInputContract.class.isAssignableFrom(contractType))
-			return 2;
-		throw new IllegalArgumentException("not supported");
-	}
-
-	/**
-	 * Returns a list of all inputs for the given {@link Contract}.<br>
-	 * Currently, the list can have 0, 1, or 2 elements.
-	 * 
-	 * @param contract
-	 *        the Contract whose inputs should be returned
-	 * @return all input contracts to this contract
-	 */
-	public static List<List<Contract>> getInputs(final Contract contract) {
-		ArrayList<List<Contract>> inputs = new ArrayList<List<Contract>>();
-
-		if (contract instanceof GenericDataSink)
-			inputs.add(new ArrayList<Contract>(((GenericDataSink) contract).getInputs()));
-		else if (contract instanceof SingleInputContract)
-			inputs.add(new ArrayList<Contract>(((SingleInputContract<?>) contract).getInputs()));
-		else if (contract instanceof DualInputContract) {
-			inputs.add(new ArrayList<Contract>(((DualInputContract<?>) contract).getFirstInputs()));
-			inputs.add(new ArrayList<Contract>(((DualInputContract<?>) contract).getSecondInputs()));
-		}
-		return inputs;
-	}
-
-	public static List<Contract> getFlatInputs(final Contract contract) {
-		if (contract instanceof GenericDataSink)
-			return ((GenericDataSink) contract).getInputs();
-		if (contract instanceof SingleInputContract)
-			return ((SingleInputContract<?>) contract).getInputs();
-		if (contract instanceof DualInputContract) {
-			ArrayList<Contract> inputs = new ArrayList<Contract>();
-			inputs.addAll(((DualInputContract<?>) contract).getFirstInputs());
-			inputs.addAll(((DualInputContract<?>) contract).getSecondInputs());
-			return inputs;
-		}
-
-		return new ArrayList<Contract>();
-	}
-
-	/**
-	 * Sets the inputs of the given {@link Contract}.<br>
-	 * Currently, the list can have 0, 1, or 2 elements and the number of elements must match the type of the contract.
-	 * 
-	 * @param contract
-	 *        the Contract whose inputs should be set
-	 * @param inputs
-	 *        all input contracts to this contract
-	 */
-	public static void setInputs(final Contract contract, final List<List<Contract>> inputs) {
-		if (contract instanceof GenericDataSink) {
-			if (inputs.size() != 1)
-				throw new IllegalArgumentException("wrong number of inputs");
-			((GenericDataSink) contract).setInputs(inputs.get(0));
-		} else if (contract instanceof SingleInputContract) {
-			if (inputs.size() != 1)
-				throw new IllegalArgumentException("wrong number of inputs");
-			((SingleInputContract<?>) contract).setInputs(inputs.get(0));
-		} else if (contract instanceof DualInputContract) {
-			if (inputs.size() != 2)
-				throw new IllegalArgumentException("wrong number of inputs");
-			((DualInputContract<?>) contract).setFirstInputs(inputs.get(0));
-			((DualInputContract<?>) contract).setSecondInputs(inputs.get(1));
-		}
-	}
-
-	/**
-	 * Swaps two inputs of the given contract.
-	 * 
-	 * @param contract
-	 *        the contract
-	 * @param input1
-	 *        the first input index
-	 * @param input2
-	 *        the second input index
-	 */
-	public static void swapInputs(Contract contract, int input1, int input2) {
-		final List<List<Contract>> inputs = new ArrayList<List<Contract>>(getInputs(contract));
-		Collections.swap(inputs, input1, input2);
-		setInputs(contract, inputs);
-	}
-}
diff --git a/pact/pact-clients/src/main/java/eu/stratosphere/pact/testing/AbstractValueMatcher.java b/pact/pact-clients/src/main/java/eu/stratosphere/pact/testing/AbstractValueMatcher.java
deleted file mode 100644
index 5b27062..0000000
--- a/pact/pact-clients/src/main/java/eu/stratosphere/pact/testing/AbstractValueMatcher.java
+++ /dev/null
@@ -1,61 +0,0 @@
-/***********************************************************************************************************************
- *
- * Copyright (C) 2010 by the Stratosphere project (http://stratosphere.eu)
- *
- * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with
- * the License. You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on
- * an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
- * specific language governing permissions and limitations under the License.
- *
- **********************************************************************************************************************/
-package eu.stratosphere.pact.testing;
-
-import it.unimi.dsi.fastutil.ints.Int2ObjectMap;
-
-import java.util.List;
-
-import eu.stratosphere.pact.common.type.PactRecord;
-import eu.stratosphere.pact.common.type.Value;
-
-/**
- * Simple matching algorithm that returns unmatched values but allows a value from one bag to be matched several times
- * against items from another bag.
- * 
- * @author Arvid.Heise
- * @param <PactRecord>
- */
-public abstract class AbstractValueMatcher implements FuzzyValueMatcher {
-	/**
-	 * Calculates the overall distance between the expected and actual record.
-	 */
-	@SuppressWarnings({ "unchecked", "rawtypes" })
-	protected double getDistance(Class<? extends Value>[] schema, Int2ObjectMap<List<ValueSimilarity<?>>> similarities,
-			PactRecord expectedRecord, PactRecord actualRecord) {
-		double distance = 0;
-		for (int index = 0; index < schema.length; index++) {
-			Value expected = expectedRecord.getField(index, schema[index]);
-			Value actual = actualRecord.getField(index, schema[index]);
-
-			List<ValueSimilarity<?>> sims = similarities.get(index);
-			if (sims == null) {
-				if (!Equaler.SafeEquals.equal(actual, expected) )
-					return ValueSimilarity.NO_MATCH;
-				continue;
-			}
-
-			double valueDistance = 0;
-			for (ValueSimilarity sim : sims) {
-				double simDistance = sim.getDistance(expected, actual);
-				if (simDistance < 0)
-					return simDistance;
-				valueDistance += simDistance;
-			}
-			distance += valueDistance / sims.size();
-		}
-		return distance;
-	}
-}
diff --git a/pact/pact-clients/src/main/java/eu/stratosphere/pact/testing/AbstractValueSimilarity.java b/pact/pact-clients/src/main/java/eu/stratosphere/pact/testing/AbstractValueSimilarity.java
deleted file mode 100644
index 1a32fbe..0000000
--- a/pact/pact-clients/src/main/java/eu/stratosphere/pact/testing/AbstractValueSimilarity.java
+++ /dev/null
@@ -1,32 +0,0 @@
-/***********************************************************************************************************************
- *
- * Copyright (C) 2010 by the Stratosphere project (http://stratosphere.eu)
- *
- * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with
- * the License. You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on
- * an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
- * specific language governing permissions and limitations under the License.
- *
- **********************************************************************************************************************/
-package eu.stratosphere.pact.testing;
-
-import eu.stratosphere.pact.common.type.Value;
-import eu.stratosphere.pact.common.util.ReflectionUtil;
-
-/**
- * @author Arvid Heise
- */
-public abstract class AbstractValueSimilarity<V extends Value> implements ValueSimilarity<V> {
-	/*
-	 * (non-Javadoc)
-	 * @see eu.stratosphere.pact.testing.ValueSimilarity#isApplicable(java.lang.Class)
-	 */
-	@Override
-	public boolean isApplicable(Class<? extends V> valueType) {
-		return ReflectionUtil.getTemplateType1(this.getClass()).isAssignableFrom(valueType);
-	}
-}
diff --git a/pact/pact-clients/src/main/java/eu/stratosphere/pact/testing/AssertUtil.java b/pact/pact-clients/src/main/java/eu/stratosphere/pact/testing/AssertUtil.java
deleted file mode 100644
index e1b6eb6..0000000
--- a/pact/pact-clients/src/main/java/eu/stratosphere/pact/testing/AssertUtil.java
+++ /dev/null
@@ -1,77 +0,0 @@
-/***********************************************************************************************************************
- *
- * Copyright (C) 2010 by the Stratosphere project (http://stratosphere.eu)
- *
- * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with
- * the License. You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on
- * an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
- * specific language governing permissions and limitations under the License.
- *
- **********************************************************************************************************************/
-
-package eu.stratosphere.pact.testing;
-
-import java.util.Iterator;
-
-import junit.framework.Assert;
-import junit.framework.AssertionFailedError;
-
-import org.junit.internal.ArrayComparisonFailure;
-
-/**
- * Additional assertions for unit tests.
- * 
- * @author Arvid Heise
- */
-public class AssertUtil {
-	/**
-	 * Asserts that two iterators generate equal series of objects.
-	 * 
-	 * @param message
-	 * @param expectedIterator
-	 * @param actualIterator
-	 */
-	public static <T> void assertIteratorEquals(String message, Iterator<? extends T> expectedIterator,
-			Iterator<? extends T> actualIterator, Equaler<T> equaler) {
-
-		int index = 0;
-		for (; actualIterator.hasNext() && expectedIterator.hasNext(); index++) {
-			final T expected = expectedIterator.next(), actual = actualIterator.next();
-			if (!equaler.equal(expected, actual))
-				throw new ArrayComparisonFailure(message, new AssertionFailedError(Assert.format(message, expected,
-					actual)), index);
-		}
-
-		if (expectedIterator.hasNext())
-			throw new ArrayComparisonFailure(message, new AssertionError("More elements expected"), index);
-		if (actualIterator.hasNext())
-			throw new ArrayComparisonFailure(message, new AssertionError("Less elements expected"), index);
-	}
-
-	/**
-	 * Asserts that two iterators generate equal series of objects.
-	 * 
-	 * @param expectedIterator
-	 * @param actualIterator
-	 */
-	public static <T> void assertIteratorEquals(Iterator<? extends T> expectedIterator,
-			Iterator<? extends T> actualIterator, Equaler<T> equaler) {
-		assertIteratorEquals(null, expectedIterator, actualIterator, equaler);
-	}
-
-	/**
-	 * Asserts that two iterators generate equal series of objects.
-	 * 
-	 * @param expectedIterator
-	 * @param actualIterator
-	 */
-	public static <T> void assertIteratorEquals(Iterator<? extends T> expectedIterator,
-			Iterator<? extends T> actualIterator) {
-		assertIteratorEquals(null, expectedIterator, actualIterator, Equaler.JavaEquals);
-	}
-
-}
diff --git a/pact/pact-clients/src/main/java/eu/stratosphere/pact/testing/ClosableManager.java b/pact/pact-clients/src/main/java/eu/stratosphere/pact/testing/ClosableManager.java
deleted file mode 100644
index c645502..0000000
--- a/pact/pact-clients/src/main/java/eu/stratosphere/pact/testing/ClosableManager.java
+++ /dev/null
@@ -1,65 +0,0 @@
-/***********************************************************************************************************************
- *
- * Copyright (C) 2010 by the Stratosphere project (http://stratosphere.eu)
- *
- * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with
- * the License. You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on
- * an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
- * specific language governing permissions and limitations under the License.
- *
- **********************************************************************************************************************/
-
-package eu.stratosphere.pact.testing;
-
-import java.io.Closeable;
-import java.io.IOException;
-import java.util.ArrayList;
-import java.util.List;
-
-/**
- * Collects other {@link java.io.Closeable}s and closes them once. Instances can be used further after a call to
- * {@link #close()}.
- * 
- * @author Arvid.Heise
- */
-public class ClosableManager implements Closeable {
-	private List<Closeable> closeables = new ArrayList<Closeable>();
-
-	@Override
-	protected void finalize() throws Throwable {
-		this.close();
-		super.finalize();
-	}
-
-	@Override
-	public synchronized void close() throws IOException {
-		List<IOException> exceptions = null;
-
-		for (Closeable closeable : this.closeables)
-			try {
-				closeable.close();
-			} catch (IOException e) {
-				if (exceptions == null)
-					exceptions = new ArrayList<IOException>();
-				exceptions.add(e);
-			}
-		this.closeables.clear();
-
-		if (exceptions != null)
-			throw new IOException("exception(s) while closing: " + exceptions);
-	}
-
-	/**
-	 * Adds a new {@link Closeable}.
-	 * 
-	 * @param closeable
-	 *        the closable to add
-	 */
-	public synchronized void add(Closeable closeable) {
-		this.closeables.add(closeable);
-	}
-}
diff --git a/pact/pact-clients/src/main/java/eu/stratosphere/pact/testing/ConcurrentUtil.java b/pact/pact-clients/src/main/java/eu/stratosphere/pact/testing/ConcurrentUtil.java
deleted file mode 100644
index 1a91b9c..0000000
--- a/pact/pact-clients/src/main/java/eu/stratosphere/pact/testing/ConcurrentUtil.java
+++ /dev/null
@@ -1,29 +0,0 @@
-/***********************************************************************************************************************
- *
- * Copyright (C) 2010 by the Stratosphere project (http://stratosphere.eu)
- *
- * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with
- * the License. You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on
- * an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
- * specific language governing permissions and limitations under the License.
- *
- **********************************************************************************************************************/
-package eu.stratosphere.pact.testing;
-
-import java.util.concurrent.ScheduledExecutorService;
-import java.util.concurrent.ScheduledThreadPoolExecutor;
-
-/**
- * @author Arvid Heise
- */
-public class ConcurrentUtil {
-	private static ScheduledExecutorService Executor = new ScheduledThreadPoolExecutor(1, new DaemonThreadFactory());
-
-	public static void invokeLater(Runnable runnable) {
-		Executor.execute(runnable);
-	}
-}
diff --git a/pact/pact-clients/src/main/java/eu/stratosphere/pact/testing/DaemonThreadFactory.java b/pact/pact-clients/src/main/java/eu/stratosphere/pact/testing/DaemonThreadFactory.java
deleted file mode 100644
index 8989bf5..0000000
--- a/pact/pact-clients/src/main/java/eu/stratosphere/pact/testing/DaemonThreadFactory.java
+++ /dev/null
@@ -1,32 +0,0 @@
-/***********************************************************************************************************************
- *
- * Copyright (C) 2010 by the Stratosphere project (http://stratosphere.eu)
- *
- * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with
- * the License. You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on
- * an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
- * specific language governing permissions and limitations under the License.
- *
- **********************************************************************************************************************/
-package eu.stratosphere.pact.testing;
-
-import java.util.concurrent.Executors;
-import java.util.concurrent.ThreadFactory;
-
-/**
- * @author Arvid Heise
- */
-public class DaemonThreadFactory implements ThreadFactory {
-	final ThreadFactory defaultFactory = Executors.defaultThreadFactory();
-
-	@Override
-	public Thread newThread(final Runnable r) {
-		Thread thread = this.defaultFactory.newThread(r);
-		thread.setDaemon(true);
-		return thread;
-	}
-}
diff --git a/pact/pact-clients/src/main/java/eu/stratosphere/pact/testing/DoubleValueSimilarity.java b/pact/pact-clients/src/main/java/eu/stratosphere/pact/testing/DoubleValueSimilarity.java
deleted file mode 100644
index e505f87..0000000
--- a/pact/pact-clients/src/main/java/eu/stratosphere/pact/testing/DoubleValueSimilarity.java
+++ /dev/null
@@ -1,56 +0,0 @@
-/***********************************************************************************************************************
- *
- * Copyright (C) 2010 by the Stratosphere project (http://stratosphere.eu)
- *
- * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with
- * the License. You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on
- * an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
- * specific language governing permissions and limitations under the License.
- *
- **********************************************************************************************************************/
-
-package eu.stratosphere.pact.testing;
-
-import eu.stratosphere.pact.common.type.base.PactDouble;
-
-/**
- * Computes the difference between double values and returns {@link FuzzyTestValueSimilarity#NO_MATCH} if the difference
- * is
- * above a given threshold.
- * 
- * @author Arvid Heise
- */
-public class DoubleValueSimilarity extends AbstractValueSimilarity<PactDouble> {
-	private double delta;
-
-	/**
-	 * Initializes DoubleValueSimilarity with the given threshold.
-	 * 
-	 * @param delta
-	 *        the threshold defining the maximum allowed difference.
-	 */
-	public DoubleValueSimilarity(double delta) {
-		this.delta = delta;
-	}
-
-	/**
-	 * Returns the threshold.
-	 * 
-	 * @return the threshold
-	 */
-	public double getDelta() {
-		return this.delta;
-	}
-
-	@Override
-	public double getDistance(PactDouble value1, PactDouble value2) {
-		double diff = Math.abs(value1.getValue() - value2.getValue());
-		if (diff <= this.delta)
-			return diff;
-		return NO_MATCH;
-	}
-}
\ No newline at end of file
diff --git a/pact/pact-clients/src/main/java/eu/stratosphere/pact/testing/Equaler.java b/pact/pact-clients/src/main/java/eu/stratosphere/pact/testing/Equaler.java
deleted file mode 100644
index a79ccd2..0000000
--- a/pact/pact-clients/src/main/java/eu/stratosphere/pact/testing/Equaler.java
+++ /dev/null
@@ -1,69 +0,0 @@
-/***********************************************************************************************************************
- *
- * Copyright (C) 2010 by the Stratosphere project (http://stratosphere.eu)
- *
- * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with
- * the License. You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on
- * an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
- * specific language governing permissions and limitations under the License.
- *
- **********************************************************************************************************************/
-package eu.stratosphere.pact.testing;
-
-/**
- * Represents the external definition of {@link Object#equals(Object)}. <code>Equaler</code> is needed when the class of
- * objects does not have an appropriate {@link Object#equals(Object)} definition.
- * 
- * @author Arvid Heise
- */
-public interface Equaler<T> {
-	/**
-	 * Returns true, if both objects are equal; false, otherwise.<br>
-	 * This method has similar semantic to <code>object1.equals(object2)</code>.
-	 * 
-	 * @param object1
-	 *        the first object
-	 * @param object2
-	 *        the second object
-	 * @return true, if both objects are equal; false, otherwise.
-	 */
-	public boolean equal(T object1, T object2);
-
-	public static Equaler<Object> JavaEquals = new JavaEquals(), SafeEquals = new SafeEquals();
-
-	/**
-	 * Wraps {@link Object#equals(Object)}.
-	 * 
-	 * @author Arvid Heise
-	 */
-	public static final class JavaEquals implements Equaler<Object> {
-		/*
-		 * (non-Javadoc)
-		 * @see eu.stratosphere.pact.testing.Equaler#equal(java.lang.Object, java.lang.Object)
-		 */
-		@Override
-		public boolean equal(Object object1, Object object2) {
-			return object1.equals(object2);
-		}
-	}
-
-	/**
-	 * Wraps {@link Object#equals(Object)} but honors possible <code>null</code> values.
-	 * 
-	 * @author Arvid Heise
-	 */
-	public static final class SafeEquals implements Equaler<Object> {
-		/*
-		 * (non-Javadoc)
-		 * @see eu.stratosphere.pact.testing.Equaler#equal(java.lang.Object, java.lang.Object)
-		 */
-		@Override
-		public boolean equal(Object object1, Object object2) {
-			return object1 == null ? object2 == null : object1.equals(object2);
-		}
-	}
-}
diff --git a/pact/pact-clients/src/main/java/eu/stratosphere/pact/testing/EqualityValueMatcher.java b/pact/pact-clients/src/main/java/eu/stratosphere/pact/testing/EqualityValueMatcher.java
deleted file mode 100644
index 7343893..0000000
--- a/pact/pact-clients/src/main/java/eu/stratosphere/pact/testing/EqualityValueMatcher.java
+++ /dev/null
@@ -1,68 +0,0 @@
-/***********************************************************************************************************************
- *
- * Copyright (C) 2010 by the Stratosphere project (http://stratosphere.eu)
- *
- * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with
- * the License. You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on
- * an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
- * specific language governing permissions and limitations under the License.
- *
- **********************************************************************************************************************/
-
-package eu.stratosphere.pact.testing;
-
-import it.unimi.dsi.fastutil.ints.Int2ObjectMap;
-
-import java.util.Collection;
-import java.util.Iterator;
-import java.util.List;
-
-import eu.stratosphere.pact.common.type.PactRecord;
-import eu.stratosphere.pact.common.type.Value;
-
-/**
- * Matches all exact matching pairs using equals.
- * 
- * @author Arvid Heise
- * @param <V>
- */
-public class EqualityValueMatcher implements FuzzyValueMatcher {
-	private Equaler<PactRecord> recordEqualer;
-
-	/**
-	 * Initializes EqualityValueMatcher.
-	 */
-	public EqualityValueMatcher() {
-		this(null);
-	}
-
-	public EqualityValueMatcher(Equaler<PactRecord> recordEqualer) {
-		this.recordEqualer = recordEqualer;
-	}
-
-	@Override
-	public void removeMatchingValues(Int2ObjectMap<List<ValueSimilarity<?>>> similarities,
-			Class<? extends Value>[] schema, Collection<PactRecord> expectedValues, Collection<PactRecord> actualValues) {
-		Equaler<PactRecord> recordEqualer = this.recordEqualer == null ? new PactRecordEqualer(schema)
-			: this.recordEqualer;
-
-		Iterator<PactRecord> actualIterator = actualValues.iterator();
-		while (!expectedValues.isEmpty() && actualIterator.hasNext()) {
-			// match
-			final PactRecord actual = actualIterator.next();
-
-			Iterator<PactRecord> expectedIterator = expectedValues.iterator();
-			while (expectedIterator.hasNext())
-				if (recordEqualer.equal(actual, expectedIterator.next())) {
-					actualIterator.remove();
-					expectedIterator.remove();
-					break;
-				}
-		}
-	}
-
-}
diff --git a/pact/pact-clients/src/main/java/eu/stratosphere/pact/testing/FuzzyValueMatcher.java b/pact/pact-clients/src/main/java/eu/stratosphere/pact/testing/FuzzyValueMatcher.java
deleted file mode 100644
index 4bf6c71..0000000
--- a/pact/pact-clients/src/main/java/eu/stratosphere/pact/testing/FuzzyValueMatcher.java
+++ /dev/null
@@ -1,52 +0,0 @@
-/***********************************************************************************************************************
- *
- * Copyright (C) 2010 by the Stratosphere project (http://stratosphere.eu)
- *
- * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with
- * the License. You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on
- * an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
- * specific language governing permissions and limitations under the License.
- *
- **********************************************************************************************************************/
-
-package eu.stratosphere.pact.testing;
-
-import it.unimi.dsi.fastutil.ints.Int2ObjectMap;
-
-import java.util.Collection;
-import java.util.List;
-
-import eu.stratosphere.pact.common.type.PactRecord;
-import eu.stratosphere.pact.common.type.Value;
-
-/**
- * Global match algorithm that uses a {@link FuzzyTestValueSimilarity} to match a bag of expected values with a bag of
- * actual values.
- * 
- * @author Arvid Heise
- * @param <V>
- *        the value type
- */
-public interface FuzzyValueMatcher {
-
-	/**
-	 * Removes all pairs of matching items from the two collections. The cardinality of both collections is guaranteed
-	 * to be the same on input and does not have to be equal on output. The given {@link FuzzyTestValueSimilarity}
-	 * defines the similarity measure between two values.<br>
-	 * Since both collections have the bag semantic, some values may appear multiple times. The algorithm should remove
-	 * only one value per matching pair unless otherwise documented.
-	 * 
-	 * @param similarities
-	 *        the similarity measures
-	 * @param expectedValues
-	 *        a bag of expected values
-	 * @param actualValues
-	 *        a bag of actual values
-	 */
-	public void removeMatchingValues(Int2ObjectMap<List<ValueSimilarity<?>>> similarities,
-			Class<? extends Value>[] schema, Collection<PactRecord> expectedValues, Collection<PactRecord> actualValues);
-}
\ No newline at end of file
diff --git a/pact/pact-clients/src/main/java/eu/stratosphere/pact/testing/ImmutableRecordIterator.java b/pact/pact-clients/src/main/java/eu/stratosphere/pact/testing/ImmutableRecordIterator.java
deleted file mode 100644
index 13cfb40..0000000
--- a/pact/pact-clients/src/main/java/eu/stratosphere/pact/testing/ImmutableRecordIterator.java
+++ /dev/null
@@ -1,75 +0,0 @@
-/***********************************************************************************************************************
- *
- * Copyright (C) 2010 by the Stratosphere project (http://stratosphere.eu)
- *
- * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with
- * the License. You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on
- * an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
- * specific language governing permissions and limitations under the License.
- *
- **********************************************************************************************************************/
-package eu.stratosphere.pact.testing;
-
-import java.io.IOException;
-import java.util.Iterator;
-
-import eu.stratosphere.pact.common.type.PactRecord;
-import eu.stratosphere.pact.common.util.MutableObjectIterator;
-
-/**
- * @author Arvid Heise
- */
-public class ImmutableRecordIterator implements Iterator<PactRecord> {
-	private PactRecord next;
-
-	private MutableObjectIterator<PactRecord> iterator;
-
-	private boolean hasNext;
-
-	public ImmutableRecordIterator(MutableObjectIterator<PactRecord> iterator) {
-		this.iterator = iterator;
-		try {
-			this.hasNext = iterator.next(this.next = new PactRecord());
-		} catch (IOException e) {
-			e.printStackTrace();
-		}
-	}
-
-	/*
-	 * (non-Javadoc)
-	 * @see java.util.Iterator#hasNext()
-	 */
-	@Override
-	public boolean hasNext() {
-		return this.hasNext;
-	}
-
-	/*
-	 * (non-Javadoc)
-	 * @see java.util.Iterator#next()
-	 */
-	@Override
-	public PactRecord next() {
-		PactRecord next = this.next;
-		try {
-			this.hasNext = this.iterator.next(this.next = new PactRecord());
-		} catch (IOException e) {
-			e.printStackTrace();
-		}
-		return next;
-	}
-
-	/*
-	 * (non-Javadoc)
-	 * @see java.util.Iterator#remove()
-	 */
-	@Override
-	public void remove() {
-		throw new UnsupportedOperationException();
-	}
-
-}
diff --git a/pact/pact-clients/src/main/java/eu/stratosphere/pact/testing/InputFileIterator.java b/pact/pact-clients/src/main/java/eu/stratosphere/pact/testing/InputFileIterator.java
deleted file mode 100644
index 31064ea..0000000
--- a/pact/pact-clients/src/main/java/eu/stratosphere/pact/testing/InputFileIterator.java
+++ /dev/null
@@ -1,118 +0,0 @@
-/***********************************************************************************************************************
- *
- * Copyright (C) 2010 by the Stratosphere project (http://stratosphere.eu)
- *
- * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with
- * the License. You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on
- * an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
- * specific language governing permissions and limitations under the License.
- *
- **********************************************************************************************************************/
-
-package eu.stratosphere.pact.testing;
-
-import java.io.Closeable;
-import java.io.IOException;
-import java.util.Arrays;
-import java.util.Iterator;
-import java.util.List;
-import java.util.NoSuchElementException;
-
-import junit.framework.Assert;
-import eu.stratosphere.nephele.util.StringUtils;
-import eu.stratosphere.pact.common.io.FileInputFormat;
-import eu.stratosphere.pact.common.type.PactRecord;
-
-/**
- * Provides an {@link Iterator} for {@link InputFormat}s. If multiple formats are specified, it is assumed that they are
- * homogeneous and most likely the result of a parallel execution of the previous {@link Stub}.
- * 
- * @author Arvid Heise
- * @param <K>
- *        the type of the keys
- * @param <V>
- *        the type of the values
- */
-public class InputFileIterator implements Iterator<PactRecord>, Closeable {
-	private final List<FileInputFormat> inputFormats;
-
-	private final Iterator<FileInputFormat> formatIterator;
-
-	private FileInputFormat currentFormat;
-
-	private PactRecord[] buffer = new PactRecord[] { new PactRecord(), new PactRecord() };
-
-	private int bufferIndex;
-
-	private PactRecord nextRecord;
-
-	private static PactRecord NO_MORE_PAIR = new PactRecord();
-
-	/**
-	 * Initializes InputFileIterator from already configured and opened {@link InputFormat}s.
-	 * 
-	 * @param reusePair
-	 *        true if the pair needs only to be created once and is refilled for each subsequent {@link #next()}
-	 * @param inputFormats
-	 *        the inputFormats to wrap
-	 */
-	public InputFileIterator(final FileInputFormat... inputFormats) {
-		this.inputFormats = Arrays.asList(inputFormats);
-		this.formatIterator = this.inputFormats.iterator();
-		this.currentFormat = this.formatIterator.next();
-
-		this.loadNextPair();
-	}
-
-	@Override
-	public boolean hasNext() {
-		return this.nextRecord != NO_MORE_PAIR;
-	}
-
-	private void loadNextPair() {
-		try {
-			do {
-				while (this.currentFormat != null && this.currentFormat.reachedEnd())
-					if (this.formatIterator.hasNext())
-						this.currentFormat = this.formatIterator.next();
-					else {
-						this.nextRecord = NO_MORE_PAIR;
-						return;
-					}
-
-				this.nextRecord = this.buffer[this.bufferIndex++ % 2];
-			} while (!this.currentFormat.nextRecord(this.nextRecord));
-
-		} catch (final IOException e) {
-			this.nextRecord = NO_MORE_PAIR;
-			Assert.fail("reading expected values " + StringUtils.stringifyException(e));
-		}
-	}
-
-	@Override
-	public PactRecord next() {
-		if (!this.hasNext())
-			throw new NoSuchElementException();
-		final PactRecord pair = this.nextRecord;
-		this.loadNextPair();
-		return pair;
-	}
-
-	@Override
-	public void close() throws IOException {
-		for (final FileInputFormat inputFormat : this.inputFormats)
-			inputFormat.close();
-	}
-
-	/**
-	 * Not supported.
-	 */
-	@Override
-	public void remove() {
-		throw new UnsupportedOperationException();
-	}
-}
\ No newline at end of file
diff --git a/pact/pact-clients/src/main/java/eu/stratosphere/pact/testing/InputOutputAdder.java b/pact/pact-clients/src/main/java/eu/stratosphere/pact/testing/InputOutputAdder.java
deleted file mode 100644
index 8e32ed3..0000000
--- a/pact/pact-clients/src/main/java/eu/stratosphere/pact/testing/InputOutputAdder.java
+++ /dev/null
@@ -1,71 +0,0 @@
-/***********************************************************************************************************************
- *
- * Copyright (C) 2010 by the Stratosphere project (http://stratosphere.eu)
- *
- * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with
- * the License. You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on
- * an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
- * specific language governing permissions and limitations under the License.
- *
- **********************************************************************************************************************/
-
-package eu.stratosphere.pact.testing;
-
-import java.util.List;
-
-import eu.stratosphere.pact.common.contract.FileDataSink;
-import eu.stratosphere.pact.common.contract.GenericDataSink;
-import eu.stratosphere.pact.common.plan.ContractUtil;
-import eu.stratosphere.pact.common.plan.Visitor;
-import eu.stratosphere.pact.generic.contract.Contract;
-
-/**
- * Adds missing {@link DataSourceContract} and {@link DataSinkContract} to an incomplete plan.
- * 
- * @author Arvid Heise
- */
-class InputOutputAdder implements Visitor<Contract> {
-	/*
-	 * (non-Javadoc)
-	 * @see eu.stratosphere.pact.common.plan.Visitor#preVisit(eu.stratosphere.pact.common.plan.Visitable)
-	 */
-	@Override
-	public boolean preVisit(Contract visitable) {
-		return true;
-	}
-
-	/*
-	 * (non-Javadoc)
-	 * @see eu.stratosphere.pact.common.plan.Visitor#postVisit(eu.stratosphere.pact.common.plan.Visitable)
-	 */
-	@Override
-	public void postVisit(Contract contract) {
-		List<List<Contract>> inputs = ContractUtil.getInputs(contract);
-		for (int index = 0; index < inputs.size(); index++)
-			if (inputs.get(index).isEmpty())
-				inputs.get(index).add(
-					TestPlan.createDefaultSource(String.format("%s-input%d", contract.getName(), index)));
-		ContractUtil.setInputs(contract, inputs);
-	}
-
-	public Contract[] process(final Contract[] contracts) {
-		for (Contract contract : contracts)
-			contract.accept(this);
-
-		for (int index = 0; index < contracts.length; index++)
-			if (!(contracts[index] instanceof GenericDataSink))
-				contracts[index] = this.replaceWithDefaultOutput(contracts[index]);
-
-		return contracts;
-	}
-
-	private Contract replaceWithDefaultOutput(final Contract contract) {
-		final FileDataSink defaultSink = TestPlan.createDefaultSink(contract.getName() + "-output");
-		defaultSink.addInput(contract);
-		return defaultSink;
-	}
-}
\ No newline at end of file
diff --git a/pact/pact-clients/src/main/java/eu/stratosphere/pact/testing/MockChannelBroker.java b/pact/pact-clients/src/main/java/eu/stratosphere/pact/testing/MockChannelBroker.java
deleted file mode 100644
index 926dfcc..0000000
--- a/pact/pact-clients/src/main/java/eu/stratosphere/pact/testing/MockChannelBroker.java
+++ /dev/null
@@ -1,30 +0,0 @@
-/***********************************************************************************************************************
- *
- * Copyright (C) 2010 by the Stratosphere project (http://stratosphere.eu)
- *
- * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with
- * the License. You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on
- * an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
- * specific language governing permissions and limitations under the License.
- *
- **********************************************************************************************************************/
-package eu.stratosphere.pact.testing;
-
-import eu.stratosphere.nephele.io.channels.AbstractChannel;
-import eu.stratosphere.nephele.taskmanager.transferenvelope.TransferEnvelope;
-
-/**
- * @author Arvid Heise
- */
-public interface MockChannelBroker {
-	public AbstractChannel getChannel();
-
-	/**
-	 * @param event
-	 */
-	public void queueTransferEnvelope(TransferEnvelope transferEnvelope);
-}
diff --git a/pact/pact-clients/src/main/java/eu/stratosphere/pact/testing/MockChannelLookup.java b/pact/pact-clients/src/main/java/eu/stratosphere/pact/testing/MockChannelLookup.java
deleted file mode 100644
index 8487b7d..0000000
--- a/pact/pact-clients/src/main/java/eu/stratosphere/pact/testing/MockChannelLookup.java
+++ /dev/null
@@ -1,42 +0,0 @@
-/***********************************************************************************************************************
- *
- * Copyright (C) 2010 by the Stratosphere project (http://stratosphere.eu)
- *
- * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with
- * the License. You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on
- * an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
- * specific language governing permissions and limitations under the License.
- *
- **********************************************************************************************************************/
-package eu.stratosphere.pact.testing;
-
-import java.io.IOException;
-
-import eu.stratosphere.nephele.instance.InstanceConnectionInfo;
-import eu.stratosphere.nephele.io.channels.ChannelID;
-import eu.stratosphere.nephele.jobgraph.JobID;
-import eu.stratosphere.nephele.protocols.ChannelLookupProtocol;
-import eu.stratosphere.nephele.taskmanager.bytebuffered.ConnectionInfoLookupResponse;
-
-/**
- * @author arv
- */
-public class MockChannelLookup implements ChannelLookupProtocol {
-
-	/*
-	 * (non-Javadoc)
-	 * @see
-	 * eu.stratosphere.nephele.protocols.ChannelLookupProtocol#lookupConnectionInfo(eu.stratosphere.nephele.instance
-	 * .InstanceConnectionInfo, eu.stratosphere.nephele.jobgraph.JobID, eu.stratosphere.nephele.io.channels.ChannelID)
-	 */
-	@Override
-	public ConnectionInfoLookupResponse lookupConnectionInfo(InstanceConnectionInfo caller, JobID jobID,
-			ChannelID sourceChannelID) throws IOException {
-		return null;
-	}
-
-}
diff --git a/pact/pact-clients/src/main/java/eu/stratosphere/pact/testing/MockChannelManager.java b/pact/pact-clients/src/main/java/eu/stratosphere/pact/testing/MockChannelManager.java
deleted file mode 100644
index 9034941..0000000
--- a/pact/pact-clients/src/main/java/eu/stratosphere/pact/testing/MockChannelManager.java
+++ /dev/null
@@ -1,170 +0,0 @@
-/***********************************************************************************************************************
- *
- * Copyright (C) 2010 by the Stratosphere project (http://stratosphere.eu)
- *
- * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with
- * the License. You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on
- * an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
- * specific language governing permissions and limitations under the License.
- *
- **********************************************************************************************************************/
-package eu.stratosphere.pact.testing;
-
-import java.util.Map;
-import java.util.concurrent.ConcurrentHashMap;
-
-import org.apache.commons.logging.Log;
-import org.apache.commons.logging.LogFactory;
-
-import eu.stratosphere.nephele.execution.RuntimeEnvironment;
-import eu.stratosphere.nephele.io.InputGate;
-import eu.stratosphere.nephele.io.OutputGate;
-import eu.stratosphere.nephele.io.channels.AbstractChannel;
-import eu.stratosphere.nephele.io.channels.AbstractInputChannel;
-import eu.stratosphere.nephele.io.channels.AbstractOutputChannel;
-import eu.stratosphere.nephele.io.channels.ChannelID;
-import eu.stratosphere.nephele.io.channels.bytebuffered.AbstractByteBufferedInputChannel;
-import eu.stratosphere.nephele.io.channels.bytebuffered.AbstractByteBufferedOutputChannel;
-import eu.stratosphere.nephele.taskmanager.bufferprovider.LocalBufferPool;
-import eu.stratosphere.nephele.taskmanager.transferenvelope.TransferEnvelope;
-import eu.stratosphere.nephele.taskmanager.transferenvelope.TransferEnvelopeDispatcher;
-import eu.stratosphere.nephele.types.Record;
-
-/**
- * @author Arvid Heise
- */
-public class MockChannelManager implements TransferEnvelopeDispatcher {
-	private static final Log LOG = LogFactory.getLog(MockChannelManager.class);
-
-	private LocalBufferPool transitBufferPool;
-
-	private Map<ChannelID, MockChannelBroker> registeredChannels =
-		new ConcurrentHashMap<ChannelID, MockChannelBroker>();
-
-	/**
-	 * Initializes MockChannelManager.
-	 */
-	public MockChannelManager() {
-		this.transitBufferPool = new LocalBufferPool(128, true);
-	}
-
-	protected synchronized void registerChannels(RuntimeEnvironment environment) {
-		for (int i = 0; i < environment.getNumberOfOutputGates(); ++i) {
-			OutputGate<? extends Record> outputGate = environment.getOutputGate(i);
-			for (int j = 0; j < outputGate.getNumberOfOutputChannels(); ++j) {
-				final AbstractOutputChannel<?> outputChannel = outputGate.getOutputChannel(j);
-				if (!(outputChannel instanceof AbstractByteBufferedOutputChannel)) {
-					LOG.error("Output channel " + outputChannel.getID() + "of job " + environment.getJobID()
-						+ " is not a byte buffered output channel, skipping...");
-					continue;
-				}
-
-				final AbstractByteBufferedOutputChannel<?> bboc = (AbstractByteBufferedOutputChannel<?>) outputChannel;
-				MockOutputChannelBroker channelBroker = new MockOutputChannelBroker(bboc, this.transitBufferPool, this);
-				bboc.setByteBufferedOutputChannelBroker(channelBroker);
-				this.registeredChannels.put(bboc.getID(), channelBroker);
-			}
-		}
-
-		for (int i = 0; i < environment.getNumberOfInputGates(); ++i) {
-			final InputGate<?> inputGate = environment.getInputGate(i);
-			for (int j = 0; j < inputGate.getNumberOfInputChannels(); ++j) {
-				final AbstractInputChannel<?> inputChannel = inputGate.getInputChannel(j);
-				if (!(inputChannel instanceof AbstractByteBufferedInputChannel)) {
-					LOG.error("Input channel " + inputChannel.getID() + "of job " + environment.getJobID()
-						+ " is not a byte buffered input channel, skipping...");
-					continue;
-				}
-
-				final AbstractByteBufferedInputChannel<?> bbic = (AbstractByteBufferedInputChannel<?>) inputChannel;
-				MockInputChannelBroker channelBroker = new MockInputChannelBroker(bbic, this);
-				bbic.setInputChannelBroker(channelBroker);
-				this.registeredChannels.put(bbic.getID(), channelBroker);
-			}
-		}
-	}
-
-	private synchronized void processEnvelope(final TransferEnvelope transferEnvelope) {
-		try {
-			AbstractChannel sourceChannel = this.registeredChannels.get(transferEnvelope.getSource()).getChannel();
-
-			final ChannelID localReceiver = sourceChannel.getConnectedChannelID();
-
-			final MockChannelBroker channel = this.registeredChannels.get(localReceiver);
-
-			// if(transferEnvelope.getBuffer() == null)
-			if (channel == null)
-				System.err.println("Unknown channel " + localReceiver);
-			else
-				channel.queueTransferEnvelope(transferEnvelope);
-		} catch (Exception e) {
-			e.printStackTrace();
-		}
-	}
-
-	/**
-	 * {@inheritDoc}
-	 */
-	@Override
-	public void processEnvelopeFromOutputChannel(final TransferEnvelope transferEnvelope) {
-		this.processEnvelope(transferEnvelope);
-	}
-
-	/**
-	 * {@inheritDoc}
-	 */
-	@Override
-	public void processEnvelopeFromInputChannel(final TransferEnvelope transferEnvelope) {
-		this.processEnvelope(transferEnvelope);
-	}
-
-	/**
-	 * {@inheritDoc}
-	 */
-	@Override
-	public void processEnvelopeFromNetwork(final TransferEnvelope transferEnvelope, boolean freeSourceBuffer) {
-		this.processEnvelope(transferEnvelope);
-	}
-
-	/**
-	 * @param environment
-	 */
-	public void unregisterChannels(RuntimeEnvironment environment) {
-		for (int i = 0; i < environment.getNumberOfOutputGates(); ++i) {
-			OutputGate<? extends Record> outputGate = environment.getOutputGate(i);
-			for (int j = 0; j < outputGate.getNumberOfOutputChannels(); ++j) {
-				final AbstractOutputChannel<?> outputChannel = outputGate.getOutputChannel(j);
-				if (!(outputChannel instanceof AbstractByteBufferedOutputChannel)) {
-					LOG.error("Output channel " + outputChannel.getID() + "of job " + environment.getJobID()
-						+ " is not a byte buffered output channel, skipping...");
-					continue;
-				}
-
-				final AbstractByteBufferedOutputChannel<?> bboc = (AbstractByteBufferedOutputChannel<?>) outputChannel;
-				this.registeredChannels.remove(bboc.getID());
-			}
-		}
-
-		for (int i = 0; i < environment.getNumberOfInputGates(); ++i) {
-			final InputGate<?> inputGate = environment.getInputGate(i);
-			for (int j = 0; j < inputGate.getNumberOfInputChannels(); ++j) {
-				final AbstractInputChannel<?> inputChannel = inputGate.getInputChannel(j);
-				if (!(inputChannel instanceof AbstractByteBufferedInputChannel)) {
-					LOG.error("Input channel " + inputChannel.getID() + "of job " + environment.getJobID()
-						+ " is not a byte buffered input channel, skipping...");
-					continue;
-				}
-
-				final AbstractByteBufferedInputChannel<?> bbic = (AbstractByteBufferedInputChannel<?>) inputChannel;
-				MockInputChannelBroker channelBroker = new MockInputChannelBroker(bbic, this);
-				bbic.setInputChannelBroker(channelBroker);
-				this.registeredChannels.remove(bbic.getID());
-			}
-		}
-	}
-
-}
diff --git a/pact/pact-clients/src/main/java/eu/stratosphere/pact/testing/MockDeployManager.java b/pact/pact-clients/src/main/java/eu/stratosphere/pact/testing/MockDeployManager.java
deleted file mode 100644
index 0e55a0f..0000000
--- a/pact/pact-clients/src/main/java/eu/stratosphere/pact/testing/MockDeployManager.java
+++ /dev/null
@@ -1,116 +0,0 @@
-/***********************************************************************************************************************
- *
- * Copyright (C) 2010 by the Stratosphere project (http://stratosphere.eu)
- *
- * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with
- * the License. You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on
- * an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
- * specific language governing permissions and limitations under the License.
- *
- **********************************************************************************************************************/
-package eu.stratosphere.pact.testing;
-
-import java.io.IOException;
-import java.util.List;
-
-import org.junit.Assert;
-
-import eu.stratosphere.nephele.deployment.TaskDeploymentDescriptor;
-import eu.stratosphere.nephele.execution.ExecutionState;
-import eu.stratosphere.nephele.executiongraph.ExecutionVertex;
-import eu.stratosphere.nephele.instance.AbstractInstance;
-import eu.stratosphere.nephele.jobgraph.JobID;
-import eu.stratosphere.nephele.jobmanager.DeploymentManager;
-import eu.stratosphere.nephele.taskmanager.AbstractTaskResult;
-import eu.stratosphere.nephele.taskmanager.TaskSubmissionResult;
-import eu.stratosphere.nephele.util.SerializableArrayList;
-
-/**
- * @author Arvid Heise
- */
-public class MockDeployManager implements DeploymentManager {
-	public final static MockDeployManager INSTANCE = new MockDeployManager();
-
-	/**
-	 * {@inheritDoc}
-	 */
-	@Override
-	public void deploy(final JobID jobID, final AbstractInstance instance,
-			final List<ExecutionVertex> verticesToBeDeployed) {
-		// final Iterator<ExecutionVertex> it = verticesToBeDeployed.iterator();
-		// while (it.hasNext()) {
-		//
-		// final ExecutionVertex executionVertex = it.next();
-		//
-		// ExecutionExceptionHandler executionListener = new ExecutionExceptionHandler(executionVertex);
-		// final Environment environment = executionVertex.getEnvironment();
-		// // environment.setExecutionObserver(executionListener);
-		// environment.setInputSplitProvider(new MockInputSplitProvider(executionVertex));
-		// this.errorHandlers.add(executionListener);
-		//
-		// final TaskSubmissionResult submissionResult = executionVertex
-		// .startTask();
-		//
-		// if (submissionResult.getReturnCode() == AbstractTaskResult.ReturnCode.ERROR)
-		// Assert.fail(submissionResult.getDescription() + " @ " + executionVertex);
-		//
-		// executionVertex.updateExecutionState(ExecutionState.STARTING, null);
-		// }
-		//
-
-		for (final ExecutionVertex vertex : verticesToBeDeployed)
-			vertex.updateExecutionState(ExecutionState.STARTING, null);
-
-		// Create a new runnable and pass it the executor service
-		final Runnable deploymentRunnable = new Runnable() {
-
-			/**
-			 * {@inheritDoc}
-			 */
-			@Override
-			public void run() {
-				final List<TaskDeploymentDescriptor> submissionList =
-					new SerializableArrayList<TaskDeploymentDescriptor>();
-
-				// Check the consistency of the call
-				for (final ExecutionVertex vertex : verticesToBeDeployed) {
-					// RuntimeEnvironment environment = vertex.getEnvironment();
-					// environment.setExecutionObserver(new MockInputSplitProvider(vertex));
-
-					submissionList.add(vertex.constructDeploymentDescriptor());
-
-					// new TaskDeploymentDescriptor(vertex.getID(), environment, vertex
-					// .getExecutionGraph().getJobConfiguration(), CheckpointState.NONE, vertex
-					// .constructInitialActiveOutputChannelsSet()));
-				}
-
-				List<TaskSubmissionResult> submissionResultList = null;
-
-				try {
-					submissionResultList = instance.submitTasks(submissionList);
-				} catch (final IOException ioe) {
-					for (final ExecutionVertex vertex : verticesToBeDeployed)
-						Assert.fail(ioe.getMessage() + " @ " + vertex);
-					return;
-				}
-
-				int count = 0;
-				for (final TaskSubmissionResult tsr : submissionResultList) {
-
-					ExecutionVertex vertex = verticesToBeDeployed.get(count++);
-
-					if (tsr.getReturnCode() != AbstractTaskResult.ReturnCode.SUCCESS)
-						// Change the execution state to failed and let the scheduler deal with the rest
-						vertex.updateExecutionState(ExecutionState.FAILED, tsr.getDescription());
-				}
-			}
-		};
-
-		ConcurrentUtil.invokeLater(deploymentRunnable);
-	}
-
-}
diff --git a/pact/pact-clients/src/main/java/eu/stratosphere/pact/testing/MockInputChannelBroker.java b/pact/pact-clients/src/main/java/eu/stratosphere/pact/testing/MockInputChannelBroker.java
deleted file mode 100644
index 4ffa31e..0000000
--- a/pact/pact-clients/src/main/java/eu/stratosphere/pact/testing/MockInputChannelBroker.java
+++ /dev/null
@@ -1,174 +0,0 @@
-/***********************************************************************************************************************
- *
- * Copyright (C) 2010 by the Stratosphere project (http://stratosphere.eu)
- *
- * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with
- * the License. You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on
- * an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
- * specific language governing permissions and limitations under the License.
- *
- **********************************************************************************************************************/
-package eu.stratosphere.pact.testing;
-
-import java.io.IOException;
-import java.util.Iterator;
-import java.util.LinkedList;
-import java.util.Queue;
-
-import eu.stratosphere.nephele.event.task.AbstractEvent;
-import eu.stratosphere.nephele.event.task.EventList;
-import eu.stratosphere.nephele.io.channels.Buffer;
-import eu.stratosphere.nephele.io.channels.bytebuffered.AbstractByteBufferedInputChannel;
-import eu.stratosphere.nephele.io.channels.bytebuffered.ByteBufferedInputChannelBroker;
-import eu.stratosphere.nephele.io.compression.CompressionException;
-import eu.stratosphere.nephele.io.compression.Decompressor;
-import eu.stratosphere.nephele.taskmanager.transferenvelope.TransferEnvelope;
-import eu.stratosphere.nephele.taskmanager.transferenvelope.TransferEnvelopeDispatcher;
-
-/**
- * @author Arvid Heise
- */
-public class MockInputChannelBroker implements ByteBufferedInputChannelBroker, MockChannelBroker {
-	private final AbstractByteBufferedInputChannel<?> bbic;
-
-	private TransferEnvelopeDispatcher transferEnvelopeDispatcher;
-
-	private Queue<TransferEnvelope> queuedEnvelopes = new LinkedList<TransferEnvelope>();
-
-	/**
-	 * Initializes MockInputChannelBroker.
-	 * 
-	 * @param bbic
-	 * @param transitBufferPool
-	 */
-	public MockInputChannelBroker(AbstractByteBufferedInputChannel<?> bbic,
-			TransferEnvelopeDispatcher transferEnvelopeDispatcher) {
-		this.bbic = bbic;
-		this.transferEnvelopeDispatcher = transferEnvelopeDispatcher;
-	}
-
-	/*
-	 * (non-Javadoc)
-	 * @see eu.stratosphere.nephele.io.channels.bytebuffered.ByteBufferedInputChannelBroker#releaseConsumedReadBuffer()
-	 */
-	@Override
-	public void releaseConsumedReadBuffer(final Buffer buffer) {
-		TransferEnvelope transferEnvelope = null;
-		synchronized (this.queuedEnvelopes) {
-
-			if (this.queuedEnvelopes.isEmpty())
-				return;
-
-			transferEnvelope = this.queuedEnvelopes.poll();
-		}
-
-		final Buffer consumedBuffer = transferEnvelope.getBuffer();
-		if (consumedBuffer == null)
-			return;
-
-		// Recycle consumed read buffer
-		buffer.recycleBuffer();
-	}
-
-	/*
-	 * (non-Javadoc)
-	 * @see eu.stratosphere.nephele.io.channels.bytebuffered.ByteBufferedInputChannelBroker#getReadBufferToConsume()
-	 */
-	@Override
-	public Buffer getReadBufferToConsume() {
-		TransferEnvelope transferEnvelope = null;
-
-		synchronized (this.queuedEnvelopes) {
-
-			if (this.queuedEnvelopes.isEmpty())
-				return null;
-
-			transferEnvelope = this.queuedEnvelopes.peek();
-
-			// If envelope does not have a buffer, remove it immediately
-			if (transferEnvelope.getBuffer() == null)
-				this.queuedEnvelopes.poll();
-		}
-
-		// Make sure we have all necessary buffers before we go on
-		if (transferEnvelope.getBuffer() == null) {
-
-			// No buffers necessary
-			final EventList eventList = transferEnvelope.getEventList();
-			if (eventList != null)
-				if (!eventList.isEmpty()) {
-					final Iterator<AbstractEvent> it = eventList.iterator();
-					while (it.hasNext())
-						this.bbic.processEvent(it.next());
-				}
-
-			return null;
-		}
-
-		final Buffer buffer = transferEnvelope.getBuffer(); // No need to copy anything
-
-		// Process events
-		final EventList eventList = transferEnvelope.getEventList();
-		if (eventList != null)
-			if (!eventList.isEmpty()) {
-				final Iterator<AbstractEvent> it = eventList.iterator();
-				while (it.hasNext())
-					this.bbic.processEvent(it.next());
-			}
-
-		return buffer;
-	}
-
-	/*
-	 * (non-Javadoc)
-	 * @see
-	 * eu.stratosphere.nephele.io.channels.bytebuffered.ByteBufferedInputChannelBroker#transferEventToOutputChannel(
-	 * eu.stratosphere.nephele.event.task.AbstractEvent)
-	 */
-	@Override
-	public void transferEventToOutputChannel(AbstractEvent event) throws IOException, InterruptedException {
-		final TransferEnvelope ephemeralTransferEnvelope = new TransferEnvelope(0, this.bbic.getJobID(),
-			this.bbic.getID());
-		ephemeralTransferEnvelope.addEvent(event);
-		this.transferEnvelopeDispatcher.processEnvelopeFromInputChannel(ephemeralTransferEnvelope);
-	}
-
-	/*
-	 * (non-Javadoc)
-	 * @see
-	 * eu.stratosphere.pact.testing.MockChannelBroker#queueTransferEnvelope(eu.stratosphere.nephele.event.task.AbstractEvent
-	 * )
-	 */
-	@Override
-	public void queueTransferEnvelope(TransferEnvelope transferEnvelope) {
-		synchronized (this.queuedEnvelopes) {
-			this.queuedEnvelopes.add(transferEnvelope);
-		}
-
-		// Notify the channel about the new data
-		this.bbic.checkForNetworkEvents();
-	}
-
-	/*
-	 * (non-Javadoc)
-	 * @see eu.stratosphere.pact.testing.MockChannelBroker#getChannel()
-	 */
-	@Override
-	public AbstractByteBufferedInputChannel<?> getChannel() {
-		return this.bbic;
-	}
-
-	/*
-	 * (non-Javadoc)
-	 * @see eu.stratosphere.nephele.io.channels.bytebuffered.ByteBufferedInputChannelBroker#getDecompressor()
-	 */
-	@Override
-	public Decompressor getDecompressor() throws CompressionException {
-
-		return null;
-	}
-}
diff --git a/pact/pact-clients/src/main/java/eu/stratosphere/pact/testing/MockInputSplitProvider.java b/pact/pact-clients/src/main/java/eu/stratosphere/pact/testing/MockInputSplitProvider.java
deleted file mode 100644
index 90d043d..0000000
--- a/pact/pact-clients/src/main/java/eu/stratosphere/pact/testing/MockInputSplitProvider.java
+++ /dev/null
@@ -1,40 +0,0 @@
-/***********************************************************************************************************************
- *
- * Copyright (C) 2010 by the Stratosphere project (http://stratosphere.eu)
- *
- * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with
- * the License. You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on
- * an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
- * specific language governing permissions and limitations under the License.
- *
- **********************************************************************************************************************/
-package eu.stratosphere.pact.testing;
-
-import java.util.concurrent.atomic.AtomicInteger;
-
-import eu.stratosphere.nephele.executiongraph.ExecutionVertex;
-import eu.stratosphere.nephele.jobmanager.splitassigner.InputSplitManager;
-import eu.stratosphere.nephele.template.InputSplit;
-import eu.stratosphere.nephele.template.InputSplitProvider;
-
-final class MockInputSplitProvider implements InputSplitProvider {
-	private ExecutionVertex vertex;
-
-	final AtomicInteger sequenceNumber = new AtomicInteger(0);
-
-	private InputSplitManager inputSplitManager;
-
-	public MockInputSplitProvider(InputSplitManager inputSplitManager, ExecutionVertex vertex) {
-		this.vertex = vertex;
-		this.inputSplitManager = inputSplitManager;
-	}
-
-	@Override
-	public InputSplit getNextInputSplit() {
-		return this.inputSplitManager.getNextInputSplit(this.vertex, this.sequenceNumber.getAndIncrement());
-	}
-}
\ No newline at end of file
diff --git a/pact/pact-clients/src/main/java/eu/stratosphere/pact/testing/MockInstance.java b/pact/pact-clients/src/main/java/eu/stratosphere/pact/testing/MockInstance.java
deleted file mode 100644
index e8c1ce3..0000000
--- a/pact/pact-clients/src/main/java/eu/stratosphere/pact/testing/MockInstance.java
+++ /dev/null
@@ -1,105 +0,0 @@
-/***********************************************************************************************************************
- *
- * Copyright (C) 2010 by the Stratosphere project (http://stratosphere.eu)
- *
- * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with
- * the License. You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on
- * an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
- * specific language governing permissions and limitations under the License.
- *
- **********************************************************************************************************************/
-
-package eu.stratosphere.pact.testing;
-
-import java.io.IOException;
-import java.net.InetAddress;
-import java.net.UnknownHostException;
-import java.util.List;
-
-import junit.framework.Assert;
-import eu.stratosphere.nephele.deployment.TaskDeploymentDescriptor;
-import eu.stratosphere.nephele.executiongraph.ExecutionVertexID;
-import eu.stratosphere.nephele.instance.AbstractInstance;
-import eu.stratosphere.nephele.instance.HardwareDescription;
-import eu.stratosphere.nephele.instance.HardwareDescriptionFactory;
-import eu.stratosphere.nephele.instance.InstanceConnectionInfo;
-import eu.stratosphere.nephele.instance.InstanceType;
-import eu.stratosphere.nephele.jobgraph.JobID;
-import eu.stratosphere.nephele.taskmanager.TaskCancelResult;
-import eu.stratosphere.nephele.taskmanager.TaskSubmissionResult;
-import eu.stratosphere.nephele.topology.NetworkTopology;
-import eu.stratosphere.nephele.util.StringUtils;
-
-/**
- * Mocks the localhost as an {@link AbstractInstance}.
- * 
- * @author Arvid Heise
- */
-class MockInstance extends AbstractInstance {
-	public final static HardwareDescription DESCRIPTION = HardwareDescriptionFactory
-		.construct(1, 256 << 20, 128 << 20);
-
-	// private final Map<ChannelID, String> fileNames = new HashMap<ChannelID,
-	// String>();
-
-	MockInstance(final InstanceType instanceType, final NetworkTopology networkTopology) {
-		super(instanceType, createConnectionInfo(), networkTopology
-			.getRootNode(), networkTopology, DESCRIPTION);
-	}
-
-	@Override
-	public synchronized void checkLibraryAvailability(final JobID jobID)
-			throws IOException {
-
-	}
-
-	/*
-	 * (non-Javadoc)
-	 * @see eu.stratosphere.nephele.instance.AbstractInstance#submitTasks(java.util.List)
-	 */
-	@Override
-	public synchronized List<TaskSubmissionResult> submitTasks(List<TaskDeploymentDescriptor> tasks) throws IOException {
-		return this.mockTaskManager.submitTasks(tasks);
-	}
-
-	/*
-	 * (non-Javadoc)
-	 * @see
-	 * eu.stratosphere.nephele.instance.AbstractInstance#cancelTask(eu.stratosphere.nephele.executiongraph.ExecutionVertexID
-	 * )
-	 */
-	@Override
-	public synchronized TaskCancelResult cancelTask(ExecutionVertexID id) throws IOException {
-		return this.mockTaskManager.cancelTask(id);
-	}
-
-	//
-	// @Override
-	// public String getUniqueFilename(final ChannelID id) {
-	// String name = this.fileNames.get(id);
-	// if (name == null)
-	// try {
-	// final File file = File.createTempFile("mock", id.toString());
-	// file.delete();
-	// this.fileNames.put(id, name = file.getName());
-	// } catch (final IOException e) {
-	// }
-	// return name;
-	// }
-
-	private MockTaskManager mockTaskManager = MockTaskManager.INSTANCE;
-
-	private static InstanceConnectionInfo createConnectionInfo() {
-		try {
-			return new InstanceConnectionInfo(InetAddress.getLocalHost(), 1234, 2345);
-		} catch (final UnknownHostException e) {
-			Assert.fail(String.format("create connection info: %s", StringUtils.stringifyException(e)));
-			return null;
-		}
-	}
-
-}
\ No newline at end of file
diff --git a/pact/pact-clients/src/main/java/eu/stratosphere/pact/testing/MockInstanceManager.java b/pact/pact-clients/src/main/java/eu/stratosphere/pact/testing/MockInstanceManager.java
deleted file mode 100644
index 4c46ca7..0000000
--- a/pact/pact-clients/src/main/java/eu/stratosphere/pact/testing/MockInstanceManager.java
+++ /dev/null
@@ -1,178 +0,0 @@
-/***********************************************************************************************************************
- *
- * Copyright (C) 2010 by the Stratosphere project (http://stratosphere.eu)
- *
- * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with
- * the License. You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on
- * an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
- * specific language governing permissions and limitations under the License.
- *
- **********************************************************************************************************************/
-
-package eu.stratosphere.pact.testing;
-
-import java.util.Arrays;
-import java.util.HashMap;
-import java.util.Iterator;
-import java.util.List;
-import java.util.Map;
-
-import eu.stratosphere.nephele.configuration.Configuration;
-import eu.stratosphere.nephele.executiongraph.ExecutionVertex;
-import eu.stratosphere.nephele.instance.AbstractInstance;
-import eu.stratosphere.nephele.instance.AllocatedResource;
-import eu.stratosphere.nephele.instance.AllocationID;
-import eu.stratosphere.nephele.instance.DummyInstance;
-import eu.stratosphere.nephele.instance.HardwareDescription;
-import eu.stratosphere.nephele.instance.InstanceConnectionInfo;
-import eu.stratosphere.nephele.instance.InstanceException;
-import eu.stratosphere.nephele.instance.InstanceListener;
-import eu.stratosphere.nephele.instance.InstanceManager;
-import eu.stratosphere.nephele.instance.InstanceRequestMap;
-import eu.stratosphere.nephele.instance.InstanceType;
-import eu.stratosphere.nephele.instance.InstanceTypeDescription;
-import eu.stratosphere.nephele.instance.InstanceTypeDescriptionFactory;
-import eu.stratosphere.nephele.instance.local.LocalInstanceManager;
-import eu.stratosphere.nephele.jobgraph.JobID;
-import eu.stratosphere.nephele.topology.NetworkTopology;
-
-/**
- * Minimalist, mocked {@link InstanceManager} having only localhost as its
- * resource.
- * 
- * @author Arvid Heise
- */
-class MockInstanceManager implements InstanceManager {
-
-	public static InstanceType DEFAULT_INSTANCE_TYPE = LocalInstanceManager.createDefaultInstanceType();
-
-	@SuppressWarnings("serial")
-	private static final HashMap<InstanceType, InstanceTypeDescription> TYPE_DESCRIPTIONS =
-		new HashMap<InstanceType, InstanceTypeDescription>() {
-			{
-				this.put(DEFAULT_INSTANCE_TYPE,
-					InstanceTypeDescriptionFactory.construct(DEFAULT_INSTANCE_TYPE, MockInstance.DESCRIPTION, 1));
-			}
-		};
-
-	private static final NetworkTopology NETWORK_TOPOLOGY = NetworkTopology
-		.createEmptyTopology();
-
-	public final static MockInstanceManager INSTANCE = new MockInstanceManager();
-
-	//
-	// public static MockInstanceManager getInstance() {
-	// return INSTANCE;
-	// }
-
-	private final AllocatedResource allocatedResource = new AllocatedResource(
-		new MockInstance(DEFAULT_INSTANCE_TYPE, NETWORK_TOPOLOGY), DEFAULT_INSTANCE_TYPE, new AllocationID());
-
-	private InstanceListener instanceListener;
-
-	@Override
-	public InstanceType getDefaultInstanceType() {
-		return DEFAULT_INSTANCE_TYPE;
-	}
-
-	@Override
-	public InstanceType getInstanceTypeByName(final String instanceTypeName) {
-		return DEFAULT_INSTANCE_TYPE;
-	}
-
-	@Override
-	public NetworkTopology getNetworkTopology(final JobID jobID) {
-		return NETWORK_TOPOLOGY;
-	}
-
-	@Override
-	public InstanceType getSuitableInstanceType(final int minNumComputeUnits,
-			final int minNumCPUCores, final int minMemorySize,
-			final int minDiskCapacity, final int maxPricePerHour) {
-		return DEFAULT_INSTANCE_TYPE;
-	}
-
-	@Override
-	public void releaseAllocatedResource(final JobID jobID,
-			final Configuration conf, final AllocatedResource allocatedResource)
-			throws InstanceException {
-
-		final DummyInstance dummyInstance =
-			DummyInstance.createDummyInstance(allocatedResource.getInstance().getType());
-		final AllocatedResource dummyResource = new AllocatedResource(dummyInstance,
-			allocatedResource.getInstanceType(), new AllocationID());
-		final Iterator<ExecutionVertex> assignedVertices = allocatedResource.assignedVertices();
-		while (assignedVertices.hasNext()) {
-			ExecutionVertex executionVertex = assignedVertices.next();
-			executionVertex.setAllocatedResource(dummyResource);
-		}
-	}
-
-	@Override
-	public void reportHeartBeat(InstanceConnectionInfo instanceConnectionInfo,
-			HardwareDescription hardwareDescription) {
-	}
-
-	@Override
-	public void setInstanceListener(final InstanceListener instanceListener) {
-		this.instanceListener = instanceListener;
-	}
-
-	@Override
-	public void shutdown() {
-	}
-
-	@Override
-	public Map<InstanceType, InstanceTypeDescription> getMapOfAvailableInstanceTypes() {
-		return TYPE_DESCRIPTIONS;
-	}
-
-	/*
-	 * (non-Javadoc)
-	 * @see eu.stratosphere.nephele.instance.InstanceManager#requestInstance(eu.stratosphere.nephele.jobgraph.JobID,
-	 * eu.stratosphere.nephele.configuration.Configuration, eu.stratosphere.nephele.instance.InstanceRequestMap,
-	 * java.util.List)
-	 */
-	@Override
-	public void requestInstance(final JobID jobID, Configuration conf, InstanceRequestMap instanceRequestMap,
-			List<String> splitAffinityList) throws InstanceException {
-
-		final InstanceListener il = this.instanceListener;
-
-		final Runnable runnable = new Runnable() {
-
-			/**
-			 * {@inheritDoc}
-			 */
-			@Override
-			public void run() {
-				il.resourcesAllocated(jobID, Arrays.asList(MockInstanceManager.this.allocatedResource));
-			}
-		};
-
-		ConcurrentUtil.invokeLater(runnable);
-	}
-
-	/*
-	 * (non-Javadoc)
-	 * @see eu.stratosphere.nephele.instance.InstanceManager#getInstanceByName(java.lang.String)
-	 */
-	@Override
-	public AbstractInstance getInstanceByName(String name) {
-		return this.allocatedResource.getInstance();
-	}
-
-	/*
-	 * (non-Javadoc)
-	 * @see
-	 * eu.stratosphere.nephele.instance.InstanceManager#cancelPendingRequests(eu.stratosphere.nephele.jobgraph.JobID)
-	 */
-	@Override
-	public void cancelPendingRequests(JobID jobID) {
-	}
-
-}
\ No newline at end of file
diff --git a/pact/pact-clients/src/main/java/eu/stratosphere/pact/testing/MockJobManager.java b/pact/pact-clients/src/main/java/eu/stratosphere/pact/testing/MockJobManager.java
deleted file mode 100644
index 76eddb1..0000000
--- a/pact/pact-clients/src/main/java/eu/stratosphere/pact/testing/MockJobManager.java
+++ /dev/null
@@ -1,76 +0,0 @@
-/***********************************************************************************************************************
- *
- * Copyright (C) 2010 by the Stratosphere project (http://stratosphere.eu)
- *
- * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with
- * the License. You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on
- * an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
- * specific language governing permissions and limitations under the License.
- *
- **********************************************************************************************************************/
-package eu.stratosphere.pact.testing;
-
-import java.util.Iterator;
-
-import eu.stratosphere.nephele.executiongraph.ExecutionGraph;
-import eu.stratosphere.nephele.executiongraph.ExecutionGraphIterator;
-import eu.stratosphere.nephele.executiongraph.ExecutionVertex;
-import eu.stratosphere.nephele.executiongraph.InternalJobStatus;
-import eu.stratosphere.nephele.executiongraph.JobStatusListener;
-import eu.stratosphere.nephele.taskmanager.AbstractTaskResult;
-import eu.stratosphere.nephele.taskmanager.TaskCancelResult;
-
-/**
- * @author Arvid Heise
- */
-public class MockJobManager implements JobStatusListener {
-	public static final MockJobManager INSTANCE = new MockJobManager();
-
-	@Override
-	public void jobStatusHasChanged(ExecutionGraph executionGraph, InternalJobStatus newJobStatus,
-			String optionalMessage) {
-//		System.out.println("job graph " + executionGraph.getJobID() + " -> " + newJobStatus  + "; " + StringUtils.stringifyException(new Throwable()));
-
-		if (newJobStatus == InternalJobStatus.CANCELING || newJobStatus == InternalJobStatus.FAILING)
-			// Cancel all remaining tasks
-			this.cancelJob(executionGraph);
-
-		if (newJobStatus == InternalJobStatus.FINISHED || newJobStatus == InternalJobStatus.CANCELED
-			|| newJobStatus == InternalJobStatus.FAILED)
-			MockTaskManager.INSTANCE.cleanupJob(executionGraph);
-	};
-
-	/**
-	 * Cancels all the tasks in the current and upper stages of the
-	 * given execution graph.
-	 * 
-	 * @param eg
-	 *        the execution graph representing the job to cancel.
-	 * @return <code>null</code> no error occurred during the cancel attempt,
-	 *         otherwise the returned object will describe the error
-	 */
-	private TaskCancelResult cancelJob(final ExecutionGraph eg) {
-
-		TaskCancelResult errorResult = null;
-
-		/**
-		 * Cancel all nodes in the current and upper execution stages.
-		 */
-		final Iterator<ExecutionVertex> it = new ExecutionGraphIterator(eg, eg.getIndexOfCurrentExecutionStage(),
-			false, true);
-		while (it.hasNext()) {
-
-			final ExecutionVertex vertex = it.next();
-			final TaskCancelResult result = vertex.cancelTask();
-			if (result.getReturnCode() != AbstractTaskResult.ReturnCode.SUCCESS)
-				errorResult = result;
-		}
-
-		return errorResult;
-	}
-
-}
diff --git a/pact/pact-clients/src/main/java/eu/stratosphere/pact/testing/MockOutputChannelBroker.java b/pact/pact-clients/src/main/java/eu/stratosphere/pact/testing/MockOutputChannelBroker.java
deleted file mode 100644
index 325dd3d..0000000
--- a/pact/pact-clients/src/main/java/eu/stratosphere/pact/testing/MockOutputChannelBroker.java
+++ /dev/null
@@ -1,180 +0,0 @@
-/***********************************************************************************************************************
- *
- * Copyright (C) 2010 by the Stratosphere project (http://stratosphere.eu)
- *
- * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with
- * the License. You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on
- * an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
- * specific language governing permissions and limitations under the License.
- *
- **********************************************************************************************************************/
-package eu.stratosphere.pact.testing;
-
-import java.io.IOException;
-import java.util.Iterator;
-import java.util.LinkedList;
-import java.util.Queue;
-
-import eu.stratosphere.nephele.event.task.AbstractEvent;
-import eu.stratosphere.nephele.event.task.AbstractTaskEvent;
-import eu.stratosphere.nephele.io.channels.Buffer;
-import eu.stratosphere.nephele.io.channels.bytebuffered.AbstractByteBufferedOutputChannel;
-import eu.stratosphere.nephele.io.channels.bytebuffered.ByteBufferedOutputChannelBroker;
-import eu.stratosphere.nephele.io.compression.CompressionException;
-import eu.stratosphere.nephele.io.compression.Compressor;
-import eu.stratosphere.nephele.taskmanager.bufferprovider.LocalBufferPool;
-import eu.stratosphere.nephele.taskmanager.transferenvelope.TransferEnvelope;
-import eu.stratosphere.nephele.taskmanager.transferenvelope.TransferEnvelopeDispatcher;
-
-/**
- * @author Arvid Heise
- */
-public class MockOutputChannelBroker implements ByteBufferedOutputChannelBroker, MockChannelBroker {
-
-	private int sequenceNumber;
-
-	/**
-	 * The byte buffered output channel this context belongs to.
-	 */
-	private final AbstractByteBufferedOutputChannel<?> byteBufferedOutputChannel;
-
-	private LocalBufferPool transitBufferPool;
-
-	private Queue<TransferEnvelope> queuedOutgoingEnvelopes = new LinkedList<TransferEnvelope>();
-
-	private TransferEnvelopeDispatcher transferEnvelopeDispatcher;
-
-	private TransferEnvelope outgoingTransferEnvelope;
-
-	public MockOutputChannelBroker(AbstractByteBufferedOutputChannel<?> byteBufferedOutputChannel,
-			LocalBufferPool transitBufferPool, TransferEnvelopeDispatcher transferEnvelopeDispatcher) {
-		this.byteBufferedOutputChannel = byteBufferedOutputChannel;
-		this.transitBufferPool = transitBufferPool;
-		this.transferEnvelopeDispatcher = transferEnvelopeDispatcher;
-	}
-
-	/*
-	 * (non-Javadoc)
-	 * @see eu.stratosphere.nephele.io.channels.bytebuffered.ByteBufferedOutputChannelBroker#requestEmptyWriteBuffers()
-	 */
-	@Override
-	public Buffer requestEmptyWriteBuffer() throws InterruptedException, IOException {
-
-		this.outgoingTransferEnvelope = this.newEnvelope();
-		final int uncompressedBufferSize = this.transitBufferPool.getMaximumBufferSize();
-
-		return this.transitBufferPool.requestEmptyBuffer(uncompressedBufferSize);
-	}
-
-	protected TransferEnvelope newEnvelope() {
-		TransferEnvelope transferEnvelope = new TransferEnvelope(this.sequenceNumber++,
-			this.byteBufferedOutputChannel.getJobID(),
-			this.byteBufferedOutputChannel.getID());
-
-		return transferEnvelope;
-	}
-
-	/*
-	 * (non-Javadoc)
-	 * @see eu.stratosphere.nephele.io.channels.bytebuffered.ByteBufferedOutputChannelBroker#releaseWriteBuffers()
-	 */
-	@Override
-	public void releaseWriteBuffer(final Buffer buffer) throws IOException, InterruptedException {
-
-		// Finish the write phase of the buffer
-		buffer.finishWritePhase();
-
-		this.outgoingTransferEnvelope.setBuffer(buffer);
-
-		if (this.queuedOutgoingEnvelopes.isEmpty())
-			this.transferEnvelopeDispatcher.processEnvelopeFromOutputChannel(this.outgoingTransferEnvelope);
-		else {
-			this.queuedOutgoingEnvelopes.add(this.outgoingTransferEnvelope);
-			this.flushQueuedOutgoingEnvelopes();
-		}
-
-		this.outgoingTransferEnvelope = null;
-	}
-
-	/*
-	 * (non-Javadoc)
-	 * @see eu.stratosphere.nephele.io.channels.bytebuffered.ByteBufferedOutputChannelBroker#hasDataLeftToTransmit()
-	 */
-	@Override
-	public boolean hasDataLeftToTransmit() throws IOException, InterruptedException {
-		this.flushQueuedOutgoingEnvelopes();
-
-		return !this.queuedOutgoingEnvelopes.isEmpty();
-	}
-
-	protected void flushQueuedOutgoingEnvelopes() throws IOException, InterruptedException {
-		while (!this.queuedOutgoingEnvelopes.isEmpty())
-			this.transferEnvelopeDispatcher.processEnvelopeFromOutputChannel(this.queuedOutgoingEnvelopes.poll());
-	}
-
-	/*
-	 * (non-Javadoc)
-	 * @see eu.stratosphere.pact.testing.MockChannelBroker#queueTransferEnvelope(eu.stratosphere.nephele.taskmanager.
-	 * transferenvelope.TransferEnvelope)
-	 */
-	@Override
-	public void queueTransferEnvelope(TransferEnvelope transferEnvelope) {
-		final Iterator<AbstractEvent> it = transferEnvelope.getEventList().iterator();
-		while (it.hasNext()) {
-
-			final AbstractEvent event = it.next();
-
-			if (event instanceof AbstractTaskEvent) {
-				this.byteBufferedOutputChannel.processEvent(event);
-			}
-		}
-	}
-
-	/*
-	 * (non-Javadoc)
-	 * @see
-	 * eu.stratosphere.nephele.io.channels.bytebuffered.ByteBufferedOutputChannelBroker#transferEventToInputChannel(
-	 * eu.stratosphere.nephele.event.task.AbstractEvent)
-	 */
-	@Override
-	public void transferEventToInputChannel(AbstractEvent event) throws IOException, InterruptedException {
-
-		if (this.outgoingTransferEnvelope != null)
-			this.outgoingTransferEnvelope.addEvent(event);
-		else {
-
-			final TransferEnvelope ephemeralTransferEnvelope = this.newEnvelope();
-			ephemeralTransferEnvelope.addEvent(event);
-
-			if (this.queuedOutgoingEnvelopes.isEmpty())
-				this.transferEnvelopeDispatcher.processEnvelopeFromOutputChannel(ephemeralTransferEnvelope);
-			else {
-				this.queuedOutgoingEnvelopes.add(ephemeralTransferEnvelope);
-				this.flushQueuedOutgoingEnvelopes();
-			}
-		}
-	}
-
-	/*
-	 * (non-Javadoc)
-	 * @see eu.stratosphere.pact.testing.MockChannelBroker#getChannel()
-	 */
-	@Override
-	public AbstractByteBufferedOutputChannel<?> getChannel() {
-		return this.byteBufferedOutputChannel;
-	}
-
-	/*
-	 * (non-Javadoc)
-	 * @see eu.stratosphere.nephele.io.channels.bytebuffered.ByteBufferedOutputChannelBroker#getCompressor()
-	 */
-	@Override
-	public Compressor getCompressor() throws CompressionException {
-
-		return null;
-	}
-}
diff --git a/pact/pact-clients/src/main/java/eu/stratosphere/pact/testing/MockTaskManager.java b/pact/pact-clients/src/main/java/eu/stratosphere/pact/testing/MockTaskManager.java
deleted file mode 100644
index 76efdcc..0000000
--- a/pact/pact-clients/src/main/java/eu/stratosphere/pact/testing/MockTaskManager.java
+++ /dev/null
@@ -1,389 +0,0 @@
-/***********************************************************************************************************************
- *
- * Copyright (C) 2010 by the Stratosphere project (http://stratosphere.eu)
- *
- * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with
- * the License. You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on
- * an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
- * specific language governing permissions and limitations under the License.
- *
- **********************************************************************************************************************/
-
-package eu.stratosphere.pact.testing;
-
-import java.io.IOException;
-import java.util.HashMap;
-import java.util.IdentityHashMap;
-import java.util.LinkedHashMap;
-import java.util.List;
-import java.util.Map;
-import java.util.Map.Entry;
-import java.util.Set;
-
-import org.apache.commons.logging.Log;
-import org.apache.commons.logging.LogFactory;
-
-import eu.stratosphere.nephele.configuration.ConfigConstants;
-import eu.stratosphere.nephele.configuration.GlobalConfiguration;
-import eu.stratosphere.nephele.deployment.TaskDeploymentDescriptor;
-import eu.stratosphere.nephele.execution.Environment;
-import eu.stratosphere.nephele.execution.ExecutionObserver;
-import eu.stratosphere.nephele.execution.ExecutionState;
-import eu.stratosphere.nephele.execution.RuntimeEnvironment;
-import eu.stratosphere.nephele.execution.librarycache.LibraryCacheProfileRequest;
-import eu.stratosphere.nephele.execution.librarycache.LibraryCacheProfileResponse;
-import eu.stratosphere.nephele.execution.librarycache.LibraryCacheUpdate;
-import eu.stratosphere.nephele.executiongraph.ExecutionGraph;
-import eu.stratosphere.nephele.executiongraph.ExecutionVertex;
-import eu.stratosphere.nephele.executiongraph.ExecutionVertexID;
-import eu.stratosphere.nephele.io.channels.ChannelID;
-import eu.stratosphere.nephele.jobgraph.JobID;
-import eu.stratosphere.nephele.jobmanager.splitassigner.InputSplitManager;
-import eu.stratosphere.nephele.protocols.TaskOperationProtocol;
-import eu.stratosphere.nephele.services.iomanager.IOManager;
-import eu.stratosphere.nephele.services.memorymanager.MemoryManager;
-import eu.stratosphere.nephele.services.memorymanager.spi.DefaultMemoryManager;
-import eu.stratosphere.nephele.taskmanager.AbstractTaskResult;
-import eu.stratosphere.nephele.taskmanager.TaskCancelResult;
-import eu.stratosphere.nephele.taskmanager.TaskCheckpointResult;
-import eu.stratosphere.nephele.taskmanager.TaskKillResult;
-import eu.stratosphere.nephele.taskmanager.TaskSubmissionResult;
-import eu.stratosphere.nephele.template.AbstractInvokable;
-import eu.stratosphere.nephele.util.SerializableArrayList;
-import eu.stratosphere.nephele.util.StringUtils;
-
-/**
- * Mocks the {@link TaskManager} without building up any network connections. It supports memory and file channels for
- * an execution graph.
- * 
- * @author Arvid Heise
- */
-class MockTaskManager implements TaskOperationProtocol {
-
-	private InputSplitManager inputSplitManager = new InputSplitManager();
-
-	private static final Log LOG = LogFactory.getLog(MockTaskManager.class);
-
-	// at least 128 mb
-	private static final long MEMORY_SIZE = Math.max(128 << 20, Runtime.getRuntime().maxMemory() / 2);
-
-	private Map<ExecutionVertexID, RuntimeEnvironment> finishedTasks = new HashMap<ExecutionVertexID, RuntimeEnvironment>();
-
-	public static final MockTaskManager INSTANCE = new MockTaskManager();
-
-	private MockChannelManager channelManager = new MockChannelManager();
-
-	private final IOManager ioManager;
-
-	private volatile MemoryManager memoryManager;
-
-	private Map<JobID, ExecutionGraph> jobGraphs = new HashMap<JobID, ExecutionGraph>();
-
-	private final Map<ExecutionVertexID, RuntimeEnvironment> runningTasks =
-		new HashMap<ExecutionVertexID, RuntimeEnvironment>();
-
-	private final Map<Environment, TaskObserver> observers = new IdentityHashMap<Environment, TaskObserver>();
-
-	private MockTaskManager() {
-		this.memoryManager = new DefaultMemoryManager(MEMORY_SIZE);
-		// this.memoryManager = new MockMemoryManager();
-		// Initialize the io manager
-		final String tmpDirPath = GlobalConfiguration.getString(ConfigConstants.TASK_MANAGER_TMP_DIR_KEY,
-			ConfigConstants.DEFAULT_TASK_MANAGER_TMP_PATH);
-		this.ioManager = new IOManager(tmpDirPath);
-	}
-
-	public void addJobGraph(ExecutionGraph executionGraph) {
-		this.inputSplitManager.registerJob(executionGraph);
-		this.jobGraphs.put(executionGraph.getJobID(), executionGraph);
-	}
-
-	@Override
-	public TaskCancelResult cancelTask(final ExecutionVertexID id) throws IOException {
-
-		RuntimeEnvironment environment = this.runningTasks.get(id);
-		final Thread executingThread = environment.getExecutingThread();
-
-		this.finishedTasks.put(id, environment);
-		this.observers.get(environment).cancel();
-		// Request user code to shut down
-		try {
-			final AbstractInvokable invokable = environment.getInvokable();
-			if (invokable != null)
-				invokable.cancel();
-			executingThread.interrupt();
-		} catch (Throwable e) {
-			LOG.error(StringUtils.stringifyException(e));
-		}
-
-		return new TaskCancelResult(id, TaskCancelResult.ReturnCode.SUCCESS);
-	}
-
-	/**
-	 * @param executionGraph
-	 */
-	public void cleanupJob(ExecutionGraph executionGraph) {
-		for (Entry<ExecutionVertexID, RuntimeEnvironment> task : this.finishedTasks.entrySet()) {
-			this.channelManager.unregisterChannels(task.getValue());
-			this.observers.remove(task.getValue());
-			this.runningTasks.remove(task.getKey());
-		}
-		this.finishedTasks.clear();
-		this.inputSplitManager.unregisterJob(executionGraph);
-		this.jobGraphs.remove(executionGraph.getJobID());
-//		System.out.println("cleaning " + executionGraph.getJobID());
-//		System.out.println("remaining runningtasks " + this.runningTasks.size());
-	}
-
-	/**
-	 * Returns the {@link IOManager}.
-	 * 
-	 * @return the IOManager
-	 */
-	public IOManager getIoManager() {
-		return this.ioManager;
-	}
-
-	@Override
-	public LibraryCacheProfileResponse getLibraryCacheProfile(final LibraryCacheProfileRequest request)
-			throws IOException {
-		final LibraryCacheProfileResponse response = new LibraryCacheProfileResponse(request);
-		final String[] requiredLibraries = request.getRequiredLibraries();
-
-		for (int i = 0; i < requiredLibraries.length; i++)
-			response.setCached(i, true);
-
-		return response;
-	}
-
-	/**
-	 * Returns the {@link MemoryManager}.
-	 * 
-	 * @return the MemoryManager
-	 */
-	public MemoryManager getMemoryManager() {
-		return this.memoryManager;
-	}
-
-	/*
-	 * (non-Javadoc)
-	 * @see eu.stratosphere.nephele.protocols.TaskOperationProtocol#invalidateLookupCacheEntries(java.util.Set)
-	 */
-	@Override
-	public void invalidateLookupCacheEntries(Set<ChannelID> channelIDs) throws IOException {
-	}
-
-	/*
-	 * (non-Javadoc)
-	 * @see eu.stratosphere.nephele.protocols.TaskOperationProtocol#killTask(eu.stratosphere.nephele.executiongraph.
-	 * ExecutionVertexID)
-	 */
-	@Override
-	public TaskKillResult killTask(ExecutionVertexID id) throws IOException {
-		return null;
-	}
-
-	/*
-	 * (non-Javadoc)
-	 * @see eu.stratosphere.nephele.protocols.TaskOperationProtocol#killTaskManager()
-	 */
-	@Override
-	public void killTaskManager() throws IOException {
-	}
-
-	//
-	// /*
-	// * (non-Javadoc)
-	// * @see eu.stratosphere.nephele.protocols.TaskOperationProtocol#submitTask(eu.stratosphere.nephele.executiongraph.
-	// * ExecutionVertexID, eu.stratosphere.nephele.configuration.Configuration,
-	// * eu.stratosphere.nephele.execution.Environment, java.util.Set)
-	// */
-	// @Override
-	// public TaskSubmissionResult submitTask(final ExecutionVertexID id, Configuration jobConfiguration,
-	// final RuntimeEnvironment environment, Set<ChannelID> activeOutputChannels) throws IOException {
-	// // Register task manager components in environment
-	// environment.setMemoryManager(this.memoryManager);
-	// environment.setIOManager(this.ioManager);
-	// TaskObserver observer = new TaskObserver(id, environment);
-	// environment.setExecutionObserver(observer);
-	//
-	// this.channelManager.registerChannels(environment);
-	// this.runningTasks.put(id, environment);
-	// this.observers.put(environment, observer);
-	//
-	// final Thread thread = environment.getExecutingThread();
-	// thread.start();
-	//
-	// return new TaskSubmissionResult(id, AbstractTaskResult.ReturnCode.SUCCESS);
-	// }
-
-	@Override
-	public void logBufferUtilization() throws IOException {
-	}
-
-	@Override
-	public void removeCheckpoints(List<ExecutionVertexID> listOfVertexIDs) throws IOException {
-	}
-
-	/*
-	 * (non-Javadoc)
-	 * @see eu.stratosphere.nephele.protocols.TaskOperationProtocol#requestCheckpointDecision(eu.stratosphere.nephele.
-	 * executiongraph.ExecutionVertexID)
-	 */
-	@Override
-	public TaskCheckpointResult requestCheckpointDecision(ExecutionVertexID id) throws IOException {
-		return null;
-	}
-
-	/*
-	 * (non-Javadoc)
-	 * @see eu.stratosphere.nephele.protocols.TaskOperationProtocol#submitTasks(java.util.List)
-	 */
-	@Override
-	public List<TaskSubmissionResult> submitTasks(List<TaskDeploymentDescriptor> tasks) throws IOException {
-		final List<TaskSubmissionResult> submissionResultList = new SerializableArrayList<TaskSubmissionResult>();
-		final Map<ExecutionVertexID, RuntimeEnvironment> tasksToStart =
-			new LinkedHashMap<ExecutionVertexID, RuntimeEnvironment>();
-
-		// Make sure all tasks are fully registered before they are started
-		for (final TaskDeploymentDescriptor tdd : tasks) {
-			final ExecutionVertexID vertexID = tdd.getVertexID();
-			RuntimeEnvironment environment;
-			try {
-				final ExecutionGraph executionGraph = this.jobGraphs.get(tdd.getJobID());
-				final ExecutionVertex vertex = executionGraph.getVertexByID(vertexID);
-				environment =
-					new RuntimeEnvironment(tdd, this.memoryManager, this.ioManager, new MockInputSplitProvider(
-						this.inputSplitManager, vertex));
-			} catch (Throwable t) {
-				final TaskSubmissionResult result = new TaskSubmissionResult(vertexID,
-					AbstractTaskResult.ReturnCode.DEPLOYMENT_ERROR);
-				result.setDescription(StringUtils.stringifyException(t));
-				LOG.error(result.getDescription());
-				submissionResultList.add(result);
-				continue;
-			}
-
-			TaskObserver observer = new TaskObserver(vertexID, environment);
-			environment.setExecutionObserver(observer);
-
-			this.channelManager.registerChannels(environment);
-			this.runningTasks.put(vertexID, environment);
-			this.observers.put(environment, observer);
-			tasksToStart.put(vertexID, environment);
-		}
-
-		for (final Entry<ExecutionVertexID, RuntimeEnvironment> task : tasksToStart.entrySet()) {
-			final Thread thread = task.getValue().getExecutingThread();
-			thread.start();
-			submissionResultList.add(new TaskSubmissionResult(task.getKey(), AbstractTaskResult.ReturnCode.SUCCESS));
-		}
-
-		return submissionResultList;
-	}
-
-	@Override
-	public void updateLibraryCache(final LibraryCacheUpdate update) throws IOException {
-	}
-
-	/**
-	 * @author Arvid Heise
-	 */
-	private final class TaskObserver implements ExecutionObserver {
-		/**
-		 * 
-		 */
-		private final ExecutionVertexID id;
-
-		/**
-		 * 
-		 */
-		private final RuntimeEnvironment environment;
-
-		private volatile boolean isCanceled = false;
-
-		/**
-		 * Initializes ExecutionObserver.
-		 * 
-		 * @param id
-		 * @param environment
-		 */
-		private TaskObserver(ExecutionVertexID id, RuntimeEnvironment environment) {
-			this.id = id;
-			this.environment = environment;
-		}
-
-		/**
-		 * 
-		 */
-		public void cancel() {
-			this.isCanceled = true;
-			ConcurrentUtil.invokeLater(new Runnable() {
-				@Override
-				public void run() {
-					TaskObserver.this.executionStateChanged(ExecutionState.CANCELING, null);
-				}
-			});
-		}
-
-		@Override
-		public void executionStateChanged(final ExecutionState executionState, final String optionalMessage) {
-//			 System.out.println("vertex " + this.id + " -> " + executionState);
-			// Don't propagate state CANCELING back to the job manager
-			if (executionState == ExecutionState.CANCELING) {
-				return;
-			}
-
-			final ExecutionGraph eg = MockTaskManager.INSTANCE.jobGraphs.get(this.environment.getJobID());
-			if (eg == null) {
-				LOG.error("Cannot find execution graph for ID " + this.environment.getJobID() + " to change state to "
-					+ executionState);
-				return;
-			}
-
-			final ExecutionVertex vertex = eg.getVertexByID(this.id);
-			if (vertex == null) {
-				LOG.error("Cannot find vertex with ID " + this.id + " of job " + eg.getJobID() + " to change state to "
-					+ executionState);
-				return;
-			}
-
-//			final Runnable taskStateChangeRunnable = new Runnable() {
-//				@Override
-//				public void run() {
-//					// The registered listeners of the vertex will make sure the appropriate actions are taken
-//					vertex.updateExecutionState(executionState, optionalMessage);
-//				}
-//			};
-//			ConcurrentUtil.invokeLater(taskStateChangeRunnable);
-
-//			System.out.println("vertex2 " + this.id + " -> " + executionState);
-			synchronized (eg) {
-				vertex.updateExecutionState(executionState, optionalMessage);				
-			}
-//			System.out.println("vertex3 " + this.id + " -> " + executionState);
-//			eg.executionStateChanged(this.environment.getJobID(), this.id, executionState, optionalMessage);
-
-			if (executionState == ExecutionState.CANCELED || executionState == ExecutionState.FINISHED
-				|| executionState == ExecutionState.FAILED)
-				MockTaskManager.this.finishedTasks.put(this.id, this.environment);
-		}
-
-		@Override
-		public boolean isCanceled() {
-			return this.isCanceled;
-		}
-
-		@Override
-		public void userThreadFinished(Thread userThread) {
-		}
-
-		@Override
-		public void userThreadStarted(Thread userThread) {
-		}
-	}
-}
diff --git a/pact/pact-clients/src/main/java/eu/stratosphere/pact/testing/NaiveFuzzyValueMatcher.java b/pact/pact-clients/src/main/java/eu/stratosphere/pact/testing/NaiveFuzzyValueMatcher.java
deleted file mode 100644
index 97b8b92..0000000
--- a/pact/pact-clients/src/main/java/eu/stratosphere/pact/testing/NaiveFuzzyValueMatcher.java
+++ /dev/null
@@ -1,56 +0,0 @@
-/***********************************************************************************************************************
- *
- * Copyright (C) 2010 by the Stratosphere project (http://stratosphere.eu)
- *
- * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with
- * the License. You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on
- * an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
- * specific language governing permissions and limitations under the License.
- *
- **********************************************************************************************************************/
-
-package eu.stratosphere.pact.testing;
-
-import it.unimi.dsi.fastutil.ints.Int2ObjectMap;
-
-import java.util.ArrayList;
-import java.util.Collection;
-import java.util.Iterator;
-import java.util.List;
-
-import eu.stratosphere.pact.common.type.PactRecord;
-import eu.stratosphere.pact.common.type.Value;
-
-/**
- * Simple matching algorithm that returns unmatched values but allows a value from one bag to be matched several times
- * against items from another bag.
- * 
- * @author Arvid.Heise
- * @param <PactRecord>
- */
-public class NaiveFuzzyValueMatcher extends AbstractValueMatcher {
-	@Override
-	public void removeMatchingValues(Int2ObjectMap<List<ValueSimilarity<?>>> similarities,
-			Class<? extends Value>[] schema, Collection<PactRecord> expectedValues, Collection<PactRecord> actualValues) {
-		Iterator<PactRecord> expectedIterator = expectedValues.iterator();
-		List<PactRecord> matchedActualValues = new ArrayList<PactRecord>();
-		while (expectedIterator.hasNext()) {
-			PactRecord expected = expectedIterator.next();
-			boolean matched = false;
-			for (PactRecord actual : actualValues)
-				if (this.getDistance(schema, similarities, expected, actual) >= 0) {
-					matched = true;
-					matchedActualValues.add(actual);
-				}
-			if (matched)
-				expectedIterator.remove();
-		}
-
-		actualValues.removeAll(matchedActualValues);
-	}
-
-}
diff --git a/pact/pact-clients/src/main/java/eu/stratosphere/pact/testing/PactRecordEqualer.java b/pact/pact-clients/src/main/java/eu/stratosphere/pact/testing/PactRecordEqualer.java
deleted file mode 100644
index 3d82031..0000000
--- a/pact/pact-clients/src/main/java/eu/stratosphere/pact/testing/PactRecordEqualer.java
+++ /dev/null
@@ -1,56 +0,0 @@
-/***********************************************************************************************************************
- *
- * Copyright (C) 2010 by the Stratosphere project (http://stratosphere.eu)
- *
- * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with
- * the License. You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on
- * an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
- * specific language governing permissions and limitations under the License.
- *
- **********************************************************************************************************************/
-package eu.stratosphere.pact.testing;
-
-import eu.stratosphere.pact.common.type.PactRecord;
-import eu.stratosphere.pact.common.type.Value;
-
-/**
- * @author arv
- */
-public class PactRecordEqualer implements Equaler<PactRecord> {
-	private Class<? extends Value>[] schema;
-
-	/**
-	 * Initializes PactRecordEqualer.
-	 */
-	public PactRecordEqualer(Class<? extends Value>[] schema) {
-		this.schema = schema;
-	}
-
-	public PactRecordEqualer(Class<? extends Value> firstFieldType, Class<?>... otherFieldTypes) {
-		this.schema = SchemaUtils.combineSchema(firstFieldType, otherFieldTypes);
-	}
-
-	/*
-	 * (non-Javadoc)
-	 * @see eu.stratosphere.pact.testing.Equaler#equal(java.lang.Object, java.lang.Object)
-	 */
-	@Override
-	public boolean equal(PactRecord object1, PactRecord object2) {
-		return recordsEqual(object1, object2, this.schema);
-	}
-
-	public static boolean recordsEqual(PactRecord object1, PactRecord object2, Class<? extends Value>[] schema) {
-		if (object1.getNumFields() != schema.length)
-			return false;
-
-		for (int index = 0; index < schema.length; index++)
-			if (!Equaler.SafeEquals.equal(object1.getField(index, schema[index]),
-				object2.getField(index, schema[index])))
-				return false;
-		return true;
-	}
-}
diff --git a/pact/pact-clients/src/main/java/eu/stratosphere/pact/testing/PactRecordUtil.java b/pact/pact-clients/src/main/java/eu/stratosphere/pact/testing/PactRecordUtil.java
deleted file mode 100644
index 64ddc09..0000000
--- a/pact/pact-clients/src/main/java/eu/stratosphere/pact/testing/PactRecordUtil.java
+++ /dev/null
@@ -1,88 +0,0 @@
-/***********************************************************************************************************************
- *
- * Copyright (C) 2010 by the Stratosphere project (http://stratosphere.eu)
- *
- * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with
- * the License. You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on
- * an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
- * specific language governing permissions and limitations under the License.
- *
- **********************************************************************************************************************/
-package eu.stratosphere.pact.testing;
-
-import java.util.Iterator;
-
-import eu.stratosphere.pact.common.type.PactRecord;
-import eu.stratosphere.pact.common.type.Value;
-
-/**
- * Convenience methods for working with {@link PactRecord}s.
- * 
- * @author Arvid Heise
- */
-public class PactRecordUtil {
-
-	/**
-	 * Generates a string for the {@link PactRecord}s using the given schema.<br>
-	 * This method stringifies at most 20 records.<br>
-	 * To exert more control over the amounts of records, use {@link #toString(Iterator, Class[], int)}.
-	 * 
-	 * @param record
-	 *        the record to stringify
-	 * @param schema
-	 *        the schema that is used to retrieve the values of the record
-	 * @return a string representation of the records
-	 */
-	public static String stringify(Iterator<? extends PactRecord> iterator, Class<? extends Value>[] schema) {
-		return stringify(iterator, schema, 20);
-	}
-
-	/**
-	 * Generates a string for the first <i>maxNum</i> {@link PactRecord}s using the given schema.
-	 * 
-	 * @param record
-	 *        the record to stringify
-	 * @param schema
-	 *        the schema that is used to retrieve the values of the record
-	 * @param maxNum
-	 *        the maximum number of records to stringify
-	 * @return a string representation of the records
-	 */
-	public static String stringify(Iterator<? extends PactRecord> iterator, Class<? extends Value>[] schema, int maxNum) {
-		StringBuilder builder = new StringBuilder();
-		for (int index = 0; index < maxNum && iterator.hasNext(); index++) {
-			builder.append(stringify(iterator.next(), schema));
-			if (iterator.hasNext())
-				builder.append(", ");
-		}
-		if (iterator.hasNext())
-			builder.append("...");
-		return builder.toString();
-	}
-
-	/**
-	 * Generates a string for the {@link PactRecord} using the given schema.
-	 * 
-	 * @param record
-	 *        the record to stringify
-	 * @param schema
-	 *        the schema that is used to retrieve the values of the record
-	 * @return a string representation of the record
-	 */
-	public static String stringify(PactRecord record, Class<? extends Value>[] schema) {
-		if (record == null)
-			return "null";
-		StringBuilder builder = new StringBuilder("(");
-		for (int index = 0; index < record.getNumFields(); index++) {
-			if (index > 0)
-				builder.append(", ");
-			builder.append(record.getField(index, schema[index]));
-		}
-		return builder.append(")").toString();
-	}
-
-}
diff --git a/pact/pact-clients/src/main/java/eu/stratosphere/pact/testing/SchemaUtils.java b/pact/pact-clients/src/main/java/eu/stratosphere/pact/testing/SchemaUtils.java
deleted file mode 100644
index 5db79b2..0000000
--- a/pact/pact-clients/src/main/java/eu/stratosphere/pact/testing/SchemaUtils.java
+++ /dev/null
@@ -1,37 +0,0 @@
-/***********************************************************************************************************************
- *
- * Copyright (C) 2010 by the Stratosphere project (http://stratosphere.eu)
- *
- * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with
- * the License. You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on
- * an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
- * specific language governing permissions and limitations under the License.
- *
- **********************************************************************************************************************/
-package eu.stratosphere.pact.testing;
-
-import eu.stratosphere.pact.common.type.Value;
-
-/**
- * @author Arvid Heise
- */
-public class SchemaUtils {
-
-	@SuppressWarnings("unchecked")
-	public static Class<? extends Value>[] combineSchema(Class<? extends Value> firstFieldType,
-			Class<?>... otherFieldTypes) {
-		Class<? extends Value>[] schema = new Class[1 + otherFieldTypes.length];
-		schema[0] = firstFieldType;
-		for (int index = 0; index < otherFieldTypes.length; index++) {
-			if (!Value.class.isAssignableFrom(otherFieldTypes[index]))
-				throw new IllegalArgumentException("All schema types must implement Value");
-			schema[index + 1] = (Class<? extends Value>) otherFieldTypes[index];
-		}
-
-		return schema;
-	}
-}
diff --git a/pact/pact-clients/src/main/java/eu/stratosphere/pact/testing/TestPlan.java b/pact/pact-clients/src/main/java/eu/stratosphere/pact/testing/TestPlan.java
deleted file mode 100644
index 320c6f6..0000000
--- a/pact/pact-clients/src/main/java/eu/stratosphere/pact/testing/TestPlan.java
+++ /dev/null
@@ -1,1145 +0,0 @@
-/***********************************************************************************************************************
- *
- * Copyright (C) 2010 by the Stratosphere project (http://stratosphere.eu)
- *
- * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with
- * the License. You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on
- * an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
- * specific language governing permissions and limitations under the License.
- *
- **********************************************************************************************************************/
-
-package eu.stratosphere.pact.testing;
-
-import it.unimi.dsi.fastutil.ints.Int2ObjectArrayMap;
-import it.unimi.dsi.fastutil.ints.Int2ObjectMap;
-import it.unimi.dsi.fastutil.ints.Int2ObjectMap.Entry;
-import it.unimi.dsi.fastutil.ints.Int2ObjectMaps;
-import it.unimi.dsi.fastutil.ints.Int2ObjectOpenHashMap;
-
-import java.io.Closeable;
-import java.io.File;
-import java.io.FileWriter;
-import java.io.IOException;
-import java.net.InetSocketAddress;
-import java.util.ArrayList;
-import java.util.Collection;
-import java.util.HashMap;
-import java.util.IdentityHashMap;
-import java.util.LinkedList;
-import java.util.List;
-import java.util.ListIterator;
-import java.util.Map;
-
-import junit.framework.Assert;
-import eu.stratosphere.nephele.client.JobClient;
-import eu.stratosphere.nephele.client.JobExecutionException;
-import eu.stratosphere.nephele.configuration.ConfigConstants;
-import eu.stratosphere.nephele.configuration.Configuration;
-import eu.stratosphere.nephele.configuration.GlobalConfiguration;
-import eu.stratosphere.nephele.execution.ExecutionListener;
-import eu.stratosphere.nephele.execution.ExecutionState;
-import eu.stratosphere.nephele.execution.librarycache.LibraryCacheManager;
-import eu.stratosphere.nephele.executiongraph.ExecutionGraph;
-import eu.stratosphere.nephele.executiongraph.ExecutionGraphIterator;
-import eu.stratosphere.nephele.executiongraph.ExecutionVertex;
-import eu.stratosphere.nephele.executiongraph.ExecutionVertexID;
-import eu.stratosphere.nephele.executiongraph.GraphConversionException;
-import eu.stratosphere.nephele.executiongraph.InternalJobStatus;
-import eu.stratosphere.nephele.fs.FileStatus;
-import eu.stratosphere.nephele.fs.FileSystem;
-import eu.stratosphere.nephele.fs.Path;
-import eu.stratosphere.nephele.instance.InstanceTypeDescription;
-import eu.stratosphere.nephele.instance.InstanceTypeDescriptionFactory;
-import eu.stratosphere.nephele.instance.local.LocalInstanceManager;
-import eu.stratosphere.nephele.jobgraph.AbstractJobVertex;
-import eu.stratosphere.nephele.jobgraph.JobGraph;
-import eu.stratosphere.nephele.jobgraph.JobID;
-import eu.stratosphere.nephele.jobmanager.JobManager;
-import eu.stratosphere.nephele.jobmanager.JobManager.ExecutionMode;
-import eu.stratosphere.nephele.jobmanager.scheduler.local.LocalScheduler;
-import eu.stratosphere.nephele.util.StringUtils;
-import eu.stratosphere.pact.common.contract.FileDataSink;
-import eu.stratosphere.pact.common.contract.FileDataSource;
-import eu.stratosphere.pact.common.contract.GenericDataSink;
-import eu.stratosphere.pact.common.contract.GenericDataSource;
-import eu.stratosphere.pact.common.io.FileInputFormat;
-import eu.stratosphere.pact.common.io.FileOutputFormat;
-import eu.stratosphere.pact.common.io.SequentialInputFormat;
-import eu.stratosphere.pact.common.io.SequentialOutputFormat;
-import eu.stratosphere.pact.common.plan.Plan;
-import eu.stratosphere.pact.common.plan.Visitor;
-import eu.stratosphere.pact.common.type.Value;
-import eu.stratosphere.pact.common.util.PactConfigConstants;
-import eu.stratosphere.pact.compiler.CompilerException;
-import eu.stratosphere.pact.compiler.PactCompiler;
-import eu.stratosphere.pact.compiler.costs.DefaultCostEstimator;
-import eu.stratosphere.pact.compiler.plan.OptimizerNode;
-import eu.stratosphere.pact.compiler.plan.PactConnection;
-import eu.stratosphere.pact.compiler.plan.candidate.OptimizedPlan;
-import eu.stratosphere.pact.compiler.plantranslate.NepheleJobGraphGenerator;
-import eu.stratosphere.pact.generic.contract.Contract;
-import eu.stratosphere.pact.runtime.shipping.ShipStrategyType;
-
-/**
- * The primary resource to test one or more implemented PACT stubs. It is
- * created in a unit tests and performs the following operations.
- * <ul>
- * <li>Adds {@link GenericDataSource<?>}s and {@link GenericDataSink}s if not explicitly specified,
- * <li>locally runs the PACT stubs,
- * <li>checks the results against the pairs as specified in {@link #getExpectedOutput()}, and
- * <li>provides comfortable access to the results with {@link #getActualOutput()}. <br>
- * </ul>
- * <br>
- * The typical usage is inside a unit test. And might look like one of the
- * following examples. <br>
- * <br>
- * <b>Test complete plan<br>
- * <code><pre>
- *    // build plan
- *    GenericDataSource<?>&lt;Key, Value&gt; source = ...;
- *    MapContract&lt;Key, Value, Key, Value&gt; map = new MapContract&lt;Key, Value, Key, Value&gt;(IdentityMap.class, "Map");
- *    map.setInput(source);    
- *    GenericDataSink&lt;Key, Value&gt; output = ...;
- *    output.setInput(map);
- *    // configure test
- *    TestPlan testPlan = new TestPlan(output);
- *    testPlan.getExpectedOutput(output).fromFile(...);
- *    testPlan.run();
- * </pre></code> <b>Test plan with ad-hoc source and sink<br>
- * <code><pre>
- *    // build plan
- *    MapContract&lt;Key, Value, Key, Value&gt; map = new MapContract&lt;Key, Value, Key, Value&gt;(IdentityMap.class, "Map");
- *    // configure test
- *    TestPlan testPlan = new TestPlan(map);
- *    testPlan.getInput().add(pair1).add(pair2).add(pair3);
- *    testPlan.getExpectedOutput(output).add(pair1).add(pair2).add(pair3);
- *    testPlan.run();
- * </pre></code> <b>Access ad-hoc source and sink of Testplan<br>
- * <code><pre>
- *    // build plan
- *    MapContract&lt;Key, Value, Key, Value&gt; map = new MapContract&lt;Key, Value, Key, Value&gt;(IdentityMap.class, "Map");
- *    // configure test
- *    TestPlan testPlan = new TestPlan(map);
- *    testPlan.getInput().add(randomInput1).add(randomInput2).add(randomInput3);
- *    testPlan.run();
- *    // custom assertions
- *    Assert.assertEquals(testPlan.getInput(), testPlan.getOutput());
- * </pre></code> <br>
- * 
- * @author Arvid Heise
- */
-
-public class TestPlan implements Closeable {
-
-	private static final InstanceTypeDescription MOCK_INSTANCE_DESCRIPTION =
-		InstanceTypeDescriptionFactory.construct(
-			MockInstanceManager.DEFAULT_INSTANCE_TYPE, MockInstance.DESCRIPTION, 1);
-
-	private static GenericDataSink ALL_SINKS = null;
-
-	private final Map<GenericDataSink, TestRecords> actualOutputs = new IdentityHashMap<GenericDataSink, TestRecords>();
-
-	private final Contract[] contracts;
-
-	private int degreeOfParallelism = 1;
-
-	private final Map<GenericDataSink, TestRecords> expectedOutputs =
-		new IdentityHashMap<GenericDataSink, TestRecords>();
-
-	private final Map<GenericDataSource<?>, TestRecords> inputs =
-		new IdentityHashMap<GenericDataSource<?>, TestRecords>();
-
-	private final List<FileDataSink> sinks = new ArrayList<FileDataSink>();
-
-	private final List<FileDataSource> sources = new ArrayList<FileDataSource>();
-
-	private final Map<GenericDataSink, Int2ObjectMap<List<ValueSimilarity<?>>>> fuzzySimilarity =
-		new HashMap<GenericDataSink, Int2ObjectMap<List<ValueSimilarity<?>>>>();
-
-	private final Map<GenericDataSink, FuzzyValueMatcher> fuzzyMatchers =
-		new HashMap<GenericDataSink, FuzzyValueMatcher>();
-
-	private LocalScheduler localScheduler;
-
-	List<ExecutionExceptionHandler> errorHandlers = new ArrayList<TestPlan.ExecutionExceptionHandler>();
-
-	/**
-	 * Initializes TestPlan with the given {@link Contract}s. Like the original {@link Plan}, the contracts may be
-	 * {@link GenericDataSink}s. However, it
-	 * is also possible to add arbitrary Contracts, to which FileDataSinkContracts
-	 * are automatically added.
-	 * 
-	 * @param contracts
-	 *        a list of Contracts with at least one element.
-	 */
-	public TestPlan(final Collection<? extends Contract> contracts) {
-		this(contracts.toArray(new Contract[contracts.size()]));
-	}
-
-	/**
-	 * Initializes TestPlan with the given {@link Contract}s. Like the original {@link Plan}, the contracts may be
-	 * {@link GenericDataSink}s. However, it
-	 * is also possible to add arbitrary Contracts, to which FileDataSinkContracts
-	 * are automatically added.
-	 * 
-	 * @param contracts
-	 *        a list of Contracts with at least one element.
-	 */
-	public TestPlan(final Contract... contracts) {
-		if (contracts.length == 0)
-			throw new IllegalArgumentException();
-
-		this.fuzzyMatchers.put(ALL_SINKS, new NaiveFuzzyValueMatcher());
-
-		final Configuration config = new Configuration();
-		config.setString(PactConfigConstants.DEFAULT_INSTANCE_TYPE_KEY, "standard,1,1,200,1,1");
-		GlobalConfiguration.includeConfiguration(config);
-
-		this.contracts = new InputOutputAdder().process(contracts);
-
-		this.findSinksAndSources();
-		this.configureSinksAndSources();
-	}
-
-	/**
-	 * Sets a fuzzy similarity measure for the values of the given data sink.
-	 * 
-	 * @param <V>
-	 *        the value type
-	 * @param sink
-	 *        the data sink
-	 * @param similarity
-	 *        the similarity measure to use
-	 */
-	public void addFuzzyValueSimilarity(GenericDataSink sink, int valueIndex, ValueSimilarity<?> similarity) {
-		this.getFuzzySimilarities(sink, valueIndex).add(similarity);
-	}
-
-	/**
-	 * Sets a fuzzy similarity measure for the values of the given data sink.
-	 * 
-	 * @param <V>
-	 *        the value type
-	 * @param sink
-	 *        the data sink
-	 * @param similarity
-	 *        the similarity measure to use
-	 */
-	public void addFuzzyValueSimilarity(GenericDataSink sink, ValueSimilarity<?> similarity) {
-		this.addFuzzyValueSimilarity(sink, TestRecords.ALL_VALUES, similarity);
-	}
-
-	/**
-	 * Sets a fuzzy similarity measure for the values of all data sinks.
-	 * 
-	 * @param similarity
-	 *        the similarity measure to use
-	 */
-	public void addFuzzyValueSimilarity(ValueSimilarity<?> similarity) {
-		this.addFuzzyValueSimilarity(ALL_SINKS, similarity);
-	}
-
-	@Override
-	public void close() throws IOException {
-		ClosableManager closableManager = new ClosableManager();
-
-		for (TestRecords pairs : this.inputs.values())
-			closableManager.add(pairs);
-		for (TestRecords pairs : this.actualOutputs.values())
-			closableManager.add(pairs);
-		for (TestRecords pairs : this.expectedOutputs.values())
-			closableManager.add(pairs);
-
-		closableManager.close();
-	}
-
-	/**
-	 * Returns the first output {@link TestPairs} of the TestPlan. If multiple
-	 * contracts are tested in the TestPlan, it is recommended to use the {@link #getActualOutput(GenericDataSink)}
-	 * method to unambiguously get
-	 * the values.<br>
-	 * The values are only meaningful after a {@link #run()}.
-	 * 
-	 * @return the first output of the TestPlan
-	 */
-	public TestRecords getActualOutput() {
-		return this.getActualOutput(0);
-	}
-
-	/**
-	 * Returns the output {@link TestPairs} of the TestPlan associated with the
-	 * given sink. This is the recommended method to get output pairs for more
-	 * complex TestPlans.<br>
-	 * The values are only meaningful after a {@link #run()}.
-	 * 
-	 * @param <K>
-	 *        the type of the key
-	 * @param <V>
-	 *        the type of the value
-	 * @param sink
-	 *        the sink of which the associated output TestPairs should be
-	 *        returned
-	 * @return the output {@link TestPairs} of the TestPlan associated with the
-	 *         given sink
-	 */
-	public TestRecords getActualOutput(final FileDataSink sink) {
-		TestRecords values = this.actualOutputs.get(sink);
-		if (values == null)
-			this.actualOutputs.put(sink, values = new TestRecords());
-		return values;
-	}
-
-	/**
-	 * Returns the output {@link TestPairs} associated with the <i>i</i>th
-	 * output of the TestPlan. If multiple contracts are tested in the TestPlan,
-	 * it is recommended to use the {@link #getActualOutput(GenericDataSink)} method to unambiguously get the
-	 * values.<br>
-	 * The values are only meaningful after a {@link #run()}.
-	 * 
-	 * @param number
-	 *        the number of the output.
-	 * @return the <i>i</i>th output of the TestPlan
-	 */
-	public TestRecords getActualOutput(final int number) {
-		return this.getActualOutput(this.getDataSinks().get(number));
-	}
-
-	/**
-	 * Allowed delta for PactDouble values, default value is 0.
-	 * 
-	 * @return the allowed delta
-	 */
-	public double getAllowedPactDoubleDelta() {
-		for (ValueSimilarity<?> sim : this.getFuzzySimilarities())
-			if (sim instanceof DoubleValueSimilarity)
-				return ((DoubleValueSimilarity) sim).getDelta();
-		return 0;
-	}
-
-	/**
-	 * Returns the degreeOfParallelism.
-	 * 
-	 * @return the degreeOfParallelism
-	 */
-	public int getDegreeOfParallelism() {
-		return this.degreeOfParallelism;
-	}
-
-	/**
-	 * Returns the first expected output {@link TestPairs} of the TestPlan. If
-	 * multiple contracts are tested in the TestPlan, it is recommended to use
-	 * the {@link #getExpectedOutput(GenericDataSink)} method to unambiguously
-	 * set the values.
-	 * 
-	 * @return the first expected output of the TestPlan
-	 */
-	public TestRecords getExpectedOutput(Class<? extends Value> firstFieldType, Class<?>... otherFieldTypes) {
-		return this.getExpectedOutput(0, firstFieldType, otherFieldTypes);
-	}
-
-	/**
-	 * Returns the first expected output {@link TestPairs} of the TestPlan. If
-	 * multiple contracts are tested in the TestPlan, it is recommended to use
-	 * the {@link #getExpectedOutput(GenericDataSink)} method to unambiguously
-	 * set the values.
-	 * 
-	 * @return the first expected output of the TestPlan
-	 */
-	public TestRecords getExpectedOutput(Class<? extends Value>[] schema) {
-		return this.getExpectedOutput(0, schema);
-	}
-
-	/**
-	 * Returns the expected output {@link TestPairs} of the TestPlan associated
-	 * with the given sink. This is the recommended method to set expected
-	 * output pairs for more complex TestPlans.
-	 * 
-	 * @param <K>
-	 *        the type of the key
-	 * @param <V>
-	 *        the type of the value
-	 * @param sink
-	 *        the sink of which the associated expected output TestPairs
-	 *        should be returned
-	 * @return the expected output {@link TestPairs} of the TestPlan associated
-	 *         with the given sink
-	 */
-	public TestRecords getExpectedOutput(final FileDataSink sink, Class<? extends Value> firstFieldType,
-			Class<?>... otherFieldTypes) {
-		return this.getExpectedOutput(sink, SchemaUtils.combineSchema(firstFieldType, otherFieldTypes));
-	}
-
-	/**
-	 * Returns the expected output {@link TestPairs} of the TestPlan associated
-	 * with the given sink. This is the recommended method to set expected
-	 * output pairs for more complex TestPlans.
-	 * 
-	 * @param <K>
-	 *        the type of the key
-	 * @param <V>
-	 *        the type of the value
-	 * @param sink
-	 *        the sink of which the associated expected output TestPairs
-	 *        should be returned
-	 * @return the expected output {@link TestPairs} of the TestPlan associated
-	 *         with the given sink
-	 */
-	public TestRecords getExpectedOutput(final FileDataSink sink, Class<? extends Value>[] schema) {
-		TestRecords values = this.expectedOutputs.get(sink);
-		if (values == null) {
-			this.expectedOutputs.put(sink, values = new TestRecords(schema));
-			TestRecords actualOutput = this.getActualOutput(sink);
-			actualOutput.setSchema(values.getSchema());
-		}
-		return values;
-	}
-
-	/**
-	 * Returns the expected output {@link TestPairs} associated with the
-	 * <i>i</i>th expected output of the TestPlan. If multiple contracts are
-	 * tested in the TestPlan, it is recommended to use the {@link #getExpectedOutput(GenericDataSink)} method to
-	 * unambiguously set
-	 * the values.
-	 * 
-	 * @param number
-	 *        the number of the expected output.
-	 * @return the <i>i</i>th expected output of the TestPlan
-	 */
-	public TestRecords getExpectedOutput(final int number, Class<? extends Value> firstFieldType,
-			Class<?>... otherFieldTypes) {
-		return this.getExpectedOutput(this.getDataSinks().get(number), firstFieldType, otherFieldTypes);
-	}
-
-	/**
-	 * Returns the expected output {@link TestPairs} associated with the
-	 * <i>i</i>th expected output of the TestPlan. If multiple contracts are
-	 * tested in the TestPlan, it is recommended to use the {@link #getExpectedOutput(GenericDataSink)} method to
-	 * unambiguously set
-	 * the values.
-	 * 
-	 * @param number
-	 *        the number of the expected output.
-	 * @return the <i>i</i>th expected output of the TestPlan
-	 */
-	public TestRecords getExpectedOutput(final int number, Class<? extends Value>[] schema) {
-		return this.getExpectedOutput(this.getDataSinks().get(number), schema);
-	}
-
-	/**
-	 * Returns the default fuzzy global matcher of all data sinks.
-	 * 
-	 * @return the global matcher
-	 */
-	public FuzzyValueMatcher getFuzzyMatcher() {
-		return this.fuzzyMatchers.get(ALL_SINKS);
-	}
-
-	/**
-	 * Returns the global matcher of the given data sink. If no measure has been explicitly set for this sink,
-	 * the matcher for all sinks is returned if set.
-	 * 
-	 * @param sink
-	 *        the data sink
-	 * @param <V>
-	 *        the value type
-	 * @return the global matcher
-	 */
-	public FuzzyValueMatcher getFuzzyMatcher(GenericDataSink sink) {
-		FuzzyValueMatcher matcher = this.fuzzyMatchers.get(sink);
-		if (matcher == null)
-			matcher = this.fuzzyMatchers.get(ALL_SINKS);
-		return matcher;
-	}
-
-	/**
-	 * Returns the default fuzzy similarity measure of all data sinks.
-	 * 
-	 * @return the similarity measure
-	 */
-	public List<ValueSimilarity<?>> getFuzzySimilarities() {
-		return this.getFuzzySimilarities(ALL_SINKS, TestRecords.ALL_VALUES);
-	}
-
-	/**
-	 * Returns the fuzzy similarity measure of the given data sink. If no measure has been explicitly set for this sink,
-	 * the measure for all sinks is returned if set.
-	 * 
-	 * @param sink
-	 *        the data sink
-	 * @param <V>
-	 *        the value type
-	 * @return the similarity measure
-	 */
-	public List<ValueSimilarity<?>> getFuzzySimilarities(GenericDataSink sink, int valueIndex) {
-		Int2ObjectMap<List<ValueSimilarity<?>>> indexMap = this.getFuzzySimilarityIndexMap(sink);
-		List<ValueSimilarity<?>> list = indexMap.get(valueIndex);
-		if (list == null)
-			indexMap.put(valueIndex, list = new ArrayList<ValueSimilarity<?>>());
-		return list;
-	}
-
-	/**
-	 * Returns the first input {@link TestPairs} of the TestPlan. If multiple
-	 * contracts are tested in the TestPlan, it is recommended to use the {@link #getInput(GenericDataSource<?>)} method
-	 * to unambiguously set the
-	 * values.
-	 * 
-	 * @return the first input of the TestPlan
-	 */
-	public TestRecords getInput() {
-		return this.getInput(0);
-	}
-
-	/**
-	 * Returns the input {@link TestPairs} of the TestPlan associated with the
-	 * given source. This is the recommended method to set input pairs for more
-	 * complex TestPlans.
-	 * 
-	 * @param <K>
-	 *        the type of the key
-	 * @param <V>
-	 *        the type of the value
-	 * @param source
-	 *        the source of which the associated input TestPairs should be
-	 *        returned
-	 * @return the input {@link TestPairs} of the TestPlan associated with the
-	 *         given source
-	 */
-	public TestRecords getInput(final GenericDataSource<?> source) {
-		TestRecords values = this.inputs.get(source);
-		if (values == null)
-			this.inputs.put(source, values = new TestRecords());
-		return values;
-	}
-
-	/**
-	 * Returns the input {@link TestPairs} associated with the <i>i</i>th input
-	 * of the TestPlan. If multiple contracts are tested in the TestPlan, it is
-	 * recommended to use the {@link #getInput(GenericDataSource<?>)} method to
-	 * unambiguously set the values.
-	 * 
-	 * @param number
-	 *        the number of the input.
-	 * @return the <i>i</i>th input of the TestPlan
-	 */
-	public TestRecords getInput(final int number) {
-		return this.getInput(this.getDataSources().get(number));
-	}
-
-	/**
-	 * Traverses the test plan and returns the first contracts that process the
-	 * data of the given contract.
-	 * 
-	 * @param contract
-	 *        the contract of which one preceding contracts should be
-	 *        returned
-	 * @return returns the first contract that process the data of the given
-	 *         contract
-	 */
-	public Contract getOutputOfContract(Contract contract) {
-		return this.getOutputsOfContract(contract)[0];
-	}
-
-	/**
-	 * Traverses the test plan and returns all contracts that process the data
-	 * of the given contract.
-	 * 
-	 * @param contract
-	 *        the contract of which preceding contracts should be returned
-	 * @return returns all contracts that process the data of the given contract
-	 */
-	public Contract[] getOutputsOfContract(final Contract contract) {
-		final ArrayList<Contract> outputs = new ArrayList<Contract>();
-
-		for (final Contract sink : this.sinks)
-			sink.accept(new Visitor<Contract>() {
-				LinkedList<Contract> outputStack = new LinkedList<Contract>();
-
-				@Override
-				public void postVisit(final Contract visitable) {
-				}
-
-				@Override
-				public boolean preVisit(final Contract visitable) {
-					if (visitable == contract)
-						outputs.add(this.outputStack.peek());
-					this.outputStack.push(visitable);
-					return true;
-				}
-			});
-
-		return outputs.toArray(new Contract[outputs.size()]);
-	}
-
-	/**
-	 * Returns all {@link GenericDataSink}s of this test plan.
-	 * 
-	 * @return the sinks
-	 */
-	public List<FileDataSink> getSinks() {
-		return this.sinks;
-	}
-
-	/**
-	 * Returns the sources.
-	 * 
-	 * @return the sources
-	 */
-	public List<FileDataSource> getSources() {
-		return this.sources;
-	}
-
-	/**
-	 * Removes the fuzzy global matcher of the given data sink.
-	 * 
-	 * @param sink
-	 *        the data sink
-	 */
-	public void removeFuzzyValueMatcher(GenericDataSink sink) {
-		this.fuzzyMatchers.remove(sink);
-	}
-
-	/**
-	 * Removes the fuzzy similarity measure of the given data sink.
-	 * 
-	 * @param sink
-	 *        the data sink
-	 */
-	public void removeFuzzyValueSimilarity(GenericDataSink sink) {
-		this.fuzzySimilarity.remove(sink);
-	}
-
-	/**
-	 * Compiles the plan to an {@link ExecutionGraph} and executes it. If
-	 * expected values have been specified, the actual outputs values are
-	 * compared to the expected values.
-	 */
-	public void run() {
-		this.errorHandlers.clear();
-		try {
-			ExecutionGraph eg = this.getExecutionGraph();
-			this.addErrorHandler(eg);
-			this.localScheduler = new LocalScheduler(MockDeployManager.INSTANCE, MockInstanceManager.INSTANCE);
-			MockTaskManager.INSTANCE.addJobGraph(eg);
-			eg.registerJobStatusListener(MockJobManager.INSTANCE);
-			this.localScheduler.schedulJob(eg);
-			this.execute(eg);
-		} catch (final Exception e) {
-			Assert.fail("plan scheduling: " + StringUtils.stringifyException(e));
-		}
-
-		for (ExecutionExceptionHandler errorHandler : this.errorHandlers)
-			// these fields are set by the ExecutionExceptionHandler in case of error
-			if (errorHandler.executionError != null)
-				Assert.fail(String.format("Error @ %s: %s", errorHandler.executionVertex.getName(),
-					errorHandler.executionError));
-
-		try {
-			this.validateResults();
-		} finally {
-			this.errorHandlers.clear();
-			try {
-				this.close();
-			} catch (IOException e) {
-			}
-		}
-	}
-
-	/**
-	 * Compiles the plan to an {@link ExecutionGraph} and executes it. If
-	 * expected values have been specified, the actual outputs values are
-	 * compared to the expected values.
-	 */
-	public void runWithMiniCluster() {
-		try {
-			Configuration config = new Configuration();
-
-			// local ip as job manager (localhost or 127.0.0.1 does not work)
-			config.setString(ConfigConstants.JOB_MANAGER_IPC_ADDRESS_KEY, "localhost");
-			JobManager jobManager = new JobManager(ExecutionMode.LOCAL);
-
-			PactCompiler pc = new PactCompiler();
-			Plan plan = this.buildPlanWithReadableSinks();
-			OptimizedPlan op = pc.compile(plan);
-
-			NepheleJobGraphGenerator jgg = new NepheleJobGraphGenerator();
-			JobGraph jobGraph = jgg.compileJobGraph(op);
-
-			jobManager.submitJob(jobGraph);
-
-			Configuration configuration = jobGraph.getJobConfiguration();
-			configuration.setString(ConfigConstants.JOB_MANAGER_IPC_ADDRESS_KEY, "localhost");
-
-			// submit
-			JobClient jobClient = new JobClient(jobGraph, configuration);
-			jobClient.submitJobAndWait();
-		} catch (CompilerException e1) {
-			e1.printStackTrace();
-		} catch (IOException e1) {
-			e1.printStackTrace();
-		} catch (JobExecutionException e1) {
-			e1.printStackTrace();
-		}
-
-		try {
-			this.validateResults();
-		} finally {
-			try {
-				this.close();
-			} catch (IOException e) {
-			}
-		}
-	}
-
-	/**
-	 * Set the allowed delta for PactDouble values to match expected and actual values that differ due to inaccuracies
-	 * in the floating point calculation.
-	 * 
-	 * @param delta
-	 *        the delta that the actual value is allowed to differ from the expected value.
-	 */
-	public void setAllowedPactDoubleDelta(double delta) {
-		ListIterator<ValueSimilarity<?>> simIter =
-			this.getFuzzySimilarities(ALL_SINKS, TestRecords.ALL_VALUES).listIterator();
-		// replace existing
-		while (simIter.hasNext()) {
-			ValueSimilarity<?> sim = simIter.next();
-			if (sim instanceof DoubleValueSimilarity) {
-				simIter.set(new DoubleValueSimilarity(delta));
-				return;
-			}
-		}
-		// or add new
-		this.addFuzzyValueSimilarity(new DoubleValueSimilarity(delta));
-	}
-
-	/**
-	 * Sets the degreeOfParallelism to the specified value.
-	 * 
-	 * @param degreeOfParallelism
-	 *        the degreeOfParallelism to set
-	 */
-	public void setDegreeOfParallelism(final int degreeOfParallelism) {
-		this.degreeOfParallelism = degreeOfParallelism;
-	}
-
-	/**
-	 * Sets a fuzzy global matcher for the values of all data sinks.
-	 * 
-	 * @param matcher
-	 *        the global matcher to use
-	 */
-	public void setFuzzyValueMatcher(FuzzyValueMatcher matcher) {
-		this.fuzzyMatchers.put(ALL_SINKS, matcher);
-	}
-
-	/**
-	 * Sets a fuzzy global matcher for the values of the given data sink.
-	 * 
-	 * @param <V>
-	 *        the value type
-	 * @param sink
-	 *        the data sink
-	 * @param matcher
-	 *        the global matcher to use
-	 */
-	public void setFuzzyValueMatcher(GenericDataSink sink, FuzzyValueMatcher matcher) {
-		this.fuzzyMatchers.put(sink, matcher);
-	}
-
-	protected void addErrorHandler(ExecutionGraph eg) {
-		ExecutionGraphIterator executionGraphIterator = new ExecutionGraphIterator(eg, true);
-		while (executionGraphIterator.hasNext()) {
-			ExecutionVertex executionVertex = executionGraphIterator.next();
-			ExecutionExceptionHandler errorHandler = new ExecutionExceptionHandler(executionVertex);
-			executionVertex.registerExecutionListener(errorHandler);
-			this.errorHandlers.add(errorHandler);
-		}
-	}
-
-	protected Int2ObjectMap<List<ValueSimilarity<?>>> getFuzzySimilarityIndexMap(GenericDataSink sink) {
-		Int2ObjectMap<List<ValueSimilarity<?>>> indexMap = this.fuzzySimilarity.get(sink);
-		if (indexMap == null)
-			this.fuzzySimilarity.put(sink, indexMap = new Int2ObjectArrayMap<List<ValueSimilarity<?>>>());
-		return indexMap;
-	}
-
-	/**
-	 * Actually builds the plan but guarantees that the output can be read
-	 * without additional knowledge. Currently the {@link SequentialOutputFormat} is used for a guaranteed
-	 * deserializable
-	 * output.<br>
-	 * If a data source is not {@link SequentialOutputFormat}, it is replaced by
-	 * a {@link SplittingOutputFormat}, with two outputs: the original one and
-	 * one {@link SequentialOutputFormat}.
-	 */
-	private Plan buildPlanWithReadableSinks() {
-		final Collection<FileDataSink> existingSinks = this.getDataSinks();
-		final Collection<GenericDataSink> wrappedSinks = new ArrayList<GenericDataSink>();
-		for (final FileDataSink fileSink : existingSinks)
-			// need a format which is deserializable without configuration
-			if (!fileSink.getFormatClass().equals(SequentialOutputFormat.class)) {
-				TestRecords expectedValues = this.expectedOutputs.get(fileSink);
-
-				final FileDataSink safeSink = createDefaultSink(fileSink.getName());
-
-				safeSink.setInputs(fileSink.getInputs());
-
-				wrappedSinks.add(fileSink);
-				wrappedSinks.add(safeSink);
-
-				// only add to expected outputs if we need to check for values
-				if (expectedValues != null)
-					this.expectedOutputs.put(safeSink, expectedValues);
-				this.actualOutputs.put(safeSink, this.getActualOutput(fileSink));
-				this.getActualOutput(fileSink).fromFile(SequentialInputFormat.class, safeSink.getFilePath());
-
-			} else {
-				wrappedSinks.add(fileSink);
-				this.getActualOutput(fileSink).fromFile(SequentialInputFormat.class, fileSink.getFilePath());
-			}
-
-		return new Plan(wrappedSinks);
-	}
-
-	private OptimizedPlan compile(final Plan plan) {
-		final OptimizedPlan optimizedPlan =
-			new PactCompiler(null, new CostEstimator(), new InetSocketAddress(0)).compile(
-				plan, MOCK_INSTANCE_DESCRIPTION);
-		return optimizedPlan;
-	}
-
-	/**
-	 * 
-	 */
-	private void configureSinksAndSources() {
-		for (FileDataSink sink : this.sinks)
-			sink.getParameters().setLong(FileOutputFormat.OUTPUT_STREAM_OPEN_TIMEOUT_KEY, 0);
-		for (FileDataSource source : this.sources)
-			source.getParameters().setLong(FileInputFormat.INPUT_STREAM_OPEN_TIMEOUT_KEY, 0);
-	}
-
-	/**
-	 * Locally executes the {@link ExecutionGraph}.
-	 */
-	private void execute(final ExecutionGraph eg) {
-		while (!eg.isExecutionFinished() && eg.getJobStatus() != InternalJobStatus.FAILED)
-			try {
-				Thread.sleep(10);
-			} catch (final InterruptedException e) {
-			}
-	}
-
-	/**
-	 * Traverses the plan for all sinks and sources.
-	 */
-	private void findSinksAndSources() {
-		for (final Contract contract : this.contracts)
-			contract.accept(new Visitor<Contract>() {
-				@Override
-				public void postVisit(final Contract visitable) {
-				}
-
-				@Override
-				public boolean preVisit(final Contract visitable) {
-					if (visitable instanceof FileDataSink && !TestPlan.this.sinks.contains(visitable))
-						TestPlan.this.sinks.add((FileDataSink) visitable);
-					if (visitable instanceof FileDataSource && !TestPlan.this.sources.contains(visitable))
-						TestPlan.this.sources.add((FileDataSource) visitable);
-					return true;
-				}
-			});
-
-//		for (FileDataSource source : this.sources)
-//			this.getInput(source).fromFile(source.getFormatClass(), source.getFilePath(), source.getParameters());
-	}
-
-	private List<FileDataSink> getDataSinks() {
-		return this.sinks;
-	}
-
-	private List<? extends GenericDataSource<?>> getDataSources() {
-		return this.sources;
-	}
-
-	private ExecutionGraph getExecutionGraph() throws IOException, GraphConversionException {
-		final Plan plan = this.buildPlanWithReadableSinks();
-		this.syncDegreeOfParallelism(plan);
-		this.initAdhocInputs();
-
-		final OptimizedPlan optimizedPlan = this.compile(plan);
-		this.replaceShippingStrategy(optimizedPlan);
-		final JobGraph jobGraph = new NepheleJobGraphGenerator().compileJobGraph(optimizedPlan);
-		for (AbstractJobVertex vertex : jobGraph.getAllJobVertices())
-			vertex.setNumberOfExecutionRetries(0);
-		LibraryCacheManager.register(jobGraph.getJobID(), new String[0]);
-		return new ExecutionGraph(jobGraph, MockInstanceManager.INSTANCE);
-	}
-
-	/**
-	 * @return
-	 */
-	private String getNepheleConf() throws IOException {
-		File nepheleConfigDir = File.createTempFile("nephele", null);
-		nepheleConfigDir.delete();
-		nepheleConfigDir.mkdir();
-
-		// config
-		final String nepheleConfigDirJob = nepheleConfigDir.getAbsolutePath();
-		final int jobManagerRpcPort = ConfigConstants.DEFAULT_JOB_MANAGER_IPC_PORT;
-		final int rpcPort = 6501, dataPort = 7501;
-
-		FileWriter writer = new FileWriter(new File(nepheleConfigDir, "nephele-user.xml"));
-		String lines[] = {
-			"<?xml version=\"1.0\" encoding=\"UTF-8\"?>",
-			"<configuration>",
-			"    <property>",
-			"        <key>jobmanager.instancemanager.local.classname</key>",
-			"        <value>" + LocalInstanceManager.class.getName() + "</value>",
-			"    </property>",
-			"    <property>",
-			"        <key>jobmanager.scheduler.local.classname</key>",
-			"        <value>" + LocalScheduler.class.getName() + "</value>",
-			"    </property>",
-			"    <property>",
-			"        <key>" + ConfigConstants.JOB_MANAGER_IPC_ADDRESS_KEY + "</key>",
-			"        <value>localhost</value>",
-			// "        <value>" + getLocalIpAddress() + "</value>",
-			"    </property>",
-			"    <property>",
-			"        <key>" + ConfigConstants.JOB_MANAGER_IPC_PORT_KEY + "</key>",
-			"        <value>" + jobManagerRpcPort + "</value>",
-			"    </property>",
-			"    <property>",
-			"        <key>" + ConfigConstants.TASK_MANAGER_IPC_PORT_KEY + "</key>",
-			"        <value>" + rpcPort + "</value>",
-			"    </property>",
-			"    <property>",
-			"        <key>" + ConfigConstants.TASK_MANAGER_DATA_PORT_KEY + "</key>",
-			"        <value>" + dataPort + "</value>",
-			"    </property>",
-			"    <property>",
-			"        <key>taskmanager.setup.usediscovery</key>",
-			"        <value>false</value>",
-			"    </property>",
-			"    <property>",
-			"        <key>jobmanager.visualization.enable</key>",
-			"        <value>false</value>",
-			"    </property>",
-			"</configuration>" };
-		for (String line : lines)
-			writer.write(line);
-		writer.close();
-
-		return nepheleConfigDirJob;
-	}
-
-	private void initAdhocInputs() throws IOException {
-		for (final FileDataSource source : this.sources) {
-			final TestRecords input = this.getInput(source);
-			if (input.isAdhoc())
-				input.saveToFile(source.getFilePath());
-		}
-	}
-
-	private Int2ObjectMap<List<ValueSimilarity<?>>> mergeSimilarityIndices(
-			Int2ObjectMap<List<ValueSimilarity<?>>> similarityMap) {
-		similarityMap = new Int2ObjectOpenHashMap<List<ValueSimilarity<?>>>(similarityMap);
-		for (Entry<List<ValueSimilarity<?>>> entry : this.getFuzzySimilarityIndexMap(ALL_SINKS).int2ObjectEntrySet())
-			if (!entry.getValue().isEmpty()) {
-				List<ValueSimilarity<?>> existingList = similarityMap.get(entry.getKey());
-				if (existingList == null)
-					similarityMap.put(entry.getKey(), entry.getValue());
-				else
-					existingList.addAll(entry.getValue());
-			}
-		return similarityMap;
-	}
-
-	private void replaceShippingStrategy(final OptimizedPlan optimizedPlan) {
-		// final Field declaredField =
-		// PactConnection.class.getDeclaredField("shipStrategy");
-		// declaredField.setAccessible(true);
-//		for (final OptimizerNode node : optimizedPlan.getAllNodes()) {
-//			for (final PactConnection pactConnection : node.getIncomingConnections())
-//				pactConnection.setShipStrategy(ShipStrategyType.FORWARD);
-//			for (final PactConnection pactConnection : node.getOutgoingConnections())
-//				// declaredField.set(pactConnection, ShipStrategy.FORWARD);
-//				pactConnection.setShipStrategy(ShipStrategyType.FORWARD);
-//		}
-	}
-
-	/**
-	 * Sets the degree of parallelism for every node in the plan.
-	 */
-	private void syncDegreeOfParallelism(final Plan plan) {
-		plan.accept(new Visitor<Contract>() {
-
-			@Override
-			public void postVisit(final Contract visitable) {
-			}
-
-			@Override
-			public boolean preVisit(final Contract visitable) {
-				int degree = TestPlan.this.getDegreeOfParallelism();
-				if (visitable instanceof GenericDataSource<?>)
-					degree = 1;
-				else if (degree > 1 && visitable instanceof FileDataSink)
-					try {
-						Path path = new Path(((FileDataSink) visitable).getFilePath());
-
-						final FileSystem fs = path.getFileSystem();
-
-						final FileStatus f = fs.getFileStatus(path);
-
-						if (!f.isDir()) {
-							fs.delete(path, false);
-							fs.mkdirs(path);
-						}
-					} catch (IOException e) {
-						e.printStackTrace();
-					}
-				if (visitable.getDegreeOfParallelism() == -1)
-					visitable.setDegreeOfParallelism(degree);
-				return true;
-			}
-		});
-	}
-
-	@SuppressWarnings("unchecked")
-	private void validateResults() {
-		for (final FileDataSink sinkContract : this.getDataSinks()) {
-			TestRecords expectedValues = this.expectedOutputs.get(sinkContract);
-			// need a format which is deserializable without configuration
-			if (sinkContract.getFormatClass() == SequentialOutputFormat.class && expectedValues != null
-				&& expectedValues.isInitialized()) {
-				final TestRecords actualValues = new TestRecords();
-				actualValues.fromFile(SequentialInputFormat.class, sinkContract.getFilePath());
-
-				FuzzyValueMatcher fuzzyMatcher = this.getFuzzyMatcher(sinkContract);
-				Int2ObjectMap<List<ValueSimilarity<?>>> similarityMap = this.getFuzzySimilarityIndexMap(sinkContract);
-				if (similarityMap == null)
-					similarityMap = Int2ObjectMaps.EMPTY_MAP;
-				if (!this.getFuzzySimilarityIndexMap(ALL_SINKS).isEmpty())
-					similarityMap = this.mergeSimilarityIndices(similarityMap);
-				try {
-					actualValues.assertEquals(expectedValues, fuzzyMatcher, similarityMap);
-				} catch (AssertionError e) {
-					AssertionError assertionError = new AssertionError(sinkContract.getName() + ": " + e.getMessage());
-					assertionError.initCause(e.getCause());
-					throw assertionError;
-				}
-			}
-		}
-	}
-
-	/**
-	 * Creates a default sink with the given name. This sink may be used with ad-hoc values added to the corresponding
-	 * {@link TestPairs}.
-	 * 
-	 * @param name
-	 *        the name of the sink
-	 * @return the created sink
-	 */
-	public static FileDataSink createDefaultSink(final String name) {
-		return new FileDataSink(SequentialOutputFormat.class, getTestPlanFile("output"), name);
-	}
-
-	/**
-	 * Creates a default source with the given name. This sink may be used with ad-hoc values added to the corresponding
-	 * {@link TestPairs}.
-	 * 
-	 * @param name
-	 *        the name of the source
-	 * @return the created source
-	 */
-	public static FileDataSource createDefaultSource(final String name) {
-		return new FileDataSource(SequentialInputFormat.class, getTestPlanFile("input"), name);
-	}
-
-	static String getTestPlanFile(final String prefix) {
-		return createTemporaryFile("testPlan", prefix);
-	}
-
-	private static String createTemporaryFile(String suffix, String prefix) {
-		try {
-			final File tempFile = File.createTempFile(suffix, prefix);
-			tempFile.deleteOnExit();
-			return tempFile.toURI().toString();
-		} catch (final IOException e) {
-			throw new IllegalStateException("Cannot create temporary file for prefix " + prefix, e);
-		}
-	}
-
-	private static final class CostEstimator extends DefaultCostEstimator {
-		private CostEstimator() {
-			super();
-		}
-		//
-		// @Override
-		// public void getBroadcastCost(OptimizerNode target, OptimizerNode
-		// source, Costs costs) {
-		// costs.setNetworkCost(Long.MAX_VALUE);
-		// }
-	}
-
-	private final class ExecutionExceptionHandler implements ExecutionListener {
-		private String executionError;
-
-		public ExecutionVertex executionVertex;
-
-		public ExecutionExceptionHandler(ExecutionVertex executionVertex) {
-			this.executionVertex = executionVertex;
-		}
-
-		/*
-		 * (non-Javadoc)
-		 * @see
-		 * eu.stratosphere.nephele.execution.ExecutionListener#executionStateChanged(eu.stratosphere.nephele.jobgraph
-		 * .JobID, eu.stratosphere.nephele.executiongraph.ExecutionVertexID,
-		 * eu.stratosphere.nephele.execution.ExecutionState, java.lang.String)
-		 */
-		@Override
-		public void executionStateChanged(JobID jobID, ExecutionVertexID vertexID, ExecutionState newExecutionState,
-				String optionalMessage) {
-			if (newExecutionState == ExecutionState.FAILED && this.executionError == null)
-				this.executionError = optionalMessage == null ? "FAILED" : optionalMessage;
-		}
-
-		/*
-		 * (non-Javadoc)
-		 * @see eu.stratosphere.nephele.execution.ExecutionListener#getPriority()
-		 */
-		@Override
-		public int getPriority() {
-			return 13;
-		}
-
-		/*
-		 * (non-Javadoc)
-		 * @see
-		 * eu.stratosphere.nephele.execution.ExecutionListener#userThreadFinished(eu.stratosphere.nephele.jobgraph.JobID
-		 * , eu.stratosphere.nephele.executiongraph.ExecutionVertexID, java.lang.Thread)
-		 */
-		@Override
-		public void userThreadFinished(JobID jobID, ExecutionVertexID vertexID, Thread userThread) {
-		}
-
-		/*
-		 * (non-Javadoc)
-		 * @see
-		 * eu.stratosphere.nephele.execution.ExecutionListener#userThreadStarted(eu.stratosphere.nephele.jobgraph.JobID,
-		 * eu.stratosphere.nephele.executiongraph.ExecutionVertexID, java.lang.Thread)
-		 */
-		@Override
-		public void userThreadStarted(JobID jobID, ExecutionVertexID vertexID, Thread userThread) {
-		}
-
-	}
-
-}
\ No newline at end of file
diff --git a/pact/pact-clients/src/main/java/eu/stratosphere/pact/testing/TestRecords.java b/pact/pact-clients/src/main/java/eu/stratosphere/pact/testing/TestRecords.java
deleted file mode 100644
index 41fca96..0000000
--- a/pact/pact-clients/src/main/java/eu/stratosphere/pact/testing/TestRecords.java
+++ /dev/null
@@ -1,640 +0,0 @@
-/***********************************************************************************************************************
- *
- * Copyright (C) 2010 by the Stratosphere project (http://stratosphere.eu)
- *
- * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with
- * the License. You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on
- * an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
- * specific language governing permissions and limitations under the License.
- *
- **********************************************************************************************************************/
-
-package eu.stratosphere.pact.testing;
-
-import it.unimi.dsi.fastutil.ints.Int2ObjectMap;
-import it.unimi.dsi.fastutil.ints.Int2ObjectMap.Entry;
-import it.unimi.dsi.fastutil.ints.Int2ObjectOpenHashMap;
-import it.unimi.dsi.fastutil.ints.IntArrayList;
-import it.unimi.dsi.fastutil.ints.IntList;
-import it.unimi.dsi.fastutil.objects.ObjectIterator;
-
-import java.io.Closeable;
-import java.io.IOException;
-import java.util.ArrayList;
-import java.util.Arrays;
-import java.util.Collections;
-import java.util.Comparator;
-import java.util.Iterator;
-import java.util.List;
-
-import junit.framework.Assert;
-
-import org.junit.internal.ArrayComparisonFailure;
-
-import eu.stratosphere.nephele.configuration.Configuration;
-import eu.stratosphere.nephele.configuration.GlobalConfiguration;
-import eu.stratosphere.nephele.services.memorymanager.MemoryAllocationException;
-import eu.stratosphere.nephele.template.AbstractTask;
-import eu.stratosphere.nephele.util.StringUtils;
-import eu.stratosphere.pact.common.io.FileInputFormat;
-import eu.stratosphere.pact.common.io.FormatUtil;
-import eu.stratosphere.pact.common.io.SequentialOutputFormat;
-import eu.stratosphere.pact.common.type.Key;
-import eu.stratosphere.pact.common.type.PactRecord;
-import eu.stratosphere.pact.common.type.Value;
-import eu.stratosphere.pact.common.util.InstantiationUtil;
-import eu.stratosphere.pact.common.util.MutableObjectIterator;
-import eu.stratosphere.pact.runtime.plugable.pactrecord.PactRecordComparator;
-import eu.stratosphere.pact.runtime.plugable.pactrecord.PactRecordSerializer;
-import eu.stratosphere.pact.runtime.sort.UnilateralSortMerger;
-import eu.stratosphere.pact.runtime.task.util.TaskConfig;
-import eu.stratosphere.pact.runtime.util.KeyComparator;
-
-/**
- * Represents the input or output values of a {@link TestPlan}. The class is
- * especially important when setting the expected values in the TestPlan.<br>
- * <br>
- * There are two ways to specify the values:
- * <ol>
- * <li>From a file: with {@link #fromFile(Class, String)} and {@link #fromFile(Class, String, Configuration)} the
- * location, format, and configuration of the data can be specified. The file is lazily loaded and thus can be
- * comparable large.
- * <li>Ad-hoc: key/value records can be added with {@link #add(Key, Value)}, {@link #add(KeyValuePair...)}, and
- * {@link #add(Iterable)}. Please note that the actual amount of records is quite for a test case as the TestPlan
- * already involves a certain degree of overhead.<br>
- * <br>
- * TestPairs are directly comparable with equals and hashCode based on its content. Please note that in the case of
- * large file-based TestPairs, the time needed to compute the {@link #hashCode()} or to compare two instances with
- * {@link #equals(Object)} can become quite long. Currently, the comparison result is order-dependent as TestPairs are
- * interpreted as a list.<br>
- * <br>
- * Currently there is no notion of an empty set of records.
- * 
- * @author Arvid Heise
- * @param <K>
- *        the type of the keys
- * @param <V>
- *        the type of the values
- */
-public class TestRecords implements Closeable, Iterable<PactRecord> {
-	private static final class TestPairsReader implements MutableObjectIterator<PactRecord> {
-		private final InputFileIterator inputFileIterator;
-
-		private TestPairsReader(final InputFileIterator inputFileIterator) {
-			this.inputFileIterator = inputFileIterator;
-		}
-
-		/*
-		 * (non-Javadoc)
-		 * @see eu.stratosphere.pact.common.util.MutableObjectIterator#next(java.lang.Object)
-		 */
-		@Override
-		public boolean next(PactRecord target) throws IOException {
-			if (this.inputFileIterator.hasNext()) {
-				this.inputFileIterator.next().copyTo(target);
-				return true;
-			}
-			return false;
-		}
-
-	}
-
-	private static final Iterator<PactRecord> EMPTY_ITERATOR = new ArrayList<PactRecord>().iterator();
-
-	private static final Comparator<Key> KeyComparator = new KeyComparator();
-
-	private Configuration configuration;
-
-	private Class<? extends FileInputFormat> inputFormatClass;
-
-	private final List<PactRecord> records = new ArrayList<PactRecord>();
-
-	private String path;
-
-	private ClosableManager closableManager = new ClosableManager();
-
-	private boolean empty;
-
-	static class SortInfo implements Cloneable {
-		IntList sortKeys = new IntArrayList();
-
-		List<Class<? extends Key>> keyClasses = new ArrayList<Class<? extends Key>>();
-
-		private List<Comparator<Key>> comparators = new ArrayList<Comparator<Key>>();
-
-		public SortInfo(IntList sortKeys, List<Class<? extends Key>> keyClasses,
-				List<? extends Comparator<Key>> comparators) {
-			this.sortKeys.addAll(sortKeys);
-			this.keyClasses.addAll(keyClasses);
-			this.comparators.addAll(comparators);
-		}
-
-		public SortInfo copy() {
-			return new SortInfo(new IntArrayList(this.sortKeys), new ArrayList<Class<? extends Key>>(this.keyClasses),
-				new ArrayList<Comparator<Key>>(this.comparators));
-		}
-
-		public void remove(int removeIndex) {
-			for (int index = 0; index < this.sortKeys.size(); index++)
-				if (this.sortKeys.get(index) == removeIndex) {
-					this.sortKeys.remove(index);
-					this.keyClasses.remove(index);
-					this.comparators.remove(index);
-				}
-		}
-
-		/**
-		 * Initializes TestPairs.SortInfo.
-		 */
-		public SortInfo(IntList sortKeys, List<Class<? extends Key>> keyClasses) {
-			this(sortKeys, keyClasses, Arrays.asList(new KeyComparator[keyClasses.size()]));
-			Collections.fill(this.comparators, KeyComparator);
-		}
-	}
-
-	SortInfo sortInfo;
-
-	private Class<? extends Value>[] schema;
-
-	private Value[] emptyTuple;
-
-	public TestRecords(Class<? extends Value>[] schema) {
-		this.schema = schema;
-		this.emptyTuple = new Value[this.schema.length];
-		for (int index = 0; index < this.schema.length; index++)
-			this.emptyTuple[index] = InstantiationUtil.instantiate(this.schema[index], Value.class);
-		this.sortInfo = this.inferInfo();
-	}
-
-	/**
-	 * Initializes TestPairs.
-	 */
-	@SuppressWarnings("unchecked")
-	public TestRecords() {
-		this.schema = new Class[0];
-		this.emptyTuple = new Value[0];
-	}
-
-	private boolean isEmpty() {
-		return this.empty;
-	}
-
-	private void setEmpty(boolean empty) {
-		this.empty = empty;
-	}
-
-	/**
-	 * Specifies that the set of key/value records is empty. This method is primarily used to distinguish between an
-	 * empty
-	 * uninitialized set and a set deliberately left empty. Further calls to {@link #fromFile(Class, String)} or
-	 * {@link #add(Iterable)} will reset the effect of this method invocation and vice-versa.
-	 */
-	public void setEmpty() {
-		this.setEmpty(true);
-		this.inputFormatClass = null;
-		this.records.clear();
-	}
-
-	/**
-	 * Adds several records at once.
-	 * 
-	 * @param records
-	 *        the records to add
-	 * @return this
-	 */
-	public TestRecords add(final Iterable<? extends PactRecord> records) {
-		for (final PactRecord record : records)
-			this.records.add(record);
-		this.setEmpty(false);
-		this.inputFormatClass = null;
-		return this;
-	}
-
-	/**
-	 * Adds several records at once.
-	 * 
-	 * @param records
-	 *        the records to add
-	 * @return this
-	 */
-	public TestRecords add(final TestRecords records) {
-		if (records.isEmpty())
-			this.setEmpty();
-		else {
-			for (final PactRecord record : records)
-				this.records.add(record);
-			this.setEmpty(false);
-			records.close();
-		}
-		return this;
-	}
-
-	/**
-	 * Adds several records at once.
-	 * 
-	 * @param records
-	 *        the records to add
-	 * @return this
-	 */
-	public TestRecords add(final PactRecord... records) {
-		for (final PactRecord record : records)
-			this.records.add(record);
-		this.setEmpty(false);
-		return this;
-	}
-
-	/**
-	 * Adds a records.
-	 * 
-	 * @param fields
-	 *        the fields of the record
-	 * @return this
-	 */
-	public TestRecords add(final Value... values) {
-		PactRecord record = new PactRecord(values.length);
-		for (int index = 0; index < values.length; index++)
-			record.setField(index, values[index]);
-		this.records.add(record);
-		this.setEmpty(false);
-		return this;
-	}
-
-	private void assignMemory(final TaskConfig config, final int memSize) {
-		// set the config
-//		config.setMemorySize(memSize * 1024L * 1024L);
-//		config.setNumFilehandles(DEFAUTL_MERGE_FACTOR);
-	}
-
-	/**
-	 * Uses {@link UnilateralSortMerger} to sort the files of the {@link SplitInputIterator}.
-	 */
-	private Iterator<PactRecord> createSortedIterator(final InputFileIterator inputFileIterator, SortInfo info) {
-		final TaskConfig config = new TaskConfig(GlobalConfiguration.getConfiguration());
-		this.assignMemory(config, 10);
-
-		// set up memory and io parameters
-//		final long totalMemory = config.getMemorySize();
-//		final int numFileHandles = config.getNumFilehandles();
-
-		try {
-			final StringBuilder testName = new StringBuilder();
-			StackTraceElement[] stackTrace = new Throwable().getStackTrace();
-			for (int index = stackTrace.length - 1; index > 0; index--)
-				if (stackTrace[index].getClassName().contains("Test"))
-					testName.append(stackTrace[index].toString());
-			// instantiate a sort-merger
-			AbstractTask parentTask = new AbstractTask() {
-				@Override
-				public String toString() {
-					return "TestPair Sorter " + testName;
-				}
-				@Override
-				public void registerInputOutput() {}
-				@Override
-				public void invoke() throws Exception {}
-			};
-
-			if (info == null)
-				return inputFileIterator;
-			@SuppressWarnings("unchecked")
-			final PactRecordComparator pactRecordComparator = new PactRecordComparator(info.sortKeys.toIntArray(),
-				info.keyClasses.toArray(new Class[0]));
-			final UnilateralSortMerger<PactRecord> sortMerger =
-//				new UnilateralSortMerger<PactRecord>(MockTaskManager.INSTANCE.getMemoryManager(),
-//					MockTaskManager.INSTANCE.getIoManager(), new TestPairsReader(inputFileIterator), parentTask,
-//					PactRecordSerializer.get(), pactRecordComparator, totalMemory, numFileHandles, 0.7f);
-					new UnilateralSortMerger<PactRecord>(MockTaskManager.INSTANCE.getMemoryManager(),
-							MockTaskManager.INSTANCE.getIoManager(), new TestPairsReader(inputFileIterator), parentTask,
-							PactRecordSerializer.get(), pactRecordComparator, 0, 0, 0.7f);
-			this.closableManager.add(sortMerger);
-
-			// obtain and return a grouped iterator from the sort-merger
-			return new ImmutableRecordIterator(sortMerger.getIterator());
-		} catch (final MemoryAllocationException mae) {
-			throw new RuntimeException(
-				"MemoryManager is not able to provide the required amount of memory for ReduceTask", mae);
-		} catch (final IOException ioe) {
-			throw new RuntimeException("IOException caught when obtaining SortMerger for ReduceTask", ioe);
-		} catch (final InterruptedException iex) {
-			throw new RuntimeException("InterruptedException caught when obtaining iterator over sorted data.", iex);
-		}
-	}
-
-	/**
-	 * @return
-	 */
-	@SuppressWarnings("unchecked")
-	private SortInfo inferInfo() {
-		IntList sortKeys = new IntArrayList();
-		List<Class<? extends Key>> keyClasses = new ArrayList<Class<? extends Key>>();
-		for (int fieldIndex = 0; fieldIndex < this.schema.length; fieldIndex++)
-			if (Key.class.isAssignableFrom(this.schema[fieldIndex])) {
-				keyClasses.add((Class<? extends Key>) this.schema[fieldIndex]);
-				sortKeys.add(fieldIndex);
-			}
-		return new SortInfo(sortKeys, keyClasses);
-	}
-
-	@Override
-	public void close() {
-		try {
-			this.closableManager.close();
-		} catch (IOException e) {
-		}
-	}
-
-	/**
-	 * Asserts that the contained set of records is equal to the set of records of the given {@link TestPairs}.
-	 * 
-	 * @param expectedValues
-	 *        the other TestPairs defining the expected result
-	 * @throws ArrayComparisonFailure
-	 *         if the sets differ
-	 */
-	public void assertEquals(final TestRecords expectedValues) throws ArrayComparisonFailure {
-		this.assertEquals(expectedValues, new EqualityValueMatcher(),
-			new Int2ObjectOpenHashMap<List<ValueSimilarity<?>>>());
-	}
-
-	static <T> T firstNonNull(T... elements) {
-		for (int index = 0; index < elements.length; index++)
-			if (elements[index] != null)
-				return elements[index];
-		return null;
-	}
-
-	/**
-	 * Asserts that the contained set of records is fuzzy equal to the set of records of the given {@link TestPairs}.<br>
-	 * Pairs from this and the given set with equal key are compared and matched using the provided
-	 * {@link FuzzyTestValueMatcher} and its {@link FuzzyTestValueSimilarity} measure.
-	 * 
-	 * @param expectedValues
-	 *        the other TestPairs defining the expected result
-	 * @param fuzzyMatcher
-	 *        the fuzzy match algorithm used to globally match the values of records with equal key
-	 * @param fuzzySimilarity
-	 *        the fuzzy similarity measure used by the matcher or null if supported by the fuzzyMatcher
-	 * @throws ArrayComparisonFailure
-	 *         if the sets differ
-	 */
-	public void assertEquals(final TestRecords expectedValues, FuzzyValueMatcher fuzzyMatcher,
-			Int2ObjectMap<List<ValueSimilarity<?>>> similarityMap) throws ArrayComparisonFailure {
-		@SuppressWarnings("unchecked")
-		Class<? extends Value>[] schema = firstNonNull(expectedValues.schema, this.schema);
-		new TestRecordsAssertor(schema, fuzzyMatcher, this.canonalizeSimilarityMap(similarityMap, schema),
-			firstNonNull(expectedValues.sortInfo, this.sortInfo), expectedValues, this).assertEquals();
-	}
-
-	/**
-	 * Removes all values column and adds similarities where applicable
-	 */
-	@SuppressWarnings({ "unchecked", "rawtypes" })
-	private Int2ObjectMap<List<ValueSimilarity<?>>> canonalizeSimilarityMap(
-			Int2ObjectMap<List<ValueSimilarity<?>>> similarityMap, Class<? extends Value>[] schema) {
-		if (similarityMap.containsKey(ALL_VALUES) && !similarityMap.get(ALL_VALUES).isEmpty()) {
-			// add all similarities to individual lists instead
-			similarityMap = new Int2ObjectOpenHashMap<List<ValueSimilarity<?>>>(similarityMap);
-			List<ValueSimilarity<?>> allSimilarity = similarityMap.remove(ALL_VALUES);
-			for (int index = 0; index < schema.length; index++) {
-				List<ValueSimilarity<?>> similarities = similarityMap.get(index);
-				if (similarities == null)
-					similarityMap.put(index, similarities = new ArrayList<ValueSimilarity<?>>());
-				for (ValueSimilarity sim : allSimilarity)
-					if (sim.isApplicable(schema[index]))
-						similarities.add(sim);
-			}
-		}
-
-		// remove empty lists
-		ObjectIterator<Entry<List<ValueSimilarity<?>>>> iterator = similarityMap.int2ObjectEntrySet().iterator();
-		while (iterator.hasNext()) {
-			Int2ObjectMap.Entry<List<ValueSimilarity<?>>> entry = iterator.next();
-			if (entry.getValue().isEmpty())
-				iterator.remove();
-		}
-		return similarityMap;
-	}
-
-	public final static int ALL_VALUES = -1;
-
-	/*
-	 * (non-Javadoc)
-	 * @see java.lang.Object#equals(java.lang.Object)
-	 */
-	@Override
-	public boolean equals(final Object obj) {
-		if (this == obj)
-			return true;
-		if (obj == null)
-			return false;
-		if (this.getClass() != obj.getClass())
-			return false;
-		final TestRecords other = (TestRecords) obj;
-
-		try {
-			other.assertEquals(this);
-		} catch (AssertionError e) {
-			return false;
-		}
-		return true;
-	}
-
-	/**
-	 * Initializes this {@link TestPairs} from the given file.
-	 * 
-	 * @param inputFormatClass
-	 *        the class of the {@link FileInputFormat}
-	 * @param file
-	 *        the path to the file, can be relative
-	 * @return this
-	 */
-	public TestRecords fromFile(final Class<? extends FileInputFormat> inputFormatClass, final String file) {
-		this.fromFile(inputFormatClass, file, new Configuration());
-		return this;
-	}
-
-	/**
-	 * Initializes this {@link TestPairs} from the given file.
-	 * 
-	 * @param inputFormatClass
-	 *        the class of the {@link FileInputFormat}
-	 * @param file
-	 *        the path to the file, can be relative
-	 * @param configuration
-	 *        the configuration for the {@link FileInputFormat}.
-	 * @return this
-	 */
-	public TestRecords fromFile(final Class<? extends FileInputFormat> inputFormatClass, final String file,
-			final Configuration configuration) {
-		this.path = file;
-		this.inputFormatClass = inputFormatClass;
-		this.configuration = configuration;
-		this.setEmpty(false);
-		this.records.clear();
-		return this;
-	}
-
-	/*
-	 * (non-Javadoc)
-	 * @see java.lang.Object#hashCode()
-	 */
-	@Override
-	public int hashCode() {
-		final int prime = 31;
-		int result = 1;
-		final Iterator<PactRecord> iterator = this.iterator();
-		while (iterator.hasNext())
-			result = prime * result + iterator.next().hashCode();
-		return result;
-	}
-
-	/**
-	 * Returns true if any add method has been called at least one.
-	 * 
-	 * @return true if records were specified in an ad-hoc manner
-	 */
-	public boolean isAdhoc() {
-		return !this.records.isEmpty();
-	}
-
-	/**
-	 * Returns true if either records were added manually or with {@link #fromFile(Class, String, Configuration)}.
-	 * 
-	 * @return true if either records were added manually or with {@link #fromFile(Class, String, Configuration)}.
-	 */
-	public boolean isInitialized() {
-		return this.isEmpty() || !this.records.isEmpty() || this.inputFormatClass != null;
-	}
-
-	/**
-	 * Sets the schema to the specified value.
-	 * 
-	 * @param schema
-	 *        the schema to set
-	 */
-	public void setSchema(Class<? extends Value> firstFieldType, Class<?>... otherFieldTypes) {
-		this.schema = SchemaUtils.combineSchema(firstFieldType, otherFieldTypes);
-		this.sortInfo = this.inferInfo();
-	}
-
-	public Class<? extends Value>[] getSchema() {
-		return this.schema;
-	}
-
-	public void setSchema(Class<? extends Value>[] schema) {
-		if (schema == null)
-			throw new NullPointerException("schema must not be null");
-
-		this.schema = schema;
-		this.sortInfo = this.inferInfo();
-	}
-
-	@Override
-	public Iterator<PactRecord> iterator() {
-		return this.iterator(this.sortInfo);
-	}
-
-	public Iterator<PactRecord> iterator(final SortInfo info) {
-		if (this.isEmpty())
-			return EMPTY_ITERATOR;
-
-		if (!this.isAdhoc() && this.inputFormatClass != null) {
-
-			final InputFileIterator inputFileIterator = this.getInputFileIterator();
-
-			if (!inputFileIterator.hasNext() || info == null)
-				return inputFileIterator;
-
-			return this.createSortedIterator(inputFileIterator, info);
-		}
-
-		if (info != null)
-			Collections.sort(this.records, new Comparator<PactRecord>() {
-				@Override
-				public int compare(PactRecord o1, PactRecord o2) {
-					for (int index = 0; index < info.keyClasses.size(); index++) {
-						Key f1 = o1.getField(info.sortKeys.get(index), info.keyClasses.get(index));
-						Key f2 = o2.getField(info.sortKeys.get(index), info.keyClasses.get(index));
-						if (f1 == f2)
-							continue;
-						if (f1 == null)
-							return -1;
-						if (f2 == null)
-							return 1;
-						int comparison = info.comparators.get(index).compare(f1, f2);
-						if (comparison != 0)
-							return comparison;
-					}
-
-					return 0;
-				}
-			});
-		return this.records.iterator();
-	}
-
-	protected InputFileIterator getInputFileIterator() {
-		final InputFileIterator inputFileIterator;
-		try {
-			inputFileIterator = new InputFileIterator(FormatUtil.openAllInputs(this.inputFormatClass, this.path,
-				this.configuration));
-		} catch (final IOException e) {
-			Assert.fail("reading values from " + this.path + ": " + StringUtils.stringifyException(e));
-			return null;
-		} catch (final Exception e) {
-			Assert.fail("creating input format " + StringUtils.stringifyException(e));
-			return null;
-		}
-		return inputFileIterator;
-	}
-
-	protected Iterator<PactRecord> getUnsortedIterator() {
-		if (this.isEmpty())
-			return EMPTY_ITERATOR;
-		if (this.isAdhoc())
-			return this.records.iterator();
-		if (this.inputFormatClass != null)
-			return this.getInputFileIterator();
-		return EMPTY_ITERATOR;
-	}
-
-	/**
-	 * Saves the data to the given path in an internal format.
-	 * 
-	 * @param path
-	 *        the path to write to, may be relative
-	 * @throws IOException
-	 *         if an I/O error occurred
-	 */
-	public void saveToFile(final String path) throws IOException {
-		final SequentialOutputFormat outputFormat = FormatUtil.openOutput(SequentialOutputFormat.class, path,
-			null);
-
-		final Iterator<PactRecord> iterator = this.iterator();
-		while (iterator.hasNext())
-			outputFormat.writeRecord(iterator.next());
-		outputFormat.close();
-	}
-
-	@Override
-	public String toString() {
-		final StringBuilder stringBuilder = new StringBuilder("TestPairs: ");
-		final Iterator<PactRecord> iterator = this.iterator(null);
-		for (int index = 0; index < 10 && iterator.hasNext(); index++) {
-			if (index > 0)
-				stringBuilder.append("; ");
-			if (this.schema.length > 0)
-				stringBuilder.append(PactRecordUtil.stringify(iterator.next(), this.schema));
-			else
-				stringBuilder.append(iterator.next());
-		}
-		if (iterator.hasNext())
-			stringBuilder.append("...");
-		return stringBuilder.toString();
-	}
-
-	private static final int DEFAUTL_MERGE_FACTOR = 64; // the number of streams to merge at once
-}
\ No newline at end of file
diff --git a/pact/pact-clients/src/main/java/eu/stratosphere/pact/testing/TestRecordsAssertor.java b/pact/pact-clients/src/main/java/eu/stratosphere/pact/testing/TestRecordsAssertor.java
deleted file mode 100644
index 3ab80d5..0000000
--- a/pact/pact-clients/src/main/java/eu/stratosphere/pact/testing/TestRecordsAssertor.java
+++ /dev/null
@@ -1,177 +0,0 @@
-/***********************************************************************************************************************
- *
- * Copyright (C) 2010 by the Stratosphere project (http://stratosphere.eu)
- *
- * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with
- * the License. You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on
- * an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
- * specific language governing permissions and limitations under the License.
- *
- **********************************************************************************************************************/
-package eu.stratosphere.pact.testing;
-
-import static eu.stratosphere.pact.testing.PactRecordUtil.stringify;
-import it.unimi.dsi.fastutil.ints.Int2ObjectMap;
-import it.unimi.dsi.fastutil.ints.Int2ObjectMap.Entry;
-
-import java.util.ArrayList;
-import java.util.Arrays;
-import java.util.Iterator;
-import java.util.List;
-
-import junit.framework.Assert;
-import junit.framework.AssertionFailedError;
-
-import org.junit.internal.ArrayComparisonFailure;
-
-import eu.stratosphere.pact.common.type.Key;
-import eu.stratosphere.pact.common.type.PactRecord;
-import eu.stratosphere.pact.common.type.Value;
-import eu.stratosphere.pact.testing.TestRecords.SortInfo;
-
-/**
- * Utility class that is used from {@link TestRecords#assertEquals(TestRecords)}.<br>
- * It tries to align all matching records by successively eliminating matching records from the multiset of expected and
- * actual values.<br>
- * To reduce memory consumption, only tuples with the same key are held within memory. The key is simply determined by
- * using all parts of the schema that implement {@link Key} and that are not matched fuzzily.
- * 
- * @author Arvid Heise
- */
-class TestRecordsAssertor {
-	private Class<? extends Value>[] schema;
-
-	private FuzzyValueMatcher fuzzyMatcher;
-
-	private Int2ObjectMap<List<ValueSimilarity<?>>> similarityMap;
-
-	private SortInfo sortInfo;
-
-	private TestRecords expectedValues, actualRecords;
-
-	private Iterator<PactRecord> actualIterator;
-
-	private Iterator<PactRecord> expectedIterator;
-
-	public TestRecordsAssertor(Class<? extends Value>[] schema, FuzzyValueMatcher fuzzyMatcher,
-			Int2ObjectMap<List<ValueSimilarity<?>>> similarityMap, SortInfo sortInfo, TestRecords expectedValues,
-			TestRecords actualRecords) {
-		this.schema = schema;
-		this.fuzzyMatcher = fuzzyMatcher;
-		this.similarityMap = similarityMap;
-		this.sortInfo = this.getSortInfoForAssertion(similarityMap,
-			TestRecords.firstNonNull(expectedValues.sortInfo, this.sortInfo));
-		if (sortInfo == null)
-			throw new IllegalStateException("Expected value does not have schema specified");
-		this.expectedValues = expectedValues;
-		this.actualRecords = actualRecords;
-		this.actualIterator = actualRecords.iterator(sortInfo);
-		this.expectedIterator = expectedValues.iterator(sortInfo);
-	}
-
-	public void assertEquals() {
-		try {
-			// initialize with null
-			List<Key> currentKeys = new ArrayList<Key>(Arrays.asList(new Key[this.sortInfo.sortKeys.size()])), nextKeys =
-				new ArrayList<Key>(currentKeys);
-			int itemIndex = 0;
-			List<PactRecord> expectedValuesWithCurrentKey = new ArrayList<PactRecord>();
-			List<PactRecord> actualValuesWithCurrentKey = new ArrayList<PactRecord>();
-			if (this.expectedIterator.hasNext()) {
-				PactRecord expected = this.expectedIterator.next();
-				this.setKeys(currentKeys, expected);
-				expectedValuesWithCurrentKey.add(expected);
-
-				// take chunks of expected values with the same keys and match them
-				while (this.actualIterator.hasNext() && this.expectedIterator.hasNext()) {
-					expected = this.expectedIterator.next().createCopy();
-					this.setKeys(nextKeys, expected);
-					if (!currentKeys.equals(nextKeys)) {
-						this.matchValues(currentKeys, itemIndex, expectedValuesWithCurrentKey,
-							actualValuesWithCurrentKey);
-						this.setKeys(currentKeys, expected);
-					}
-					expectedValuesWithCurrentKey.add(expected);
-
-					itemIndex++;
-				}
-
-				// remaining values
-				if (!expectedValuesWithCurrentKey.isEmpty())
-					this.matchValues(currentKeys, itemIndex, expectedValuesWithCurrentKey, actualValuesWithCurrentKey);
-			}
-
-			if (!expectedValuesWithCurrentKey.isEmpty() || this.expectedIterator.hasNext())
-				Assert.fail("More elements expected: " + expectedValuesWithCurrentKey
-					+ stringify(this.expectedIterator, this.schema));
-			if (!actualValuesWithCurrentKey.isEmpty() || this.actualIterator.hasNext())
-				Assert.fail("Less elements expected: " + actualValuesWithCurrentKey
-					+ stringify(this.actualIterator, this.schema));
-		} finally {
-			this.actualRecords.close();
-			this.expectedValues.close();
-		}
-	}
-
-	private void matchValues(List<Key> currentKeys, int itemIndex, List<PactRecord> expectedValuesWithCurrentKey,
-			List<PactRecord> actualValuesWithCurrentKey) throws ArrayComparisonFailure {
-
-		List<Key> actualKeys = new ArrayList<Key>(currentKeys);
-
-		// collect all actual values with the same key
-		PactRecord actualRecord = null;
-		while (this.actualIterator.hasNext()) {
-			actualRecord = this.actualIterator.next();
-			this.setKeys(actualKeys, actualRecord);
-
-			if (!currentKeys.equals(actualKeys))
-				break;
-			actualValuesWithCurrentKey.add(actualRecord);
-			actualRecord = null;
-		}
-
-		if (actualValuesWithCurrentKey.isEmpty())
-			throw new ArrayComparisonFailure("Unexpected value for key " + currentKeys, new AssertionFailedError(
-				Assert.format(" ", stringify(expectedValuesWithCurrentKey.iterator(), this.schema), stringify(
-					actualRecord, this.schema))), itemIndex + expectedValuesWithCurrentKey.size() - 1);
-
-		// and invoke the fuzzy matcher
-		this.fuzzyMatcher.removeMatchingValues(this.similarityMap, this.schema, expectedValuesWithCurrentKey,
-			actualValuesWithCurrentKey);
-
-		if (!expectedValuesWithCurrentKey.isEmpty() || !actualValuesWithCurrentKey.isEmpty())
-			throw new ArrayComparisonFailure("Unexpected values for key " + currentKeys + ": ",
-				new AssertionFailedError(Assert.format(" ", stringify(expectedValuesWithCurrentKey.iterator(),
-					this.schema), stringify(actualValuesWithCurrentKey.iterator(), this.schema))),
-				itemIndex - expectedValuesWithCurrentKey.size());
-
-		// don't forget the first record that has a different key
-		if (actualRecord != null)
-			actualValuesWithCurrentKey.add(actualRecord);
-	}
-
-	protected SortInfo getSortInfoForAssertion(Int2ObjectMap<List<ValueSimilarity<?>>> similarityMap, SortInfo sortInfo) {
-		if (similarityMap.isEmpty())
-			return sortInfo;
-		sortInfo = sortInfo.copy();
-		// remove all keys that have a fuzzy similarity measure
-		for (Entry<List<ValueSimilarity<?>>> similarityEntry : similarityMap.int2ObjectEntrySet())
-			if (similarityEntry.getIntKey() != TestRecords.ALL_VALUES && !similarityEntry.getValue().isEmpty())
-				sortInfo.remove(similarityEntry.getIntKey());
-		return sortInfo;
-	}
-
-	private void setKeys(List<Key> keyList, PactRecord record) {
-		for (int index = 0; index < this.sortInfo.sortKeys.size(); index++) {
-			final int fieldIndex = this.sortInfo.sortKeys.getInt(index);
-			if (record.getNumFields() <= fieldIndex)
-				Assert.fail("Record has less fields then the expected values suggested: "
-					+ stringify(record, this.schema));
-			keyList.set(index, record.getField(fieldIndex, this.sortInfo.keyClasses.get(index)));
-		}
-	}
-}
\ No newline at end of file
diff --git a/pact/pact-clients/src/main/java/eu/stratosphere/pact/testing/ValueSimilarity.java b/pact/pact-clients/src/main/java/eu/stratosphere/pact/testing/ValueSimilarity.java
deleted file mode 100644
index 36612d6..0000000
--- a/pact/pact-clients/src/main/java/eu/stratosphere/pact/testing/ValueSimilarity.java
+++ /dev/null
@@ -1,45 +0,0 @@
-/***********************************************************************************************************************
- *
- * Copyright (C) 2010 by the Stratosphere project (http://stratosphere.eu)
- *
- * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with
- * the License. You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on
- * an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
- * specific language governing permissions and limitations under the License.
- *
- **********************************************************************************************************************/
-
-package eu.stratosphere.pact.testing;
-
-import eu.stratosphere.pact.common.type.Value;
-
-/**
- * Distance function between two values.
- * 
- * @author Arvid Heise
- * @param <V>
- *        the value type
- */
-public interface ValueSimilarity<V extends Value> {
-	/**
-	 * Constant used to indicate that two values do not match.
-	 */
-	public static double NO_MATCH = -1;
-
-	/**
-	 * Returns the distance between the first and the second value or {@link #NO_MATCH}.
-	 * 
-	 * @param value1
-	 *        the first value
-	 * @param value2
-	 *        the second value
-	 * @return a positive value corresponding to the distance or {@link #NO_MATCH}
-	 */
-	public double getDistance(V value1, V value2);
-
-	public boolean isApplicable(Class<? extends V> valueType);
-}
\ No newline at end of file
diff --git a/pact/pact-clients/src/test/java/eu/stratosphere/pact/client/LocalExecutorTest.java b/pact/pact-clients/src/test/java/eu/stratosphere/pact/client/LocalExecutorTest.java
new file mode 100644
index 0000000..c0879e6
--- /dev/null
+++ b/pact/pact-clients/src/test/java/eu/stratosphere/pact/client/LocalExecutorTest.java
@@ -0,0 +1,122 @@
+/***********************************************************************************************************************
+ *
+ * Copyright (C) 2012 by the Stratosphere project (http://stratosphere.eu)
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on
+ * an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
+ * specific language governing permissions and limitations under the License.
+ *
+ **********************************************************************************************************************/
+package eu.stratosphere.pact.client;
+
+import java.io.File;
+import java.io.FileWriter;
+
+import org.junit.Assert;
+import org.junit.Test;
+
+import eu.stratosphere.pact.example.wordcount.WordCount;
+
+
+public class LocalExecutorTest {
+
+	@Test
+	public void testLocalExecutorWithWordCount() {
+		try {
+			// set up the files
+			File inFile = File.createTempFile("wctext", ".in");
+			File outFile = File.createTempFile("wctext", ".out");
+			inFile.deleteOnExit();
+			outFile.deleteOnExit();
+			
+			FileWriter fw = new FileWriter(inFile);
+			fw.write(TEXT);
+			fw.close();
+			
+			// run WordCount
+			WordCount wc = new WordCount();
+			LocalExecutor.execute(wc, "4", "file://" + inFile.getAbsolutePath(), "file://" + outFile.getAbsolutePath());
+		} catch (Exception e) {
+			e.printStackTrace();
+			Assert.fail(e.getMessage());
+		}
+		
+	}
+	
+	private static final String TEXT = "Goethe - Faust: Der Tragoedie erster Teil\n" + "Prolog im Himmel.\n"
+			+ "Der Herr. Die himmlischen Heerscharen. Nachher Mephistopheles. Die drei\n" + "Erzengel treten vor.\n"
+			+ "RAPHAEL: Die Sonne toent, nach alter Weise, In Brudersphaeren Wettgesang,\n"
+			+ "Und ihre vorgeschriebne Reise Vollendet sie mit Donnergang. Ihr Anblick\n"
+			+ "gibt den Engeln Staerke, Wenn keiner Sie ergruenden mag; die unbegreiflich\n"
+			+ "hohen Werke Sind herrlich wie am ersten Tag.\n"
+			+ "GABRIEL: Und schnell und unbegreiflich schnelle Dreht sich umher der Erde\n"
+			+ "Pracht; Es wechselt Paradieseshelle Mit tiefer, schauervoller Nacht. Es\n"
+			+ "schaeumt das Meer in breiten Fluessen Am tiefen Grund der Felsen auf, Und\n"
+			+ "Fels und Meer wird fortgerissen Im ewig schnellem Sphaerenlauf.\n"
+			+ "MICHAEL: Und Stuerme brausen um die Wette Vom Meer aufs Land, vom Land\n"
+			+ "aufs Meer, und bilden wuetend eine Kette Der tiefsten Wirkung rings umher.\n"
+			+ "Da flammt ein blitzendes Verheeren Dem Pfade vor des Donnerschlags. Doch\n"
+			+ "deine Boten, Herr, verehren Das sanfte Wandeln deines Tags.\n"
+			+ "ZU DREI: Der Anblick gibt den Engeln Staerke, Da keiner dich ergruenden\n"
+			+ "mag, Und alle deine hohen Werke Sind herrlich wie am ersten Tag.\n"
+			+ "MEPHISTOPHELES: Da du, o Herr, dich einmal wieder nahst Und fragst, wie\n"
+			+ "alles sich bei uns befinde, Und du mich sonst gewoehnlich gerne sahst, So\n"
+			+ "siehst du mich auch unter dem Gesinde. Verzeih, ich kann nicht hohe Worte\n"
+			+ "machen, Und wenn mich auch der ganze Kreis verhoehnt; Mein Pathos braechte\n"
+			+ "dich gewiss zum Lachen, Haettst du dir nicht das Lachen abgewoehnt. Von\n"
+			+ "Sonn' und Welten weiss ich nichts zu sagen, Ich sehe nur, wie sich die\n"
+			+ "Menschen plagen. Der kleine Gott der Welt bleibt stets von gleichem\n"
+			+ "Schlag, Und ist so wunderlich als wie am ersten Tag. Ein wenig besser\n"
+			+ "wuerd er leben, Haettst du ihm nicht den Schein des Himmelslichts gegeben;\n"
+			+ "Er nennt's Vernunft und braucht's allein, Nur tierischer als jedes Tier\n"
+			+ "zu sein. Er scheint mir, mit Verlaub von euer Gnaden, Wie eine der\n"
+			+ "langbeinigen Zikaden, Die immer fliegt und fliegend springt Und gleich im\n"
+			+ "Gras ihr altes Liedchen singt; Und laeg er nur noch immer in dem Grase! In\n"
+			+ "jeden Quark begraebt er seine Nase.\n"
+			+ "DER HERR: Hast du mir weiter nichts zu sagen? Kommst du nur immer\n"
+			+ "anzuklagen? Ist auf der Erde ewig dir nichts recht?\n"
+			+ "MEPHISTOPHELES: Nein Herr! ich find es dort, wie immer, herzlich\n"
+			+ "schlecht. Die Menschen dauern mich in ihren Jammertagen, Ich mag sogar\n"
+			+ "die armen selbst nicht plagen.\n" + "DER HERR: Kennst du den Faust?\n" + "MEPHISTOPHELES: Den Doktor?\n"
+			+ "DER HERR: Meinen Knecht!\n"
+			+ "MEPHISTOPHELES: Fuerwahr! er dient Euch auf besondre Weise. Nicht irdisch\n"
+			+ "ist des Toren Trank noch Speise. Ihn treibt die Gaerung in die Ferne, Er\n"
+			+ "ist sich seiner Tollheit halb bewusst; Vom Himmel fordert er die schoensten\n"
+			+ "Sterne Und von der Erde jede hoechste Lust, Und alle Naeh und alle Ferne\n"
+			+ "Befriedigt nicht die tiefbewegte Brust.\n"
+			+ "DER HERR: Wenn er mir auch nur verworren dient, So werd ich ihn bald in\n"
+			+ "die Klarheit fuehren. Weiss doch der Gaertner, wenn das Baeumchen gruent, Das\n"
+			+ "Bluet und Frucht die kuenft'gen Jahre zieren.\n"
+			+ "MEPHISTOPHELES: Was wettet Ihr? den sollt Ihr noch verlieren! Wenn Ihr\n"
+			+ "mir die Erlaubnis gebt, Ihn meine Strasse sacht zu fuehren.\n"
+			+ "DER HERR: Solang er auf der Erde lebt, So lange sei dir's nicht verboten,\n"
+			+ "Es irrt der Mensch so lang er strebt.\n"
+			+ "MEPHISTOPHELES: Da dank ich Euch; denn mit den Toten Hab ich mich niemals\n"
+			+ "gern befangen. Am meisten lieb ich mir die vollen, frischen Wangen. Fuer\n"
+			+ "einem Leichnam bin ich nicht zu Haus; Mir geht es wie der Katze mit der Maus.\n"
+			+ "DER HERR: Nun gut, es sei dir ueberlassen! Zieh diesen Geist von seinem\n"
+			+ "Urquell ab, Und fuehr ihn, kannst du ihn erfassen, Auf deinem Wege mit\n"
+			+ "herab, Und steh beschaemt, wenn du bekennen musst: Ein guter Mensch, in\n"
+			+ "seinem dunklen Drange, Ist sich des rechten Weges wohl bewusst.\n"
+			+ "MEPHISTOPHELES: Schon gut! nur dauert es nicht lange. Mir ist fuer meine\n"
+			+ "Wette gar nicht bange. Wenn ich zu meinem Zweck gelange, Erlaubt Ihr mir\n"
+			+ "Triumph aus voller Brust. Staub soll er fressen, und mit Lust, Wie meine\n"
+			+ "Muhme, die beruehmte Schlange.\n"
+			+ "DER HERR: Du darfst auch da nur frei erscheinen; Ich habe deinesgleichen\n"
+			+ "nie gehasst. Von allen Geistern, die verneinen, ist mir der Schalk am\n"
+			+ "wenigsten zur Last. Des Menschen Taetigkeit kann allzu leicht erschlaffen,\n"
+			+ "er liebt sich bald die unbedingte Ruh; Drum geb ich gern ihm den Gesellen\n"
+			+ "zu, Der reizt und wirkt und muss als Teufel schaffen. Doch ihr, die echten\n"
+			+ "Goettersoehne, Erfreut euch der lebendig reichen Schoene! Das Werdende, das\n"
+			+ "ewig wirkt und lebt, Umfass euch mit der Liebe holden Schranken, Und was\n"
+			+ "in schwankender Erscheinung schwebt, Befestigt mit dauernden Gedanken!\n"
+			+ "(Der Himmel schliesst, die Erzengel verteilen sich.)\n"
+			+ "MEPHISTOPHELES (allein): Von Zeit zu Zeit seh ich den Alten gern, Und\n"
+			+ "huete mich, mit ihm zu brechen. Es ist gar huebsch von einem grossen Herrn,\n"
+			+ "So menschlich mit dem Teufel selbst zu sprechen.";
+}
diff --git a/pact/pact-clients/src/test/java/eu/stratosphere/pact/common/plan/ContractUtilTest.java b/pact/pact-clients/src/test/java/eu/stratosphere/pact/common/plan/ContractUtilTest.java
deleted file mode 100644
index 1943928..0000000
--- a/pact/pact-clients/src/test/java/eu/stratosphere/pact/common/plan/ContractUtilTest.java
+++ /dev/null
@@ -1,172 +0,0 @@
-/***********************************************************************************************************************
- *
- * Copyright (C) 2010 by the Stratosphere project (http://stratosphere.eu)
- *
- * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with
- * the License. You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on
- * an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
- * specific language governing permissions and limitations under the License.
- *
- **********************************************************************************************************************/
-
-package eu.stratosphere.pact.common.plan;
-
-import static org.junit.Assert.assertEquals;
-
-import java.util.Iterator;
-
-import org.junit.Test;
-
-import eu.stratosphere.pact.common.contract.CoGroupContract;
-import eu.stratosphere.pact.common.contract.CrossContract;
-import eu.stratosphere.pact.common.contract.FileDataSink;
-import eu.stratosphere.pact.common.contract.FileDataSource;
-import eu.stratosphere.pact.common.contract.MapContract;
-import eu.stratosphere.pact.common.contract.MatchContract;
-import eu.stratosphere.pact.common.contract.ReduceContract;
-import eu.stratosphere.pact.common.io.DelimitedInputFormat;
-import eu.stratosphere.pact.common.io.DelimitedOutputFormat;
-import eu.stratosphere.pact.common.stubs.CoGroupStub;
-import eu.stratosphere.pact.common.stubs.Collector;
-import eu.stratosphere.pact.common.stubs.CrossStub;
-import eu.stratosphere.pact.common.stubs.MapStub;
-import eu.stratosphere.pact.common.stubs.MatchStub;
-import eu.stratosphere.pact.common.stubs.ReduceStub;
-import eu.stratosphere.pact.common.stubs.Stub;
-import eu.stratosphere.pact.common.type.PactRecord;
-
-/**
- * Tests {@link ContractUtil}.
- * 
- * @author Arvid Heise
- */
-public class ContractUtilTest {
-	/**
-	 * Test {@link ContractUtil#getContractClass(Class)}
-	 */
-	@Test
-	public void getContractClassShouldReturnCoGroupForCoGroupStub() {
-		final Class<?> result = ContractUtil.getContractClass(CoGrouper.class);
-		assertEquals(CoGroupContract.class, result);
-	}
-
-	/**
-	 * Test {@link ContractUtil#getContractClass(Class)}
-	 */
-	@Test
-	public void getContractClassShouldReturnCrossForCrossStub() {
-		final Class<?> result = ContractUtil.getContractClass(Crosser.class);
-		assertEquals(CrossContract.class, result);
-	}
-
-	/**
-	 * Test {@link ContractUtil#getContractClass(Class)}
-	 */
-	@Test
-	public void getContractClassShouldReturnMapForMapStub() {
-		final Class<?> result = ContractUtil.getContractClass(Mapper.class);
-		assertEquals(MapContract.class, result);
-	}
-
-	/**
-	 * Test {@link ContractUtil#getContractClass(Class)}
-	 */
-	@Test
-	public void getContractClassShouldReturnMatchForMatchStub() {
-		final Class<?> result = ContractUtil.getContractClass(Matcher.class);
-		assertEquals(MatchContract.class, result);
-	}
-
-	/**
-	 * Test {@link ContractUtil#getContractClass(Class)}
-	 */
-	@Test
-	public void getContractClassShouldReturnNullForStub() {
-		final Class<?> result = ContractUtil.getContractClass(Stub.class);
-		assertEquals(null, result);
-	}
-
-	/**
-	 * Test {@link ContractUtil#getContractClass(Class)}
-	 */
-	@Test
-	public void getContractClassShouldReturnReduceForReduceStub() {
-		final Class<?> result = ContractUtil.getContractClass(Reducer.class);
-		assertEquals(ReduceContract.class, result);
-	}
-
-	/**
-	 * Test {@link ContractUtil#getContractClass(Class)}
-	 */
-	@Test
-	public void getContractClassShouldReturnSinkForOutputFormat() {
-		final Class<?> result = ContractUtil.getContractClass(DelimitedOutputFormat.class);
-		assertEquals(FileDataSink.class, result);
-	}
-
-	/**
-	 * Test {@link ContractUtil#getContractClass(Class)}
-	 */
-	@Test
-	public void getContractClassShouldReturnSourceForInputFormat() {
-		final Class<?> result = ContractUtil.getContractClass(DelimitedInputFormat.class);
-		assertEquals(FileDataSource.class, result);
-	}
-
-	static class CoGrouper extends CoGroupStub {
-		/* (non-Javadoc)
-		 * @see eu.stratosphere.pact.common.stubs.CoGroupStub#coGroup(java.util.Iterator, java.util.Iterator, eu.stratosphere.pact.common.stubs.Collector)
-		 */
-		@Override
-		public void coGroup(Iterator<PactRecord> records1, Iterator<PactRecord> records2, Collector<PactRecord> out) {
-		}
-	}
-
-	static class Crosser extends CrossStub {
-		/*
-		 * (non-Javadoc)
-		 * @see eu.stratosphere.pact.common.stubs.CrossStub#cross(eu.stratosphere.pact.common.type.PactRecord,
-		 * eu.stratosphere.pact.common.type.PactRecord, eu.stratosphere.pact.common.stubs.Collector)
-		 */
-		@Override
-		public void cross(PactRecord record1, PactRecord record2, Collector<PactRecord> out) {
-		}
-	}
-
-	static class Mapper extends MapStub {
-		/*
-		 * (non-Javadoc)
-		 * @see eu.stratosphere.pact.common.stubs.MapStub#map(eu.stratosphere.pact.common.type.PactRecord,
-		 * eu.stratosphere.pact.common.stubs.Collector)
-		 */
-		@Override
-		public void map(PactRecord record, Collector<PactRecord> out) throws Exception {
-		}
-	}
-
-	static class Matcher extends MatchStub {
-		/*
-		 * (non-Javadoc)
-		 * @see eu.stratosphere.pact.common.stubs.MatchStub#match(eu.stratosphere.pact.common.type.PactRecord,
-		 * eu.stratosphere.pact.common.type.PactRecord, eu.stratosphere.pact.common.stubs.Collector)
-		 */
-		@Override
-		public void match(PactRecord value1, PactRecord value2, Collector<PactRecord> out) throws Exception {
-		}
-	}
-
-	static class Reducer extends ReduceStub {
-		/*
-		 * (non-Javadoc)
-		 * @see eu.stratosphere.pact.common.stubs.ReduceStub#reduce(java.util.Iterator,
-		 * eu.stratosphere.pact.common.stubs.Collector)
-		 */
-		@Override
-		public void reduce(Iterator<PactRecord> records, Collector<PactRecord> out) throws Exception {
-		}
-	}
-}
diff --git a/pact/pact-clients/src/test/java/eu/stratosphere/pact/testing/AssertUtilTest.java b/pact/pact-clients/src/test/java/eu/stratosphere/pact/testing/AssertUtilTest.java
deleted file mode 100644
index 5bb210b..0000000
--- a/pact/pact-clients/src/test/java/eu/stratosphere/pact/testing/AssertUtilTest.java
+++ /dev/null
@@ -1,110 +0,0 @@
-/***********************************************************************************************************************
- *
- * Copyright (C) 2010 by the Stratosphere project (http://stratosphere.eu)
- *
- * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with
- * the License. You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on
- * an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
- * specific language governing permissions and limitations under the License.
- *
- **********************************************************************************************************************/
-
-package eu.stratosphere.pact.testing;
-
-import java.util.ArrayList;
-import java.util.Arrays;
-import java.util.List;
-
-import org.junit.Test;
-
-/**
- * Tests {@link AssertUtil}.
- * 
- * @author Arvid Heise
- */
-public class AssertUtilTest {
-	/**
-	 * 
-	 */
-	@Test
-	public void twoEmptyIteratorsShouldBeEquals() {
-		AssertUtil.assertIteratorEquals(Arrays.asList().iterator(), Arrays.asList().iterator(), Equaler.JavaEquals);
-	}
-	
-	/**
-	 * 
-	 */
-	@Test(expected = NullPointerException.class)
-	public void nullAsExpectedIteratorShouldFail() {
-		AssertUtil.assertIteratorEquals(null, Arrays.asList().iterator(), Equaler.JavaEquals);
-	}
-
-	/**
-	 * 
-	 */
-	@Test(expected = NullPointerException.class)
-	public void nullAsActualIteratorShouldFail() {
-		AssertUtil.assertIteratorEquals(Arrays.asList().iterator(), null, Equaler.JavaEquals);
-	}
-
-	/**
-	 * 
-	 */
-	@Test
-	public void twoIteratorsFromSameCollectionShouldBeEquals() {
-		List<String> collection = Arrays.asList("a", "b", "c");
-		AssertUtil.assertIteratorEquals(collection.iterator(), collection.iterator(), Equaler.JavaEquals);
-	}
-
-	/**
-	 * 
-	 */
-	@Test
-	public void twoIteratorsFromEqualCollectionShouldBeEquals() {
-		List<String> collection = Arrays.asList("a", "b", "c");
-		AssertUtil.assertIteratorEquals(collection.iterator(), new ArrayList<String>(collection).iterator(), Equaler.JavaEquals);
-	}
-
-	/**
-	 * 
-	 */
-	@Test(expected = AssertionError.class)
-	public void twoUnequalIteratorsShouldFail() {
-		List<String> collection1 = Arrays.asList("a", "b", "c");
-		List<String> collection2 = Arrays.asList("d", "e", "f");
-		AssertUtil.assertIteratorEquals(collection1.iterator(), collection2.iterator(), Equaler.JavaEquals);
-	}
-
-	/**
-	 * 
-	 */
-	@Test(expected = AssertionError.class)
-	public void emptyAndFilledIteratorShouldFail() {
-		List<String> collection1 = Arrays.asList("a", "b", "c");
-		AssertUtil.assertIteratorEquals(Arrays.asList().iterator(), collection1.iterator(), Equaler.JavaEquals);
-	}
-
-	/**
-	 * 
-	 */
-	@Test(expected = AssertionError.class)
-	public void filledAndEmptyIteratorShouldFail() {
-		List<String> collection1 = Arrays.asList("a", "b", "c");
-		AssertUtil.assertIteratorEquals(collection1.iterator(), Arrays.asList().iterator(), Equaler.JavaEquals);
-	}
-
-	/**
-	 * 
-	 */
-	@Test(expected = AssertionError.class)
-	public void differentOrderShouldFail() {
-		List<String> collection1 = Arrays.asList("a", "b", "c");
-		List<String> collection2 = Arrays.asList("b", "c", "a");
-		AssertUtil.assertIteratorEquals(collection1.iterator(), collection2.iterator(), Equaler.JavaEquals);
-	}
-
-}
diff --git a/pact/pact-clients/src/test/java/eu/stratosphere/pact/testing/FuzzyTestPlanTest.java b/pact/pact-clients/src/test/java/eu/stratosphere/pact/testing/FuzzyTestPlanTest.java
deleted file mode 100644
index aa9deeb..0000000
--- a/pact/pact-clients/src/test/java/eu/stratosphere/pact/testing/FuzzyTestPlanTest.java
+++ /dev/null
@@ -1,107 +0,0 @@
-/***********************************************************************************************************************
- *
- * Copyright (C) 2010 by the Stratosphere project (http://stratosphere.eu)
- *
- * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with
- * the License. You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on
- * an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
- * specific language governing permissions and limitations under the License.
- *
- **********************************************************************************************************************/
-
-package eu.stratosphere.pact.testing;
-
-import org.junit.Test;
-
-import eu.stratosphere.pact.common.contract.MapContract;
-import eu.stratosphere.pact.common.stubs.Collector;
-import eu.stratosphere.pact.common.stubs.MapStub;
-import eu.stratosphere.pact.common.type.PactRecord;
-import eu.stratosphere.pact.common.type.base.PactDouble;
-import eu.stratosphere.pact.common.type.base.PactInteger;
-
-/**
- * Tests the fuzzy matching function of {@link TestPlan}.
- * 
- * @author Arvid Heise
- */
-public class FuzzyTestPlanTest {
-	/**
-	 * Truncates a double after the first two decimal places.
-	 * 
-	 * @author Arvid Heise
-	 */
-	public static class DoubleTruncatingMap extends MapStub {
-		/*
-		 * (non-Javadoc)
-		 * @see eu.stratosphere.pact.common.stubs.MapStub#map(eu.stratosphere.pact.common.type.PactRecord,
-		 * eu.stratosphere.pact.common.stubs.Collector)
-		 */
-		@Override
-		public void map(PactRecord record, Collector<PactRecord> out) throws Exception {
-			PactDouble value = record.getField(1, PactDouble.class);
-			value.setValue((int) (value.getValue() * 100) / 100d);
-			out.collect(record);
-		}
-	};
-
-	/**
-	 * As no delta is set, this test plan should fail with truncation.
-	 */
-	@Test
-	public void shouldFailInaccurateDoublesWithoutDelta() {
-		final MapContract map = MapContract.builder(DoubleTruncatingMap.class)
-			.name("Map")
-			.build();
-		TestPlan testPlan = new TestPlan(map);
-		testPlan.getInput().
-			add(new PactInteger(1), new PactDouble(1.2345)).
-			add(new PactInteger(2), new PactDouble(2.3456));
-		testPlan.getExpectedOutput(PactInteger.class, PactDouble.class).
-			add(new PactInteger(1), new PactDouble(1.2349)).
-			add(new PactInteger(2), new PactDouble(2.3459));
-		TestPlanTest.assertTestRunFails(testPlan);
-	}
-
-	/**
-	 * With set delta, this test plan should not fail despite the truncation.
-	 */
-	@Test
-	public void shouldMatchInaccurateDoublesWithDelta() {
-		final MapContract map = MapContract.builder(DoubleTruncatingMap.class)
-			.name("Map")
-			.build();
-		TestPlan testPlan = new TestPlan(map);
-		testPlan.setAllowedPactDoubleDelta(0.01);
-		testPlan.getInput().
-			add(new PactInteger(1), new PactDouble(1.2345)).
-			add(new PactInteger(2), new PactDouble(2.3456));
-		testPlan.getExpectedOutput(PactInteger.class, PactDouble.class).
-			add(new PactInteger(1), new PactDouble(1.2349)).
-			add(new PactInteger(2), new PactDouble(2.3459));
-		testPlan.run();
-	}
-
-	/**
-	 * With set delta, this test plan should not fail despite the truncation.
-	 */
-	@Test
-	public void shouldMatchInaccurateDoublesWithDeltaAndSameKey() {
-		final MapContract map = MapContract.builder(DoubleTruncatingMap.class)
-			.name("Map")
-			.build();
-		TestPlan testPlan = new TestPlan(map);
-		testPlan.setAllowedPactDoubleDelta(0.01);
-		testPlan.getInput().
-			add(new PactInteger(1), new PactDouble(1.2345)).
-			add(new PactInteger(1), new PactDouble(2.3456));
-		testPlan.getExpectedOutput(PactInteger.class, PactDouble.class).
-			add(new PactInteger(1), new PactDouble(1.2349)).
-			add(new PactInteger(1), new PactDouble(2.3459));
-		testPlan.run();
-	}
-}
diff --git a/pact/pact-clients/src/test/java/eu/stratosphere/pact/testing/IdentityMap.java b/pact/pact-clients/src/test/java/eu/stratosphere/pact/testing/IdentityMap.java
deleted file mode 100644
index 33f2bfa..0000000
--- a/pact/pact-clients/src/test/java/eu/stratosphere/pact/testing/IdentityMap.java
+++ /dev/null
@@ -1,31 +0,0 @@
-/***********************************************************************************************************************
- *
- * Copyright (C) 2010 by the Stratosphere project (http://stratosphere.eu)
- *
- * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with
- * the License. You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on
- * an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
- * specific language governing permissions and limitations under the License.
- *
- **********************************************************************************************************************/
-
-package eu.stratosphere.pact.testing;
-
-import eu.stratosphere.pact.common.stubs.Collector;
-import eu.stratosphere.pact.common.stubs.MapStub;
-import eu.stratosphere.pact.common.type.PactRecord;
-
-public final class IdentityMap extends MapStub
-{
-	/* (non-Javadoc)
-	 * @see eu.stratosphere.pact.common.stubs.MapStub#map(eu.stratosphere.pact.common.type.PactRecord, eu.stratosphere.pact.common.stubs.Collector)
-	 */
-	@Override
-	public void map(PactRecord record, Collector<PactRecord> out) throws Exception {
-		out.collect(record);
-	}
-}
diff --git a/pact/pact-clients/src/test/java/eu/stratosphere/pact/testing/InputFileIteratorTest.java b/pact/pact-clients/src/test/java/eu/stratosphere/pact/testing/InputFileIteratorTest.java
deleted file mode 100644
index 03d32f6..0000000
--- a/pact/pact-clients/src/test/java/eu/stratosphere/pact/testing/InputFileIteratorTest.java
+++ /dev/null
@@ -1,144 +0,0 @@
-/***********************************************************************************************************************
- *
- * Copyright (C) 2010 by the Stratosphere project (http://stratosphere.eu)
- *
- * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with
- * the License. You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on
- * an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
- * specific language governing permissions and limitations under the License.
- *
- **********************************************************************************************************************/
-
-package eu.stratosphere.pact.testing;
-
-import java.io.IOException;
-import java.util.ArrayList;
-import java.util.Arrays;
-import java.util.NoSuchElementException;
-
-import org.junit.Assert;
-import org.junit.Test;
-
-import eu.stratosphere.pact.common.io.FormatUtil;
-import eu.stratosphere.pact.common.io.SequentialInputFormat;
-import eu.stratosphere.pact.common.io.SequentialOutputFormat;
-import eu.stratosphere.pact.common.type.PactRecord;
-import eu.stratosphere.pact.common.type.base.PactInteger;
-import eu.stratosphere.pact.common.type.base.PactString;
-
-/**
- * Tests {@link InputFileIterator}.
- * 
- * @author Arvid Heise
- */
-public class InputFileIteratorTest {
-	/**
-	 * Tests if a file iterator of an empty file returns any pairs at all.
-	 * 
-	 * @throws IOException
-	 *         if an I/O exception occurred
-	 */
-	@Test
-	public void emptyIteratorShouldReturnNoElements() throws IOException {
-		InputFileIterator inputFileIterator = createFileIterator();
-
-		AssertUtil.assertIteratorEquals("input file iterator is not empty", Arrays.asList().iterator(),
-			inputFileIterator, Equaler.JavaEquals);
-	}
-
-	/**
-	 * Tests if a file iterator of an empty file returns any pairs at all.
-	 * 
-	 * @throws IOException
-	 *         if an I/O exception occurred
-	 */
-	@Test
-	public void filledIteratorShouldReturnExactlyTheGivenArguments() throws IOException {
-		PactRecord[] pairs = { new PactRecord(new PactInteger(1), new PactString("test1")),
-			new PactRecord(new PactInteger(2), new PactString("test2")) };
-		InputFileIterator inputFileIterator = createFileIterator(pairs);
-
-		AssertUtil.assertIteratorEquals("input file iterator does not return the right sequence of pairs", Arrays
-			.asList(pairs).iterator(), inputFileIterator, new PactRecordEqualer(PactInteger.class, PactString.class));
-	}
-
-	/**
-	 * Tests if a file iterator of an empty file returns any pairs at all.
-	 * 
-	 * @throws IOException
-	 *         if an I/O exception occurred
-	 */
-	@Test
-	public void filledIteratorShouldReturnExactlyTheGivenArguments2() throws IOException {
-		PactRecord[] pairs = { 
-			new PactRecord(new PactInteger(1), new PactString("test1")),
-			new PactRecord(new PactInteger(2), new PactString("test2")),
-			new PactRecord(new PactInteger(3), new PactString("test3")),
-			new PactRecord(new PactInteger(4), new PactString("test4")),
-			new PactRecord(new PactInteger(5), new PactString("test5")),
-			new PactRecord(new PactInteger(6), new PactString("test6")) };
-		InputFileIterator inputFileIterator = createFileIterator(pairs);
-
-		AssertUtil.assertIteratorEquals("input file iterator does not return the right sequence of pairs", Arrays
-			.asList(pairs).iterator(), inputFileIterator, new PactRecordEqualer(PactInteger.class, PactString.class));
-	}
-
-	/**
-	 * Tests if a file iterator of a non-existent file fails.
-	 * 
-	 * @throws IOException
-	 *         if an I/O exception occurred
-	 */
-	@Test
-	public void emptyIteratorIfInputFileDoesNotExists() throws IOException {
-		String testPlanFile = TestPlan.getTestPlanFile("fileIteratorTest");
-		SequentialInputFormat inputFormat = FormatUtil.openInput(SequentialInputFormat.class, testPlanFile,
-			null);
-		InputFileIterator inputFileIterator = new InputFileIterator(inputFormat);
-
-		AssertUtil.assertIteratorEquals("input file iterator is not empty", 
-			new ArrayList<PactRecord>().iterator(),
-			inputFileIterator, 
-			new PactRecordEqualer(PactInteger.class, PactString.class));
-	}
-
-	/**
-	 * Tests if a file iterator of a non-existent file fails.
-	 * 
-	 * @throws IOException
-	 *         if an I/O exception occurred
-	 */
-	@Test
-	public void failIfReadTwoManyItems() throws IOException {
-		PactRecord[] pairs = { new PactRecord(new PactInteger(1), new PactString("test1")),
-			new PactRecord(new PactInteger(2), new PactString("test2")) };
-		InputFileIterator inputFileIterator = createFileIterator(pairs);
-
-		while (inputFileIterator.hasNext())
-			Assert.assertNotNull(inputFileIterator.next());
-
-		try {
-			inputFileIterator.next();
-			Assert.fail("should have thrown Exception");
-		} catch (NoSuchElementException e) {
-		}
-	}
-
-	private InputFileIterator createFileIterator(PactRecord... pairs)
-			throws IOException {
-		String testPlanFile = TestPlan.getTestPlanFile("fileIteratorTest");
-		SequentialOutputFormat output = FormatUtil.openOutput(SequentialOutputFormat.class,
-			testPlanFile, null);
-		for (PactRecord keyValuePair : pairs)
-			output.writeRecord(keyValuePair);
-		output.close();
-		SequentialInputFormat inputFormat = FormatUtil.openInput(SequentialInputFormat.class, testPlanFile,
-			null);
-		InputFileIterator inputFileIterator = new InputFileIterator(inputFormat);
-		return inputFileIterator;
-	}
-}
diff --git a/pact/pact-clients/src/test/java/eu/stratosphere/pact/testing/TestPairsTest.java b/pact/pact-clients/src/test/java/eu/stratosphere/pact/testing/TestPairsTest.java
deleted file mode 100644
index 228aee9..0000000
--- a/pact/pact-clients/src/test/java/eu/stratosphere/pact/testing/TestPairsTest.java
+++ /dev/null
@@ -1,110 +0,0 @@
-/***********************************************************************************************************************
- *
- * Copyright (C) 2010 by the Stratosphere project (http://stratosphere.eu)
- *
- * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with
- * the License. You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on
- * an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
- * specific language governing permissions and limitations under the License.
- *
- **********************************************************************************************************************/
-
-package eu.stratosphere.pact.testing;
-
-import java.util.ArrayList;
-import java.util.Arrays;
-
-import org.junit.Before;
-import org.junit.Test;
-
-import eu.stratosphere.pact.common.type.PactRecord;
-import eu.stratosphere.pact.common.type.base.PactInteger;
-import eu.stratosphere.pact.common.type.base.PactString;
-
-/**
- * Tests {@link TestPairs}.
- * 
- * @author Arvid Heise
- */
-public class TestPairsTest {
-	private TestRecords pairs;
-
-	private static PactRecordEqualer IntStringEqualer = new PactRecordEqualer(PactInteger.class, PactString.class);
-
-	/**
-	 * 
-	 */
-	@Before
-	public void setup() {
-		this.pairs = new TestRecords();
-	}
-
-	/**
-	 * 
-	 */
-	@Test
-	public void singleAddShouldAddOneItem() {
-		AssertUtil.assertIteratorEquals("should be empty in the beginning",
-			new ArrayList<PactRecord>().iterator(),
-			this.pairs.iterator(),
-			IntStringEqualer);
-
-		this.pairs.add(new PactInteger(1), new PactString("test1"));
-		AssertUtil.assertIteratorEquals("should contain one element after invoking add once",
-			Arrays.asList(new PactRecord(new PactInteger(1), new PactString("test1"))).iterator(),
-			this.pairs.iterator(),
-			IntStringEqualer);
-
-		this.pairs.add(new PactInteger(2), new PactString("test2"));
-		AssertUtil.assertIteratorEquals("should contain two element after invoking add twice",
-			Arrays.asList(
-				new PactRecord(new PactInteger(1), new PactString("test1")),
-				new PactRecord(new PactInteger(2), new PactString("test2"))).iterator(),
-			this.pairs.iterator(),
-			IntStringEqualer);
-	}
-
-	/**
-	 * 
-	 */
-	@Test
-	public void iterableAddShouldAddAllItems() {
-		AssertUtil.assertIteratorEquals("should be empty in the beginning",
-			new ArrayList<PactRecord>().iterator(),
-			this.pairs.iterator(),
-			IntStringEqualer);
-
-		this.pairs.add(Arrays.asList(new PactRecord(new PactInteger(1), new PactString("test1")),
-			new PactRecord(new PactInteger(2), new PactString("test2"))));
-		AssertUtil.assertIteratorEquals("should contain two element after batch adding two items",
-			Arrays.asList(
-				new PactRecord(new PactInteger(1), new PactString("test1")),
-				new PactRecord(new PactInteger(2), new PactString("test2"))).iterator(),
-			this.pairs.iterator(),
-			IntStringEqualer);
-	}
-
-	/**
-	 * 
-	 */
-	@Test
-	public void arrayAddShouldAddAllItems() {
-		AssertUtil.assertIteratorEquals("should be empty in the beginning",
-			new ArrayList<PactRecord>().iterator(),
-			this.pairs.iterator(),
-			IntStringEqualer);
-
-		this.pairs.add(new PactRecord(new PactInteger(1), new PactString("test1")),
-			new PactRecord(new PactInteger(2), new PactString("test2")));
-		AssertUtil.assertIteratorEquals("should contain two element after batch adding two items",
-			Arrays.asList(
-				new PactRecord(new PactInteger(1), new PactString("test1")),
-				new PactRecord(new PactInteger(2), new PactString("test2"))).iterator(),
-			this.pairs.iterator(),
-			IntStringEqualer);
-	}
-}
diff --git a/pact/pact-clients/src/test/java/eu/stratosphere/pact/testing/TestPlanTest.java b/pact/pact-clients/src/test/java/eu/stratosphere/pact/testing/TestPlanTest.java
deleted file mode 100644
index 8570783..0000000
--- a/pact/pact-clients/src/test/java/eu/stratosphere/pact/testing/TestPlanTest.java
+++ /dev/null
@@ -1,813 +0,0 @@
-/***********************************************************************************************************************
- *
- * Copyright (C) 2010 by the Stratosphere project (http://stratosphere.eu)
- *
- * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with
- * the License. You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on
- * an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
- * specific language governing permissions and limitations under the License.
- *
- **********************************************************************************************************************/
-
-package eu.stratosphere.pact.testing;
-
-import static org.junit.Assert.assertEquals;
-import static org.junit.Assert.assertFalse;
-import static org.junit.Assert.assertTrue;
-import static org.junit.Assert.fail;
-
-import java.io.File;
-import java.io.IOException;
-import java.io.PrintWriter;
-import java.net.URL;
-import java.util.Enumeration;
-import java.util.Iterator;
-import java.util.regex.Matcher;
-import java.util.regex.Pattern;
-
-import junit.framework.Assert;
-import junit.framework.AssertionFailedError;
-
-import org.junit.Test;
-import org.junit.internal.ArrayComparisonFailure;
-
-import eu.stratosphere.pact.common.contract.CoGroupContract;
-import eu.stratosphere.pact.common.contract.CrossContract;
-import eu.stratosphere.pact.common.contract.FileDataSink;
-import eu.stratosphere.pact.common.contract.FileDataSource;
-import eu.stratosphere.pact.common.contract.GenericDataSource;
-import eu.stratosphere.pact.common.contract.MapContract;
-import eu.stratosphere.pact.common.contract.MatchContract;
-import eu.stratosphere.pact.common.contract.ReduceContract;
-import eu.stratosphere.pact.common.contract.ReduceContract.Combinable;
-import eu.stratosphere.pact.common.io.DelimitedInputFormat;
-import eu.stratosphere.pact.common.io.FileInputFormat;
-import eu.stratosphere.pact.common.io.FileOutputFormat;
-import eu.stratosphere.pact.common.io.SequentialOutputFormat;
-import eu.stratosphere.pact.common.io.TextInputFormat;
-import eu.stratosphere.pact.common.stubs.CoGroupStub;
-import eu.stratosphere.pact.common.stubs.Collector;
-import eu.stratosphere.pact.common.stubs.CrossStub;
-import eu.stratosphere.pact.common.stubs.MapStub;
-import eu.stratosphere.pact.common.stubs.MatchStub;
-import eu.stratosphere.pact.common.stubs.ReduceStub;
-import eu.stratosphere.pact.common.type.PactRecord;
-import eu.stratosphere.pact.common.type.Value;
-import eu.stratosphere.pact.common.type.base.PactInteger;
-import eu.stratosphere.pact.common.type.base.PactList;
-import eu.stratosphere.pact.common.type.base.PactString;
-import eu.stratosphere.pact.generic.contract.Contract;
-
-/**
- * Tests {@link TestPlan}.
- * 
- * @author Arvid Heise
- */
-public class TestPlanTest {
-	@SuppressWarnings("unchecked")
-	private static final Class<? extends Value>[] IntStringPair = new Class[] { PactInteger.class, PactString.class };
-
-	/**
-	 * (int1, string1) x (int2, string2) -&gt; ((int1, int2), (string1, string2))
-	 * 
-	 * @author Arvid Heise
-	 */
-	public static final class CartesianProduct extends CrossStub {
-		/*
-		 * (non-Javadoc)
-		 * @see eu.stratosphere.pact.common.stubs.CrossStub#cross(eu.stratosphere.pact.common.type.PactRecord,
-		 * eu.stratosphere.pact.common.type.PactRecord, eu.stratosphere.pact.common.stubs.Collector)
-		 */
-		@Override
-		public void cross(PactRecord record1, PactRecord record2, Collector<PactRecord> out) {
-			out.collect(makeRecord(
-				record1.getField(0, PactInteger.class),
-				record2.getField(0, PactInteger.class),
-				record1.getField(1, PactString.class),
-				record2.getField(1, PactString.class)));
-		}
-
-	}
-
-	private static PactRecord makeRecord(Value... values) {
-		PactRecord record = new PactRecord();
-		for (int index = 0; index < values.length; index++)
-			record.setField(index, values[index]);
-		return record;
-	}
-
-	/**
-	 * (int1, [string1, string2]) x (int1, [string3, string4]) -&gt; (int1, [string1, string2, string3, string4])
-	 * 
-	 * @author Arvid Heise
-	 */
-	public static final class AppendingCoGroup extends CoGroupStub {
-		/*
-		 * (non-Javadoc)
-		 * @see eu.stratosphere.pact.common.stubs.CoGroupStub#coGroup(java.util.Iterator, java.util.Iterator,
-		 * eu.stratosphere.pact.common.stubs.Collector)
-		 */
-		@SuppressWarnings("null")
-		@Override
-		public void coGroup(Iterator<PactRecord> records1, Iterator<PactRecord> records2, Collector<PactRecord> out) {
-			StringList values = new StringList();
-			PactRecord lastRecord = null;
-			while (records1.hasNext())
-				values.add(new PactString((lastRecord = records1.next()).getField(1, PactString.class)));
-			while (records2.hasNext())
-				values.add(new PactString((lastRecord = records2.next()).getField(1, PactString.class)));
-			out.collect(new PactRecord(lastRecord.getField(0, PactInteger.class), values));
-		}
-	}
-
-	/**
-	 * (int1, string1) x (int1, string2) -&gt; (int1, (string1, string2))
-	 * 
-	 * @author Arvid Heise
-	 */
-	public static final class Join extends MatchStub {
-		/*
-		 * (non-Javadoc)
-		 * @see eu.stratosphere.pact.common.stubs.MatchStub#match(eu.stratosphere.pact.common.type.PactRecord,
-		 * eu.stratosphere.pact.common.type.PactRecord, eu.stratosphere.pact.common.stubs.Collector)
-		 */
-		@Override
-		public void match(PactRecord record1, PactRecord record2, Collector<PactRecord> out) throws Exception {
-			out.collect(makeRecord(record1.getField(0, PactInteger.class),
-				record1.getField(1, PactString.class),
-				record2.getField(1, PactString.class)));
-		}
-	}
-
-	/**
-	 * @author Arvid Heise
-	 */
-	public static final class ErroneousPact extends MapStub {
-		/*
-		 * (non-Javadoc)
-		 * @see eu.stratosphere.pact.common.stubs.MapStub#map(eu.stratosphere.pact.common.type.PactRecord,
-		 * eu.stratosphere.pact.common.stubs.Collector)
-		 */
-		@Override
-		public void map(PactRecord record, Collector<PactRecord> out) throws Exception {
-			throw new IllegalStateException();
-		}
-	}
-
-	/**
-	 * (int1, string1), (int1, string2) -&gt; (int1, [string1, string2])
-	 * 
-	 * @author Arvid Heise
-	 */
-	public static final class AppendingReduce extends ReduceStub {
-		/*
-		 * (non-Javadoc)
-		 * @see eu.stratosphere.pact.common.stubs.ReduceStub#reduce(java.util.Iterator,
-		 * eu.stratosphere.pact.common.stubs.Collector)
-		 */
-		@Override
-		public void reduce(Iterator<PactRecord> records, Collector<PactRecord> out) throws Exception {
-			StringList result = new StringList();
-			PactRecord lastRecord = null;
-			while (records.hasNext())
-				result.add(new PactString((lastRecord = records.next()).getField(1, PactString.class)));
-			@SuppressWarnings("null")
-			PactInteger id = lastRecord.getField(0, PactInteger.class);
-			out.collect(new PactRecord(id, result));
-		}
-	}
-
-	/**
-	 * List of {@link PactString}s.
-	 * 
-	 * @author Arvid Heise
-	 */
-	public static final class StringList extends PactList<PactString> {
-		/**
-		 * Initializes StringList.
-		 */
-		public StringList() {
-		}
-
-		private StringList(String... strings) {
-			for (String string : strings)
-				add(new PactString(string));
-		}
-	}
-
-	/**
-	 * Converts a input string (a line) into a PactRecord.
-	 */
-	public static class IntegerInFormat extends DelimitedInputFormat {
-		@Override
-		public boolean reachedEnd() {
-			return super.reachedEnd();
-		}
-
-		/* (non-Javadoc)
-		 * @see eu.stratosphere.pact.common.io.TextInputFormat#readRecord(eu.stratosphere.pact.common.type.PactRecord, byte[], int, int)
-		 */
-		@Override
-		public boolean readRecord(PactRecord target, byte[] bytes, int offset, int numBytes) {
-			target.setField(0, new PactInteger(Integer.valueOf(new String(bytes, offset, numBytes))));
-			return true;//super.readRecord(target, bytes, offset, numBytes);
-		}
-	}
-
-	/**
-	 * Converts a PactRecord to a string.
-	 */
-	public static class IntegerOutFormat extends FileOutputFormat {
-		private PrintWriter writer;
-		
-		/*
-		 * (non-Javadoc)
-		 * @see eu.stratosphere.pact.common.io.FileOutputFormat#open(int)
-		 */
-		@Override
-		public void open(int taskNumber) throws IOException {
-			super.open(taskNumber);
-			this.writer = new PrintWriter(this.stream);
-		}
-
-		/*
-		 * (non-Javadoc)
-		 * @see eu.stratosphere.pact.common.io.OutputFormat#writeRecord(eu.stratosphere.pact.common.type.PactRecord)
-		 */
-		@Override
-		public void writeRecord(PactRecord record) throws IOException {
-			this.writer.format("%d\n", record.getField(0, PactInteger.class).getValue());
-		}
-	}
-
-	/**
-	 * Tests if a {@link TestPlan} can be executed.
-	 */
-	@Test
-	public void completeTestPasses() {
-		final FileDataSource read = createInput(IntegerInFormat.class,
-			"TestPlan/test.txt");
-
-		final MapContract map =
-			MapContract.builder(IdentityMap.class).name("Map").build();
-		map.setInput(read);
-
-		FileDataSink output = createOutput(map, SequentialOutputFormat.class);
-
-		TestPlan testPlan = new TestPlan(output);
-		testPlan.run();
-		testPlan.getInput().setSchema(PactInteger.class);
-		// testPlan.getActualOutput().setSchema(PactInteger.class);
-		assertEquals("input and output should be equal in identity map", testPlan.getInput(), testPlan
-			.getActualOutput());
-	}
-
-	/**
-	 * Tests if a {@link TestPlan} without explicit data sources and sinks can be executed.
-	 */
-	@Test
-	public void adhocInputAndOutputShouldTransparentlyWork() {
-		final MapContract map = MapContract.builder(IdentityMap.class)
-			.name("Map")
-			.build();
-		TestPlan testPlan = new TestPlan(map);
-		testPlan.getInput().
-			add(new PactInteger(1), new PactString("test1")).
-			add(new PactInteger(2), new PactString("test2"));
-		testPlan.run();
-
-		testPlan.getInput().setSchema(IntStringPair);
-		testPlan.getActualOutput().setSchema(IntStringPair);
-		assertEquals("input and output should be equal in identity map", testPlan.getInput(), testPlan
-			.getActualOutput());
-
-		// explicitly check output
-		Iterator<PactRecord> outputIterator = testPlan.getActualOutput().iterator();
-		Iterator<PactRecord> inputIterator = testPlan.getInput().iterator();
-		for (int index = 0; index < 2; index++) {
-			assertTrue("too few actual output values", outputIterator.hasNext());
-			assertTrue("too few input values", outputIterator.hasNext());
-			try {
-				assertTrue(PactRecordEqualer.recordsEqual(inputIterator.next(), outputIterator.next(), IntStringPair));
-			} catch (AssertionFailedError e) {
-				throw new ArrayComparisonFailure("Could not verify output values", e, index);
-			}
-		}
-		assertFalse("too few actual output values", outputIterator.hasNext());
-		assertFalse("too few input values", outputIterator.hasNext());
-	}
-
-	/**
-	 * Tests if a {@link TestPlan} can be executed.
-	 */
-	@Test
-	public void completeTestPassesWithExpectedValues() {
-		final FileDataSource read = createInput(IntegerInFormat.class,
-			"TestPlan/test.txt");
-
-		final MapContract map = MapContract.builder(IdentityMap.class)
-			.name("Map")
-			.build();
-		map.setInput(read);
-
-		FileDataSink output = createOutput(map, IntegerOutFormat.class);
-
-		TestPlan testPlan = new TestPlan(output);
-		testPlan.getExpectedOutput(output, IntStringPair).fromFile(IntegerInFormat.class,
-			getResourcePath("TestPlan/test.txt"));
-		testPlan.run();
-	}
-
-	private String getResourcePath(String resource) {
-		try {
-			Enumeration<URL> resources = TestPlanTest.class.getClassLoader().getResources(resource);
-			if (resources.hasMoreElements())
-				return resources.nextElement().toString();
-		} catch (IOException e) {
-			throw new IllegalStateException(e);
-		}
-		throw new IllegalArgumentException("no resources found");
-	}
-
-	/**
-	 * Tests if a {@link TestPlan} without explicit data sources and sinks can be executed.
-	 */
-	@Test
-	public void expectedValuesShouldAlsoWorkWithAdhocInputAndOutput() {
-		final MapContract map = MapContract.builder(IdentityMap.class)
-			.name("Map")
-			.build();
-		TestPlan testPlan = new TestPlan(map);
-		testPlan.getInput().
-			add(new PactInteger(1), new PactString("test1")).
-			add(new PactInteger(2), new PactString("test2"));
-		testPlan.getExpectedOutput(PactInteger.class, PactString.class).
-			add(new PactInteger(1), new PactString("test1")).
-			add(new PactInteger(2), new PactString("test2"));
-		testPlan.run();
-	}
-
-	/**
-	 * Tests if a {@link TestPlan} succeeds with values having the same key.
-	 */
-	@Test
-	public void shouldMatchValuesWithSameKey() {
-		final MapContract map = MapContract.builder(IdentityMap.class)
-			.name("Map")
-			.build();
-		TestPlan testPlan = new TestPlan(map);
-		// randomize values
-		testPlan.getInput().
-			add(new PactInteger(2), new PactString("test3")).
-			add(new PactInteger(1), new PactString("test2")).
-			add(new PactInteger(1), new PactString("test1")).
-			add(new PactInteger(2), new PactString("test1")).
-			add(new PactInteger(1), new PactString("test3")).
-			add(new PactInteger(2), new PactString("test2"));
-		testPlan.getExpectedOutput(PactInteger.class, PactString.class).
-			add(new PactInteger(1), new PactString("test1")).
-			add(new PactInteger(2), new PactString("test1")).
-			add(new PactInteger(2), new PactString("test2")).
-			add(new PactInteger(1), new PactString("test3")).
-			add(new PactInteger(1), new PactString("test2")).
-			add(new PactInteger(2), new PactString("test3"));
-		testPlan.run();
-	}
-
-	/**
-	 * Tests a {@link TestPlan} with a {@link CrossContract}.
-	 */
-	@Test
-	public void crossShouldBeSupported() {
-		CrossContract crossContract = CrossContract.builder(CartesianProduct.class).build();
-
-		TestPlan testPlan = new TestPlan(crossContract);
-		testPlan.getInput(0).
-			add(new PactInteger(1), new PactString("test1")).
-			add(new PactInteger(2), new PactString("test2"));
-		testPlan.getInput(1).
-			add(new PactInteger(3), new PactString("test3")).
-			add(new PactInteger(4), new PactString("test4"));
-
-		testPlan.getExpectedOutput(PactInteger.class, PactInteger.class, PactString.class, PactString.class).
-			add(new PactInteger(1), new PactInteger(3), new PactString("test1"), new PactString("test3")).
-			add(new PactInteger(1), new PactInteger(4), new PactString("test1"), new PactString("test4")).
-			add(new PactInteger(2), new PactInteger(3), new PactString("test2"), new PactString("test3")).
-			add(new PactInteger(2), new PactInteger(4), new PactString("test2"), new PactString("test4"));
-		testPlan.run();
-	}
-
-	/**
-	 * Tests a {@link TestPlan} with a {@link CoGroupContract}.
-	 */
-	@Test
-	public void coGroupShouldBeSupported() {
-		CoGroupContract crossContract = CoGroupContract.builder(AppendingCoGroup.class, PactInteger.class, 0, 0)
-			.build();
-
-		TestPlan testPlan = new TestPlan(crossContract);
-		testPlan.getInput(0).
-			add(new PactInteger(1), new PactString("test1")).
-			add(new PactInteger(1), new PactString("test2")).
-			add(new PactInteger(2), new PactString("test3"));
-		testPlan.getInput(1).
-			add(new PactInteger(1), new PactString("test4")).
-			add(new PactInteger(3), new PactString("test5"));
-
-		testPlan.getExpectedOutput(PactInteger.class, StringList.class).
-			add(new PactInteger(1), new StringList("test1", "test2", "test4")).
-			add(new PactInteger(2), new StringList("test3")).
-			add(new PactInteger(3), new StringList("test5"));
-		testPlan.run();
-	}
-
-	/**
-	 * Tests a {@link TestPlan} with a {@link CoGroupContract}.
-	 */
-	@Test
-	public void matchShouldBeSupported() {
-		MatchContract crossContract = MatchContract.builder(Join.class, PactInteger.class, 0, 0)
-			.build();
-
-		TestPlan testPlan = new TestPlan(crossContract);
-		testPlan.getInput(0).
-			add(new PactInteger(1), new PactString("test1")).
-			add(new PactInteger(1), new PactString("test2")).
-			add(new PactInteger(2), new PactString("test3"));
-		testPlan.getInput(1).
-			add(new PactInteger(1), new PactString("test4")).
-			add(new PactInteger(3), new PactString("test5"));
-
-		testPlan.getExpectedOutput(PactInteger.class, PactString.class, PactString.class).
-			add(new PactInteger(1), new PactString("test1"), new PactString("test4")).
-			add(new PactInteger(1), new PactString("test2"), new PactString("test4"));
-		testPlan.run();
-	}
-
-	/**
-	 * Tests a {@link TestPlan} with a {@link CoGroupContract}.
-	 */
-	@Test
-	public void reduceShouldBeSupported() {
-		ReduceContract crossContract = new ReduceContract.Builder(AppendingReduce.class, PactInteger.class, 0)
-			.build();
-
-		TestPlan testPlan = new TestPlan(crossContract);
-		testPlan.getInput().
-			add(new PactInteger(1), new PactString("test1")).
-			add(new PactInteger(1), new PactString("test2")).
-			add(new PactInteger(2), new PactString("test3")).
-			add(new PactInteger(1), new PactString("test4")).
-			add(new PactInteger(3), new PactString("test5"));
-
-		testPlan.getExpectedOutput(PactInteger.class, StringList.class).
-			add(new PactInteger(1), new StringList("test1", "test2", "test4")).
-			add(new PactInteger(2), new StringList("test3")).
-			add(new PactInteger(3), new StringList("test5"));
-		testPlan.run();
-	}
-
-	/**
-	 * Tests a {@link TestPlan} with a {@link CrossContract}.
-	 */
-	@Test
-	public void settingValuesShouldWorkWithSourceContracts() {
-		CrossContract crossContract = CrossContract.builder(CartesianProduct.class).build();
-
-		TestPlan testPlan = new TestPlan(crossContract);
-		// first and second input are added in TestPlan
-		testPlan.getInput((GenericDataSource<?>) crossContract.getFirstInputs().get(0)).
-			add(new PactInteger(1), new PactString("test1")).
-			add(new PactInteger(2), new PactString("test2"));
-		testPlan.getInput((GenericDataSource<?>) crossContract.getSecondInputs().get(0)).
-			add(new PactInteger(3), new PactString("test3")).
-			add(new PactInteger(4), new PactString("test4"));
-
-		testPlan.getExpectedOutput(PactInteger.class, PactInteger.class, PactString.class, PactString.class).
-			add(new PactInteger(1), new PactInteger(3), new PactString("test1"), new PactString("test3")).
-			add(new PactInteger(1), new PactInteger(4), new PactString("test1"), new PactString("test4")).
-			add(new PactInteger(2), new PactInteger(3), new PactString("test2"), new PactString("test3")).
-			add(new PactInteger(2), new PactInteger(4), new PactString("test2"), new PactString("test4"));
-		testPlan.run();
-	}
-
-	/**
-	 * Tests {@link TestPlan#setDegreeOfParallelism(int)}.
-	 */
-	@Test
-	public void degreeOfParallelismShouldBeConfigurable() {
-		final MapContract map = MapContract.builder(IdentityMap.class)
-			.name("Map")
-			.build();
-		TestPlan testPlan = new TestPlan(map);
-		testPlan.getInput().
-			add(new PactInteger(1), new PactString("test1")).
-			add(new PactInteger(2), new PactString("test2"));
-		testPlan.getExpectedOutput(PactInteger.class, PactString.class).
-			add(new PactInteger(1), new PactString("test1")).
-			add(new PactInteger(2), new PactString("test2"));
-		testPlan.setDegreeOfParallelism(2);
-		Assert.assertEquals(2, testPlan.getDegreeOfParallelism());
-		testPlan.run();
-		Assert.assertEquals(2, map.getDegreeOfParallelism());
-	}
-
-	/**
-	 * Creates an output file in the temporary folder for arbitrary key/value pairs coming from the given input
-	 * contract.
-	 * 
-	 * @param input
-	 *        the input from which the values are read
-	 * @param outputFormatClass
-	 *        the output format
-	 * @return the {@link FileDataSinkContract} for the temporary file
-	 */
-	private FileDataSink createOutput(final Contract input, final Class<? extends FileOutputFormat> outputFormatClass) {
-		try {
-			final FileDataSink out = new FileDataSink(outputFormatClass, File.createTempFile(
-				"output", null).toURI().toString(), "Output");
-			out.setInput(input);
-			return out;
-		} catch (IOException e) {
-			fail("cannot create temporary output file" + e);
-			return null;
-		}
-	}
-
-	/**
-	 * Creates an {@link FileDataSource} contract for the specified resource file in the temporary folder for
-	 * arbitrary key/value pairs coming from the given input
-	 * contract.
-	 * 
-	 * @param input
-	 *        the input from which the values are read
-	 * @return the {@link FileDataSinkContract} for the temporary file
-	 */
-	private FileDataSource createInput(Class<? extends FileInputFormat> inputFormat, String resource) {
-		final FileDataSource read = new FileDataSource(inputFormat,
-			getResourcePath(resource),
-			"Input");
-		return read;
-	}
-
-	/**
-	 * Converts a (String,Integer)-KeyValuePair into multiple KeyValuePairs. The
-	 * key string is tokenized by spaces. For each token a new
-	 * (String,Integer)-KeyValuePair is emitted where the Token is the key and
-	 * an Integer(1) is the value.
-	 */
-	public static class TokenizeLine extends MapStub {
-		private static Pattern WORD_PATTERN = Pattern.compile("\\w+");
-
-		/*
-		 * (non-Javadoc)
-		 * @see eu.stratosphere.pact.common.stubs.MapStub#map(eu.stratosphere.pact.common.type.PactRecord,
-		 * eu.stratosphere.pact.common.stubs.Collector)
-		 */
-		@Override
-		public void map(PactRecord record, Collector<PactRecord> out) throws Exception {
-			PactString line = record.getField(0, PactString.class);
-			Matcher matcher = WORD_PATTERN.matcher(line.getValue());
-			while (matcher.find())
-				out.collect(new PactRecord(new PactString(matcher.group(0).toLowerCase()), new PactInteger(1)));
-		}
-	}
-
-	/**
-	 * Counts the number of values for a given key. Hence, the number of
-	 * occurences of a given token (word) is computed and emitted. The key is
-	 * not modified, hence a SameKey OutputContract is attached to this class.
-	 */
-	@Combinable
-	public static class CountWords extends ReduceStub {
-		/*
-		 * (non-Javadoc)
-		 * @see eu.stratosphere.pact.common.stubs.ReduceStub#reduce(java.util.Iterator,
-		 * eu.stratosphere.pact.common.stubs.Collector)
-		 */
-		@Override
-		public void reduce(Iterator<PactRecord> records, Collector<PactRecord> out) throws Exception {
-			PactRecord result = records.next().createCopy();
-			int sum = result.getField(1, PactInteger.class).getValue();
-			while (records.hasNext())
-				sum += records.next().getField(1, PactInteger.class).getValue();
-			result.setField(1, new PactInteger(sum));
-			out.collect(result);
-		}
-	}
-
-	/**
-	 * Tests if a {@link TestPlan} with two stubs can be executed.
-	 */
-	@Test
-	public void complexTestPassesWithExpectedValues() {
-		final MapContract tokenize = MapContract.builder(TokenizeLine.class)
-			.name("Map")
-			.build();
-		final ReduceContract summing = new ReduceContract.Builder(CountWords.class, PactString.class, 0)
-			.name("Reduce")
-			.build();
-		summing.setInput(tokenize);
-
-		TestPlan testPlan = new TestPlan(summing);
-		String[] lines =
-			{
-				"Lorem ipsum dolor sit amet, consectetur adipisicing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua.",
-				"Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat.",
-				"Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur.",
-				"Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum." };
-		for (String line : lines)
-			testPlan.getInput().add(new PactString(line));
-
-		String[] singleWords = { "voluptate", "veniam", "velit", "ullamco", "tempor", "sunt", "sit", "sint", "sed",
-			"reprehenderit", "quis", "qui", "proident", "pariatur", "officia", "occaecat", "nulla", "nostrud", "non",
-			"nisi", "mollit", "minim", "magna", "lorem", "laborum", "laboris", "labore", "irure", "ipsum",
-			"incididunt", "id", "fugiat", "exercitation", "excepteur", "ex", "eu", "et", "est", "esse", "enim", "elit",
-			"eiusmod", "ea", "duis", "do", "deserunt", "cupidatat", "culpa", "consequat", "consectetur", "commodo",
-			"cillum", "aute", "anim", "amet", "aliquip", "aliqua", "adipisicing", "ad" };
-		for (String singleWord : singleWords)
-			testPlan.getExpectedOutput(PactString.class, PactInteger.class).
-				add(new PactString(singleWord), new PactInteger(1));
-		testPlan.getExpectedOutput(PactString.class, PactInteger.class).
-			add(new PactString("ut"), new PactInteger(3)).
-			add(new PactString("in"), new PactInteger(3)).
-			add(new PactString("dolore"), new PactInteger(2)).
-			add(new PactString("dolor"), new PactInteger(2));
-		testPlan.run();
-	}
-
-	/**
-	 * Tests if a {@link TestPlan} fails if the actual values do not match the expected values.
-	 */
-	@Test
-	public void shouldFailIfExpectedAndActualValuesDiffer() {
-		final MapContract map = MapContract.builder(IdentityMap.class)
-			.name("Map")
-			.build();
-		TestPlan testPlan = new TestPlan(map);
-		testPlan.getInput().
-			add(new PactInteger(1), new PactString("test1")).
-			add(new PactInteger(2), new PactString("test2"));
-		testPlan.getExpectedOutput(PactInteger.class, PactString.class).
-			add(new PactInteger(1), new PactString("test1")).
-			add(new PactInteger(2), new PactString("test3"));
-		assertTestRunFails(testPlan);
-	}
-
-	/**
-	 * Tests if a {@link TestPlan} fails there are too many values.
-	 */
-	@Test
-	public void shouldFailIfTooManyValues() {
-		final MapContract map = MapContract.builder(IdentityMap.class)
-			.name("Map")
-			.build();
-		TestPlan testPlan = new TestPlan(map);
-		testPlan.getInput().
-			add(new PactInteger(1), new PactString("test1")).
-			add(new PactInteger(2), new PactString("test2"));
-		testPlan.getExpectedOutput(PactInteger.class, PactString.class).
-			add(new PactInteger(1), new PactString("test1"));
-		assertTestRunFails(testPlan);
-	}
-
-	/**
-	 * Tests if a {@link TestPlan} fails there are too few values.
-	 */
-	@Test
-	public void shouldFailIfTooFewValues() {
-		final MapContract map = MapContract.builder(IdentityMap.class)
-			.name("Map")
-			.build();
-		TestPlan testPlan = new TestPlan(map);
-		testPlan.getInput().
-			add(new PactInteger(1), new PactString("test1")).
-			add(new PactInteger(2), new PactString("test2"));
-		testPlan.getExpectedOutput(PactInteger.class, PactString.class).
-			add(new PactInteger(1), new PactString("test1")).
-			add(new PactInteger(2), new PactString("test2")).
-			add(new PactInteger(3), new PactString("test3"));
-		assertTestRunFails(testPlan);
-	}
-
-	/**
-	 * Tests if a {@link TestPlan} fails there are too many values.
-	 */
-	@Test
-	public void shouldFailIfPactThrowsException() {
-		final MapContract map = MapContract.builder(ErroneousPact.class)
-			.name("Map")
-			.build();
-		TestPlan testPlan = new TestPlan(map);
-		testPlan.getInput().
-			add(new PactInteger(1), new PactString("test1")).
-			add(new PactInteger(2), new PactString("test2"));
-		testPlan.getExpectedOutput(PactInteger.class, PactString.class).
-			setEmpty();
-		assertTestRunFails(testPlan);
-	}
-
-	/**
-	 * Fails if the test plan does not fail.
-	 * 
-	 * @param testPlan
-	 *        the test plan expected to fail
-	 */
-	public static void assertTestRunFails(TestPlan testPlan) {
-		boolean failed = false;
-		try {
-			testPlan.run();
-		} catch (AssertionError error) {
-			failed = true;
-		}
-		assertTrue("Test plan should have failed", failed);
-	}
-
-	/**
-	 * Tests if a {@link TestPlan} succeeds with uninitialized expected values.
-	 */
-	@Test
-	public void shouldSucceedIfNoExpectedValues() {
-		final MapContract map = MapContract.builder(IdentityMap.class)
-			.name("Map")
-			.build();
-		TestPlan testPlan = new TestPlan(map);
-		testPlan.getInput().
-			add(new PactInteger(1), new PactString("test1")).
-			add(new PactInteger(2), new PactString("test2"));
-		testPlan.run();
-	}
-
-	/**
-	 * Tests if a {@link TestPlan} succeeds with values having the same key.
-	 */
-	@Test
-	public void shouldFailWithEqualValuesWithSameKey() {
-		final MapContract map = MapContract.builder(IdentityMap.class)
-			.name("Map")
-			.build();
-		TestPlan testPlan = new TestPlan(map);
-		testPlan.getInput().
-			add(new PactInteger(1), new PactString("test1")).
-			add(new PactInteger(1), new PactString("test2")).
-			add(new PactInteger(1), new PactString("test3")).
-			add(new PactInteger(2), new PactString("test1")).
-			add(new PactInteger(2), new PactString("test2")).
-			add(new PactInteger(2), new PactString("test3"));
-		// randomize values
-		testPlan.getExpectedOutput(PactInteger.class, PactString.class).
-			add(new PactInteger(1), new PactString("test1")).
-			add(new PactInteger(2), new PactString("test1")).
-			add(new PactInteger(2), new PactString("test2")).
-			add(new PactInteger(1), new PactString("test3")).
-			add(new PactInteger(1), new PactString("test3")). // <-- duplicate
-			add(new PactInteger(2), new PactString("test3"));
-		assertTestRunFails(testPlan);
-	}
-
-	/**
-	 * Tests if a {@link TestPlan} fails if actual values appear but empty values are expected.
-	 */
-	@Test
-	public void shouldFailIfNonEmptyExpectedValues() {
-		final MapContract map = MapContract.builder(IdentityMap.class)
-			.name("Map")
-			.build();
-		TestPlan testPlan = new TestPlan(map);
-		testPlan.getInput().
-			add(new PactInteger(1), new PactString("test1")).
-			add(new PactInteger(2), new PactString("test2"));
-		testPlan.getExpectedOutput(PactInteger.class, PactString.class).setEmpty();
-		assertTestRunFails(testPlan);
-	}
-
-	/**
-	 * Tests if the outputs of two {@link TestPlan}s can be successfully compared.
-	 */
-	@Test
-	public void shouldCompareTwoTestPlans() {
-		final MapContract map = MapContract.builder(IdentityMap.class)
-			.name("Map")
-			.build();
-		TestPlan testPlan1 = new TestPlan(map);
-		testPlan1.getInput().
-			add(new PactInteger(1), new PactString("test1")).
-			add(new PactInteger(2), new PactString("test2"));
-		testPlan1.run();
-		TestPlan testPlan2 = new TestPlan(map);
-		testPlan2.getInput().
-			add(new PactInteger(2), new PactString("test2")).
-			add(new PactInteger(1), new PactString("test1"));
-		testPlan2.run();
-
-		testPlan1.getActualOutput().setSchema(IntStringPair);
-		testPlan2.getActualOutput().setSchema(IntStringPair);
-		AssertUtil.assertIteratorEquals(testPlan1.getActualOutput().iterator(),
-			testPlan2.getActualOutput().iterator(),
-			new PactRecordEqualer(IntStringPair));
-	}
-}
diff --git a/pact/pact-clients/src/test/resources/TestPlan/test.txt b/pact/pact-clients/src/test/resources/TestPlan/test.txt
deleted file mode 100644
index ab823eb..0000000
--- a/pact/pact-clients/src/test/resources/TestPlan/test.txt
+++ /dev/null
@@ -1,20 +0,0 @@
-85
-82
-0
-62
-7
-51
-16
-65
-56
-8
-13
-1
-75
-99
-34
-19
-19
-96
-52
-54
\ No newline at end of file
diff --git a/pact/pact-common/src/main/java/eu/stratosphere/pact/common/io/DelimitedInputFormat.java b/pact/pact-common/src/main/java/eu/stratosphere/pact/common/io/DelimitedInputFormat.java
index 005a26a..d7b95c0 100644
--- a/pact/pact-common/src/main/java/eu/stratosphere/pact/common/io/DelimitedInputFormat.java
+++ b/pact/pact-common/src/main/java/eu/stratosphere/pact/common/io/DelimitedInputFormat.java
@@ -67,6 +67,11 @@ public abstract class DelimitedInputFormat extends FileInputFormat {
 	 */
 	private static final int DEFAULT_MIN_NUM_SAMPLES;
 	
+	/**
+	 * The maximum size of a sample record before sampling is aborted. To catch cases where a wrong delimiter is given.
+	 */
+	private static final int MAX_SAMPLE_LEN;
+	
 	static {
 		int maxSamples = GlobalConfiguration.getInteger(PactConfigConstants.DELIMITED_FORMAT_MAX_LINE_SAMPLES_KEY,
 				PactConfigConstants.DEFAULT_DELIMITED_FORMAT_MAX_LINE_SAMPLES);
@@ -93,9 +98,19 @@ public abstract class DelimitedInputFormat extends FileInputFormat {
 		} else {
 			DEFAULT_MIN_NUM_SAMPLES = minSamples;
 		}
+		
+		int maxLen = GlobalConfiguration.getInteger(PactConfigConstants.DELIMITED_FORMAT_MAX_SAMPLE_LENGTH_KEY,
+				PactConfigConstants.DEFAULT_DELIMITED_FORMAT_MAX_SAMPLE_LEN);
+		if (maxLen <= 0) {
+			maxLen = PactConfigConstants.DEFAULT_DELIMITED_FORMAT_MAX_SAMPLE_LEN;
+			LOG.error("Invalid value for the maximum sample record length. Using defailt value of " + maxLen + '.');
+		} else if (maxLen < DEFAULT_READ_BUFFER_SIZE) {
+			maxLen = DEFAULT_READ_BUFFER_SIZE;
+			LOG.warn("Increasing maximum sample record length to size of the read buffer (" + maxLen + ").");
+		}
+		MAX_SAMPLE_LEN = maxLen;
 	}
 	
-	
 	// ------------------------------------- Config Keys ------------------------------------------
 	
 	/**
@@ -128,6 +143,7 @@ public abstract class DelimitedInputFormat extends FileInputFormat {
 	private byte[] currBuffer;
 	private int currOffset;
 	private int currLen;
+	private int lineLengthLimit = Integer.MAX_VALUE;
 
 	protected boolean overLimit;
 
@@ -149,36 +165,6 @@ public abstract class DelimitedInputFormat extends FileInputFormat {
 	 * @return returns whether the record was successfully deserialized
 	 */
 	public abstract boolean readRecord(PactRecord target, byte[] bytes, int offset, int numBytes);
-
-	// --------------------------------------------------------------------------------------------
-
-	/**
-	 * Gets the delimiter that defines the record boundaries.
-	 * 
-	 * @return The delimiter, as bytes.
-	 */
-	public byte[] getDelimiter() {
-		return this.delimiter;
-	}
-	
-	/**
-	 * Sets the size of the buffer to be used to find record boundaries. This method has only an effect, if it is called
-	 * before the input format is opened.
-	 * 
-	 * @param bufferSize The buffer size to use.
-	 */
-	public void setBufferSize(int bufferSize) {
-		this.bufferSize = bufferSize;
-	}
-	
-	/**
-	 * Gets the size of the buffer internally used to parse record boundaries.
-	 * 
-	 * @return The size of the parsing buffer.
-	 */
-	public int getBufferSize() {
-		return this.readBuffer == null ? 0: this.readBuffer.length;
-	}
 	
 	// --------------------------------------------------------------------------------------------
 	
@@ -272,12 +258,13 @@ public abstract class DelimitedInputFormat extends FileInputFormat {
 				throw new RuntimeException("Error: Invalid number of samples: " + numSamples);
 			}
 			
-			
-			final int delimiterLength = getDelimiter().length;
-			
+			// make sure that the sampling times out after a while if the file system does not answer in time
+			this.openTimeout = 10000;
 			// set a small read buffer size
-			this.bufferSize = 1024;
-
+			this.bufferSize = 4 * 1024;
+			// prevent overly large records, for example if we have an incorrectly configured delimiter
+			this.lineLengthLimit = MAX_SAMPLE_LEN;
+			
 			long offset = 0;
 			long totalNumBytes = 0;
 			long stepSize = stats.getTotalInputSize() / numSamples;
@@ -286,16 +273,18 @@ public abstract class DelimitedInputFormat extends FileInputFormat {
 			int samplesTaken = 0;
 
 			// take the samples
-			for (int sampleNum = 0; sampleNum < numSamples && fileNum < allFiles.size(); sampleNum++) {
+			while (samplesTaken < numSamples && fileNum < allFiles.size()) {
 				// make a split for the sample and use it to read a record
 				FileStatus file = allFiles.get(fileNum);
-				FileInputSplit split = new FileInputSplit(sampleNum, file.getPath(), offset, file.getLen() - offset, null);
+				FileInputSplit split = new FileInputSplit(0, file.getPath(), offset, file.getLen() - offset, null);
 
 				// we open the split, read one line, and take its length
 				try {
 					open(split);
-					readLine();
-					totalNumBytes += this.currLen + delimiterLength;
+					if (readLine()) {
+						totalNumBytes += this.currLen + this.delimiter.length;
+						samplesTaken++;
+					}
 				} finally {
 					// close the file stream, do not release the buffers
 					super.close();
@@ -351,6 +340,7 @@ public abstract class DelimitedInputFormat extends FileInputFormat {
 		}
 
 		this.readPos = 0;
+		this.limit = 0;
 		this.overLimit = false;
 		this.end = false;
 
@@ -400,7 +390,6 @@ public abstract class DelimitedInputFormat extends FileInputFormat {
 	public void close() throws IOException {
 		this.wrapBuffer = null;
 		this.readBuffer = null;
-		
 		super.close();
 	}
 
@@ -464,11 +453,17 @@ public abstract class DelimitedInputFormat extends FileInputFormat {
 				}
 			} else {
 				count = this.limit - startPos;
+				
+				// check against the maximum record length
+				if ( ((long) countInWrapBuffer) + count > this.lineLengthLimit) {
+					throw new IOException("The record length exceeded the maximum record length (" + 
+							this.lineLengthLimit + ").");
+				}
 
 				// buffer exhausted
-				while (this.wrapBuffer.length - countInWrapBuffer < count) {
+				if (this.wrapBuffer.length - countInWrapBuffer < count) {
 					// reallocate
-					byte[] tmp = new byte[this.wrapBuffer.length * 2];
+					byte[] tmp = new byte[Math.max(this.wrapBuffer.length * 2, countInWrapBuffer + count)];
 					System.arraycopy(this.wrapBuffer, 0, tmp, 0, countInWrapBuffer);
 					this.wrapBuffer = tmp;
 				}
diff --git a/pact/pact-common/src/main/java/eu/stratosphere/pact/generic/contract/BulkIteration.java b/pact/pact-common/src/main/java/eu/stratosphere/pact/generic/contract/BulkIteration.java
index 9c4567d..d3c4fbb 100644
--- a/pact/pact-common/src/main/java/eu/stratosphere/pact/generic/contract/BulkIteration.java
+++ b/pact/pact-common/src/main/java/eu/stratosphere/pact/generic/contract/BulkIteration.java
@@ -21,8 +21,8 @@ import eu.stratosphere.pact.generic.stub.AbstractStub;
 /**
  * 
  */
-public class BulkIteration extends SingleInputContract<AbstractStub>
-{
+public class BulkIteration extends SingleInputContract<AbstractStub> {
+	
 	private static String DEFAULT_NAME = "<Unnamed Bulk Iteration>";
 	
 	private Contract iterationResult;
@@ -121,8 +121,8 @@ public class BulkIteration extends SingleInputContract<AbstractStub>
 	 * Specialized contract to use as a recognizable place-holder for the input to the
 	 * step function when composing the nested data flow.
 	 */
-	public static final class PartialSolutionPlaceHolder extends Contract
-	{
+	public static final class PartialSolutionPlaceHolder extends Contract {
+		
 		private final BulkIteration containingIteration;
 		
 		private PartialSolutionPlaceHolder(BulkIteration container) {
diff --git a/pact/pact-common/src/main/java/eu/stratosphere/pact/generic/contract/WorksetIteration.java b/pact/pact-common/src/main/java/eu/stratosphere/pact/generic/contract/WorksetIteration.java
index 1026b18..2f14b55 100644
--- a/pact/pact-common/src/main/java/eu/stratosphere/pact/generic/contract/WorksetIteration.java
+++ b/pact/pact-common/src/main/java/eu/stratosphere/pact/generic/contract/WorksetIteration.java
@@ -26,8 +26,8 @@ import eu.stratosphere.pact.generic.stub.AbstractStub;
  * This class is a subclass of {@code DualInputContract}. The solution set is considered the first input, the
  * workset is considered the second input.
  */
-public class WorksetIteration extends DualInputContract<AbstractStub>
-{
+public class WorksetIteration extends DualInputContract<AbstractStub> {
+	
 	private final Contract solutionSetPlaceholder = new SolutionSetPlaceHolder(this);
 
 	private final Contract worksetPlaceholder = new WorksetPlaceHolder(this);
diff --git a/pact/pact-common/src/main/java/eu/stratosphere/pact/generic/io/DelimitedInputFormat.java b/pact/pact-common/src/main/java/eu/stratosphere/pact/generic/io/DelimitedInputFormat.java
index e1c6ec4..1f3eae8 100644
--- a/pact/pact-common/src/main/java/eu/stratosphere/pact/generic/io/DelimitedInputFormat.java
+++ b/pact/pact-common/src/main/java/eu/stratosphere/pact/generic/io/DelimitedInputFormat.java
@@ -152,6 +152,20 @@ public abstract class DelimitedInputFormat<OT> extends FileInputFormat<OT> {
 	
 	// --------------------------------------------------------------------------------------------
 	
+	byte[] getDelimiter() {
+		return this.delimiter;
+	}
+	
+	void setBufferSize(int size) {
+		this.bufferSize = size;
+	}
+	
+	int getBufferSize() {
+		return this.bufferSize;
+	}
+	
+	// --------------------------------------------------------------------------------------------
+	
 	/**
 	 * This function parses the given byte array which represents a serialized key/value
 	 * pair. The parsed content is then returned by setting the pair variables. If the
diff --git a/pact/pact-common/src/test/java/eu/stratosphere/pact/common/io/DelimitedInputFormatSamplingTest.java b/pact/pact-common/src/test/java/eu/stratosphere/pact/common/io/DelimitedInputFormatSamplingTest.java
deleted file mode 100644
index 79cfe16..0000000
--- a/pact/pact-common/src/test/java/eu/stratosphere/pact/common/io/DelimitedInputFormatSamplingTest.java
+++ /dev/null
@@ -1,280 +0,0 @@
-/***********************************************************************************************************************
- *
- * Copyright (C) 2010 by the Stratosphere project (http://stratosphere.eu)
- *
- * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with
- * the License. You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on
- * an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
- * specific language governing permissions and limitations under the License.
- *
- **********************************************************************************************************************/
-
-package eu.stratosphere.pact.common.io;
-
-import org.junit.Assert;
-import org.junit.BeforeClass;
-import org.junit.Test;
-
-import eu.stratosphere.nephele.configuration.Configuration;
-import eu.stratosphere.pact.common.io.statistics.BaseStatistics;
-import eu.stratosphere.pact.common.testutils.TestConfigUtils;
-import eu.stratosphere.pact.common.testutils.TestFileSystem;
-import eu.stratosphere.pact.common.testutils.TestFileUtils;
-import eu.stratosphere.pact.common.type.base.PactInteger;
-import eu.stratosphere.pact.common.util.PactConfigConstants;
-
-public class DelimitedInputFormatSamplingTest {
-	
-	private static final String TEST_DATA1 = 
-			"123456789\n" +
-			"123456789\n" +
-			"123456789\n" +
-			"123456789\n" +
-			"123456789\n" +
-			"123456789\n" +
-			"123456789\n" +
-			"123456789\n" +
-			"123456789\n" +
-			"123456789\n";
-	
-	private static final String TEST_DATA2 = 
-			"12345\n" +
-			"12345\n" +
-			"12345\n" +
-			"12345\n" +
-			"12345\n" +
-			"12345\n" +
-			"12345\n" +
-			"12345\n" +
-			"12345\n" +
-			"12345\n";
-			
-	private static final int TEST_DATA_1_LINES = TEST_DATA1.split("\n").length;
-	
-	private static final int TEST_DATA_1_LINEWIDTH = TEST_DATA1.split("\n")[0].length();
-	
-	private static final int TEST_DATA_2_LINEWIDTH = TEST_DATA2.split("\n")[0].length();
-	
-	private static final int TOTAL_SIZE = TEST_DATA1.length() + TEST_DATA2.length();
-	
-	private static final int DEFAULT_NUM_SAMPLES = 4;
-	
-	// ========================================================================
-	//  Setup
-	// ========================================================================
-	
-	@BeforeClass
-	public static void initialize() {
-		try {
-			TestFileSystem.registerTestFileSysten();
-		} catch (Throwable t) {
-			Assert.fail("Could not setup the mock test filesystem.");
-		}
-		
-		try {
-			// make sure we do 4 samples
-			TestConfigUtils.loadGlobalConf(
-				new String[] { PactConfigConstants.DELIMITED_FORMAT_MIN_LINE_SAMPLES_KEY,
-								PactConfigConstants.DELIMITED_FORMAT_MAX_LINE_SAMPLES_KEY },
-				new String[] { "4", "4" });
-		} catch (Throwable t) {
-			Assert.fail("Could not load the global configuration.");
-		}
-	}
-	
-	// ========================================================================
-	//  Tests
-	// ========================================================================
-	
-	@Test
-	public void testNumSamplesOneFile() {
-		try {
-			final String tempFile = TestFileUtils.createTempFile(TEST_DATA1);
-			final Configuration conf = new Configuration();
-			conf.setString(FileInputFormat.FILE_PARAMETER_KEY, "test://" + tempFile);
-			
-			final TestDelimitedInputFormat format = new TestDelimitedInputFormat();
-			format.configure(conf);
-			
-			TestFileSystem.resetStreamOpenCounter();
-			format.getStatistics(null);
-			Assert.assertEquals("Wrong number of samples taken.", DEFAULT_NUM_SAMPLES, TestFileSystem.getNumtimeStreamOpened());
-			
-			conf.setString(TestDelimitedInputFormat.NUM_STATISTICS_SAMPLES, "8");
-			final TestDelimitedInputFormat format2 = new TestDelimitedInputFormat();
-			format2.configure(conf);
-			
-			TestFileSystem.resetStreamOpenCounter();
-			format2.getStatistics(null);
-			Assert.assertEquals("Wrong number of samples taken.", 8, TestFileSystem.getNumtimeStreamOpened());
-			
-		} catch (Exception e) {
-			e.printStackTrace();
-			Assert.fail(e.getMessage());
-		}
-	}
-	
-	@Test
-	public void testNumSamplesMultipleFiles() {
-		try {
-			final String tempFile = TestFileUtils.createTempFileDir(TEST_DATA1, TEST_DATA1, TEST_DATA1, TEST_DATA1);
-			final Configuration conf = new Configuration();
-			conf.setString(FileInputFormat.FILE_PARAMETER_KEY, "test://" + tempFile);
-			
-			final TestDelimitedInputFormat format = new TestDelimitedInputFormat();
-			format.configure(conf);
-			
-			TestFileSystem.resetStreamOpenCounter();
-			format.getStatistics(null);
-			Assert.assertEquals("Wrong number of samples taken.", DEFAULT_NUM_SAMPLES, TestFileSystem.getNumtimeStreamOpened());
-			
-			conf.setString(TestDelimitedInputFormat.NUM_STATISTICS_SAMPLES, "8");
-			final TestDelimitedInputFormat format2 = new TestDelimitedInputFormat();
-			format2.configure(conf);
-			
-			TestFileSystem.resetStreamOpenCounter();
-			format2.getStatistics(null);
-			Assert.assertEquals("Wrong number of samples taken.", 8, TestFileSystem.getNumtimeStreamOpened());
-			
-		} catch (Exception e) {
-			e.printStackTrace();
-			Assert.fail(e.getMessage());
-		}
-	}
-	
-	@Test
-	public void testSamplingOneFile() {
-		try {
-			final String tempFile = TestFileUtils.createTempFile(TEST_DATA1);
-			final Configuration conf = new Configuration();
-			conf.setString(FileInputFormat.FILE_PARAMETER_KEY, "file://" + tempFile);
-			
-			final TestDelimitedInputFormat format = new TestDelimitedInputFormat();
-			format.configure(conf);
-			BaseStatistics stats = format.getStatistics(null);
-			
-			final int numLines = TEST_DATA_1_LINES;
-			final float avgWidth = ((float) TEST_DATA1.length()) / TEST_DATA_1_LINES;
-			Assert.assertTrue("Wrong record count.", stats.getNumberOfRecords() < numLines + 1 & stats.getNumberOfRecords() > numLines - 1);
-			Assert.assertTrue("Wrong avg record size.", stats.getAverageRecordWidth() < avgWidth + 1 & stats.getAverageRecordWidth() > avgWidth - 1);
-		} catch (Exception e) {
-			e.printStackTrace();
-			Assert.fail(e.getMessage());
-		}
-	}
-	
-	@Test
-	public void testSamplingDirectory() {
-		try {
-			final String tempFile = TestFileUtils.createTempFileDir(TEST_DATA1, TEST_DATA2);
-			final Configuration conf = new Configuration();
-			conf.setString(FileInputFormat.FILE_PARAMETER_KEY, "file://" + tempFile);
-			
-			final TestDelimitedInputFormat format = new TestDelimitedInputFormat();
-			format.configure(conf);
-			BaseStatistics stats = format.getStatistics(null);
-			
-			final int maxNumLines = (int) Math.ceil(TOTAL_SIZE / ((double) Math.min(TEST_DATA_1_LINEWIDTH, TEST_DATA_2_LINEWIDTH)));
-			final int minNumLines = (int) (TOTAL_SIZE / ((double) Math.max(TEST_DATA_1_LINEWIDTH, TEST_DATA_2_LINEWIDTH)));
-			final float maxAvgWidth = ((float) (TOTAL_SIZE)) / minNumLines;
-			final float minAvgWidth = ((float) (TOTAL_SIZE)) / maxNumLines;
-			
-			if (!(stats.getNumberOfRecords() <= maxNumLines  & stats.getNumberOfRecords() >= minNumLines)) {
-				System.err.println("Records: " + stats.getNumberOfRecords() + " out of (" + minNumLines + ", " + maxNumLines + ").");
-				Assert.fail("Wrong record count.");
-			}
-			if (!(stats.getAverageRecordWidth() <= maxAvgWidth & stats.getAverageRecordWidth() >= minAvgWidth)) {
-				Assert.fail("Wrong avg record size.");
-			}
-		} catch (Exception e) {
-			e.printStackTrace();
-			Assert.fail(e.getMessage());
-		}
-	}
-	
-	@Test
-	public void testDifferentDelimiter() {
-		try {
-			final String DELIMITER = "12345678-";
-			String testData = TEST_DATA1.replace("\n", DELIMITER);
-			
-			final String tempFile = TestFileUtils.createTempFile(testData);
-			final Configuration conf = new Configuration();
-			conf.setString(FileInputFormat.FILE_PARAMETER_KEY, "file://" + tempFile);
-			conf.setString(TestDelimitedInputFormat.RECORD_DELIMITER, DELIMITER);
-			
-			final TestDelimitedInputFormat format = new TestDelimitedInputFormat();
-			format.configure(conf);
-			
-			BaseStatistics stats = format.getStatistics(null);
-			final int numLines = TEST_DATA_1_LINES;
-			final float avgWidth = ((float) testData.length()) / TEST_DATA_1_LINES;
-			
-			Assert.assertTrue("Wrong record count.", stats.getNumberOfRecords() < numLines + 1 & stats.getNumberOfRecords() > numLines - 1);
-			Assert.assertTrue("Wrong avg record size.", stats.getAverageRecordWidth() < avgWidth + 1 & stats.getAverageRecordWidth() > avgWidth - 1);
-		} catch (Exception e) {
-			e.printStackTrace();
-			Assert.fail(e.getMessage());
-		}
-	}
-	
-	@Test
-	public void testSamplingOverlyLongRecord() {
-		try {
-			final String tempFile = TestFileUtils.createTempFile(2 * PactConfigConstants.DEFAULT_DELIMITED_FORMAT_MAX_SAMPLE_LEN);
-			final Configuration conf = new Configuration();
-			conf.setString(FileInputFormat.FILE_PARAMETER_KEY, "file://" + tempFile);
-			
-			final TestDelimitedInputFormat format = new TestDelimitedInputFormat();
-			format.configure(conf);
-			
-			Assert.assertNull("Expected exception due to overly long record.", format.getStatistics(null));
-		} catch (Exception e) {
-			e.printStackTrace();
-			Assert.fail(e.getMessage());
-		}
-	}
-	
-	@Test
-	public void testCachedStatistics() {
-		try {
-			final String tempFile = TestFileUtils.createTempFile(TEST_DATA1);
-			final Configuration conf = new Configuration();
-			conf.setString(FileInputFormat.FILE_PARAMETER_KEY, "test://" + tempFile);
-			
-			final TestDelimitedInputFormat format = new TestDelimitedInputFormat();
-			format.configure(conf);
-			
-			TestFileSystem.resetStreamOpenCounter();
-			BaseStatistics stats = format.getStatistics(null);
-			Assert.assertEquals("Wrong number of samples taken.", DEFAULT_NUM_SAMPLES, TestFileSystem.getNumtimeStreamOpened());
-			
-			final TestDelimitedInputFormat format2 = new TestDelimitedInputFormat();
-			format2.configure(conf);
-			
-			TestFileSystem.resetStreamOpenCounter();
-			BaseStatistics stats2 = format2.getStatistics(stats);
-			Assert.assertTrue("Using cached statistics should cicumvent sampling.", 0 == TestFileSystem.getNumtimeStreamOpened());
-			Assert.assertTrue("Using cached statistics should cicumvent sampling.", stats == stats2);
-			
-		} catch (Exception e) {
-			e.printStackTrace();
-			Assert.fail(e.getMessage());
-		}
-	}
-	
-	// ========================================================================
-	//  Mocks
-	// ========================================================================
-	
-	private static final class TestDelimitedInputFormat extends eu.stratosphere.pact.generic.io.DelimitedInputFormat<PactInteger> {
-		@Override
-		public boolean readRecord(PactInteger target, byte[] bytes, int offset, int numBytes) {
-			throw new UnsupportedOperationException();
-		}
-	}
-}
diff --git a/pact/pact-common/src/test/java/eu/stratosphere/pact/common/io/DelimitedInputFormatTest.java b/pact/pact-common/src/test/java/eu/stratosphere/pact/common/io/DelimitedInputFormatTest.java
deleted file mode 100644
index 9fcbb49..0000000
--- a/pact/pact-common/src/test/java/eu/stratosphere/pact/common/io/DelimitedInputFormatTest.java
+++ /dev/null
@@ -1,190 +0,0 @@
-/***********************************************************************************************************************
- *
- * Copyright (C) 2010 by the Stratosphere project (http://stratosphere.eu)
- *
- * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with
- * the License. You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on
- * an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
- * specific language governing permissions and limitations under the License.
- *
- **********************************************************************************************************************/
-
-package eu.stratosphere.pact.common.io;
-
-import static org.junit.Assert.assertEquals;
-import static org.junit.Assert.assertFalse;
-import static org.junit.Assert.assertTrue;
-import static org.mockito.Mockito.times;
-import static org.mockito.Mockito.verify;
-import static org.mockito.MockitoAnnotations.initMocks;
-import static org.powermock.api.mockito.PowerMockito.when;
-
-import java.io.File;
-import java.io.FileOutputStream;
-import java.io.IOException;
-import java.io.OutputStreamWriter;
-
-import org.junit.After;
-import org.junit.Before;
-import org.junit.Test;
-import org.junit.runner.RunWith;
-import org.mockito.Matchers;
-import org.mockito.Mock;
-import org.powermock.core.classloader.annotations.PowerMockIgnore;
-import org.powermock.modules.junit4.PowerMockRunner;
-
-import eu.stratosphere.nephele.configuration.Configuration;
-import eu.stratosphere.nephele.fs.FileInputSplit;
-import eu.stratosphere.nephele.fs.Path;
-import eu.stratosphere.pact.common.type.PactRecord;
-import eu.stratosphere.pact.common.type.base.PactString;
-
-@RunWith(PowerMockRunner.class)
-@PowerMockIgnore("org.apache.log4j.*")
-public class DelimitedInputFormatTest
-{
-	@Mock
-	protected Configuration config;
-	
-	protected File tempFile;
-	
-	private final DelimitedInputFormat format = new MyTextInputFormat();
-	
-	// --------------------------------------------------------------------------------------------
-	
-	@Before
-	public void setup() {
-		initMocks(this);
-	}
-	
-	@After
-	public void setdown() throws Exception {
-		if (this.format != null) {
-			this.format.close();
-		}
-		if (this.tempFile != null) {
-			this.tempFile.delete();
-		}
-	}
-
-	// --------------------------------------------------------------------------------------------
-	// --------------------------------------------------------------------------------------------
-	@Test
-	public void testConfigure() {
-		when(this.config.getString(Matchers.matches(DelimitedInputFormat.RECORD_DELIMITER), Matchers.anyString()))
-			.thenReturn("\n");
-		when(this.config.getString(Matchers.matches(FileInputFormat.FILE_PARAMETER_KEY), Matchers.anyString()))
-		.thenReturn("file:///some/file/that/will/not/be/read");
-		
-		format.configure(this.config);
-		verify(this.config, times(4)).getString(Matchers.any(String.class), Matchers.any(String.class));
-		assertEquals("\n", new String(format.getDelimiter()));
-
-		when(this.config.getString(Matchers.matches(DelimitedInputFormat.RECORD_DELIMITER), Matchers.anyString()))
-			.thenReturn("&-&");
-		format.configure(this.config);
-		verify(this.config, times(8)).getString(Matchers.any(String.class), Matchers.any(String.class));
-		assertEquals("&-&", new String(format.getDelimiter()));
-	}
-
-	@Test
-	public void testOpen() throws IOException {
-		final String myString = "my mocked line 1\nmy mocked line 2\n";
-		final FileInputSplit split = createTempFile(myString);	
-		
-		int bufferSize = 5;
-		format.setBufferSize(bufferSize);
-		format.open(split);
-		assertEquals(0, format.getSplitStart());
-		assertEquals(myString.length() - bufferSize, format.getSplitLength());
-		assertEquals(bufferSize, format.getBufferSize());
-	}
-
-	@Test
-	public void testRead() throws IOException {
-		final String myString = "my key|my val$$$my key2\n$$ctd.$$|my value2";
-		final FileInputSplit split = createTempFile(myString);
-		
-		final Configuration parameters = new Configuration();
-		parameters.setString(FileInputFormat.FILE_PARAMETER_KEY, "file:///some/file/that/will/not/be/read");
-		parameters.setString(DelimitedInputFormat.RECORD_DELIMITER, "$$$");
-		
-		format.configure(parameters);
-		format.open(split);
-		
-		PactRecord theRecord = new PactRecord();
-
-		assertTrue(format.nextRecord(theRecord));
-		assertEquals("my key", theRecord.getField(0, PactString.class).getValue());
-		assertEquals("my val", theRecord.getField(1, PactString.class).getValue());
-		
-		assertTrue(format.nextRecord(theRecord));
-		assertEquals("my key2\n$$ctd.$$", theRecord.getField(0, PactString.class).getValue());
-		assertEquals("my value2", theRecord.getField(1, PactString.class).getValue());
-		
-		assertFalse(format.nextRecord(theRecord));
-		assertTrue(format.reachedEnd());
-	}
-	
-	@Test
-	public void testRead2() throws IOException {
-		// 2. test case
-		final String myString = "my key|my val$$$my key2\n$$ctd.$$|my value2";
-		final FileInputSplit split = createTempFile(myString);
-		
-		final Configuration parameters = new Configuration();
-		parameters.setString(FileInputFormat.FILE_PARAMETER_KEY, "file:///some/file/that/will/not/be/read");
-		parameters.setString(DelimitedInputFormat.RECORD_DELIMITER, "\n");
-		
-		
-		format.configure(parameters);
-		format.open(split);
-
-		PactRecord theRecord = new PactRecord();
-
-		assertTrue(format.nextRecord(theRecord));
-		assertEquals("my key", theRecord.getField(0, PactString.class).getValue());
-		assertEquals("my val$$$my key2", theRecord.getField(1, PactString.class).getValue());
-		
-		assertTrue(format.nextRecord(theRecord));
-		assertEquals("$$ctd.$$", theRecord.getField(0, PactString.class).getValue());
-		assertEquals("my value2", theRecord.getField(1, PactString.class).getValue());
-		
-		assertFalse(format.nextRecord(theRecord));
-		assertTrue(format.reachedEnd());
-	}
-	
-	private FileInputSplit createTempFile(String contents) throws IOException {
-		this.tempFile = File.createTempFile("test_contents", "tmp");
-		OutputStreamWriter wrt = new OutputStreamWriter(new FileOutputStream(this.tempFile));
-		wrt.write(contents);
-		wrt.close();
-		
-		return new FileInputSplit(0, new Path("file://" + this.tempFile.getAbsolutePath()), 0, this.tempFile.length(), new String[] {"localhost"});
-	}
-	
-	protected static final class MyTextInputFormat extends DelimitedInputFormat {
-		
-		private final PactString str1 = new PactString();
-		private final PactString str2 = new PactString();
-		
-		/* (non-Javadoc)
-		 * @see eu.stratosphere.pact.common.io.DelimitedInputFormat#readRecord(eu.stratosphere.pact.common.type.PactRecord, byte[], int)
-		 */
-		@Override
-		public boolean readRecord(PactRecord target, byte[] bytes, int offset, int numBytes) {
-			String theRecord = new String(bytes, offset, numBytes);
-			
-			str1.setValue(theRecord.substring(0, theRecord.indexOf('|')));
-			str2.setValue(theRecord.substring(theRecord.indexOf('|') + 1));
-			
-			target.setField(0, str1);
-			target.setField(1, str2);
-			return true;
-		}
-	}
-}
diff --git a/pact/pact-common/src/test/java/eu/stratosphere/pact/common/io/FileInputFormatTest.java b/pact/pact-common/src/test/java/eu/stratosphere/pact/common/io/FileInputFormatTest.java
deleted file mode 100644
index ba2ca6f..0000000
--- a/pact/pact-common/src/test/java/eu/stratosphere/pact/common/io/FileInputFormatTest.java
+++ /dev/null
@@ -1,179 +0,0 @@
-/***********************************************************************************************************************
- *
- * Copyright (C) 2012 by the Stratosphere project (http://stratosphere.eu)
- *
- * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with
- * the License. You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on
- * an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
- * specific language governing permissions and limitations under the License.
- *
- **********************************************************************************************************************/
-package eu.stratosphere.pact.common.io;
-
-import java.io.IOException;
-
-import junit.framework.Assert;
-
-import org.junit.Test;
-
-import eu.stratosphere.nephele.configuration.Configuration;
-import eu.stratosphere.pact.common.io.statistics.BaseStatistics;
-import eu.stratosphere.pact.common.testutils.TestFileUtils;
-import eu.stratosphere.pact.common.type.base.PactInteger;
-import eu.stratosphere.pact.generic.io.FileInputFormat;
-import eu.stratosphere.pact.generic.io.FileInputFormat.FileBaseStatistics;
-
-public class FileInputFormatTest { 
-
-	@Test
-	public void testGetStatisticsNonExistingFile() {
-		try {
-			final Configuration config = new Configuration();
-			config.setString(FileInputFormat.FILE_PARAMETER_KEY, "file:///some/none/existing/directory/");
-			final DummyFileInputFormat format = new DummyFileInputFormat();
-			format.configure(config);
-			
-			BaseStatistics stats = format.getStatistics(null);
-			Assert.assertNull("The file statistics should be null.", stats);
-		} catch (Exception ex) {
-			ex.printStackTrace();
-			Assert.fail(ex.getMessage());
-		}
-	}
-	
-	@Test
-	public void testGetStatisticsOneFileNoCachedVersion() {
-		try {
-			final long SIZE = 1024 * 500;
-			final Configuration config = TestFileUtils.getConfigForFile(SIZE);
-			
-			final DummyFileInputFormat format = new DummyFileInputFormat();
-			format.configure(config);
-			
-			BaseStatistics stats = format.getStatistics(null);
-			Assert.assertEquals("The file size from the statistics is wrong.", SIZE, stats.getTotalInputSize());
-		} catch (Exception ex) {
-			ex.printStackTrace();
-			Assert.fail(ex.getMessage());
-		}
-	}
-	
-	@Test
-	public void testGetStatisticsMultipleFilesNoCachedVersion() {
-		try {
-			final long SIZE1 = 2077;
-			final long SIZE2 = 31909;
-			final long SIZE3 = 10;
-			final long TOTAL = SIZE1 + SIZE2 + SIZE3;
-			
-			final Configuration config = TestFileUtils.getConfigForDir(SIZE1, SIZE2, SIZE3);
-			
-			final DummyFileInputFormat format = new DummyFileInputFormat();
-			format.configure(config);
-			
-			BaseStatistics stats = format.getStatistics(null);
-			Assert.assertEquals("The file size from the statistics is wrong.", TOTAL, stats.getTotalInputSize());
-		} catch (Exception ex) {
-			ex.printStackTrace();
-			Assert.fail(ex.getMessage());
-		}
-	}
-	
-	@Test
-	public void testGetStatisticsOneFileWithCachedVersion() {
-		try {
-			final long SIZE = 50873;
-			final long FAKE_SIZE = 10065;
-			
-			final Configuration config = TestFileUtils.getConfigForFile(SIZE);
-			
-			DummyFileInputFormat format = new DummyFileInputFormat();
-			format.configure(config);
-			FileBaseStatistics stats = format.getStatistics(null);
-			Assert.assertEquals("The file size from the statistics is wrong.", SIZE, stats.getTotalInputSize());
-			
-			format = new DummyFileInputFormat();
-			format.configure(config);
-			FileBaseStatistics newStats = format.getStatistics(stats);
-			Assert.assertTrue("Statistics object was changed", newStats == stats);
-
-			// insert fake stats with the correct modification time. the call should return the fake stats
-			format = new DummyFileInputFormat();
-			format.configure(config);
-			FileBaseStatistics fakeStats = new FileBaseStatistics(stats.getLastModificationTime(), FAKE_SIZE, BaseStatistics.AVG_RECORD_BYTES_UNKNOWN);
-			BaseStatistics latest = format.getStatistics(fakeStats);
-			Assert.assertEquals("The file size from the statistics is wrong.", FAKE_SIZE, latest.getTotalInputSize());
-			
-			// insert fake stats with the correct modification time. the call should return the fake stats
-			format = new DummyFileInputFormat();
-			format.configure(config);
-			FileBaseStatistics outDatedFakeStats = new FileBaseStatistics(stats.getLastModificationTime()-1, FAKE_SIZE, BaseStatistics.AVG_RECORD_BYTES_UNKNOWN);
-			BaseStatistics reGathered = format.getStatistics(outDatedFakeStats);
-			Assert.assertEquals("The file size from the statistics is wrong.", SIZE, reGathered.getTotalInputSize());
-			
-		} catch (Exception ex) {
-			ex.printStackTrace();
-			Assert.fail(ex.getMessage());
-		}
-	}
-	
-	@Test
-	public void testGetStatisticsMultipleFilesWithCachedVersion() {
-		try {
-			final long SIZE1 = 2077;
-			final long SIZE2 = 31909;
-			final long SIZE3 = 10;
-			final long TOTAL = SIZE1 + SIZE2 + SIZE3;
-			final long FAKE_SIZE = 10065;
-			
-			final Configuration config = TestFileUtils.getConfigForDir(SIZE1, SIZE2, SIZE3);
-			
-			DummyFileInputFormat format = new DummyFileInputFormat();
-			format.configure(config);
-			FileBaseStatistics stats = format.getStatistics(null);
-			Assert.assertEquals("The file size from the statistics is wrong.", TOTAL, stats.getTotalInputSize());
-			
-			format = new DummyFileInputFormat();
-			format.configure(config);
-			FileBaseStatistics newStats = format.getStatistics(stats);
-			Assert.assertTrue("Statistics object was changed", newStats == stats);
-
-			// insert fake stats with the correct modification time. the call should return the fake stats
-			format = new DummyFileInputFormat();
-			format.configure(config);
-			FileBaseStatistics fakeStats = new FileBaseStatistics(stats.getLastModificationTime(), FAKE_SIZE, BaseStatistics.AVG_RECORD_BYTES_UNKNOWN);
-			BaseStatistics latest = format.getStatistics(fakeStats);
-			Assert.assertEquals("The file size from the statistics is wrong.", FAKE_SIZE, latest.getTotalInputSize());
-			
-			// insert fake stats with the correct modification time. the call should return the fake stats
-			format = new DummyFileInputFormat();
-			format.configure(config);
-			FileBaseStatistics outDatedFakeStats = new FileBaseStatistics(stats.getLastModificationTime()-1, FAKE_SIZE, BaseStatistics.AVG_RECORD_BYTES_UNKNOWN);
-			BaseStatistics reGathered = format.getStatistics(outDatedFakeStats);
-			Assert.assertEquals("The file size from the statistics is wrong.", TOTAL, reGathered.getTotalInputSize());
-			
-		} catch (Exception ex) {
-			ex.printStackTrace();
-			Assert.fail(ex.getMessage());
-		}
-	}
-	
-	// ------------------------------------------------------------------------
-	
-	private class DummyFileInputFormat extends FileInputFormat<PactInteger> {
-
-		@Override
-		public boolean reachedEnd() throws IOException {
-			return true;
-		}
-
-		@Override
-		public boolean nextRecord(PactInteger record) throws IOException {
-			return false;
-		}
-	}
-}
diff --git a/pact/pact-common/src/test/java/eu/stratosphere/pact/generic/io/DelimitedInputFormatSamplingTest.java b/pact/pact-common/src/test/java/eu/stratosphere/pact/generic/io/DelimitedInputFormatSamplingTest.java
new file mode 100644
index 0000000..7a4da53
--- /dev/null
+++ b/pact/pact-common/src/test/java/eu/stratosphere/pact/generic/io/DelimitedInputFormatSamplingTest.java
@@ -0,0 +1,281 @@
+/***********************************************************************************************************************
+ *
+ * Copyright (C) 2010 by the Stratosphere project (http://stratosphere.eu)
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on
+ * an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
+ * specific language governing permissions and limitations under the License.
+ *
+ **********************************************************************************************************************/
+
+package eu.stratosphere.pact.generic.io;
+
+import org.junit.Assert;
+import org.junit.BeforeClass;
+import org.junit.Test;
+
+import eu.stratosphere.nephele.configuration.Configuration;
+import eu.stratosphere.pact.common.io.FileInputFormat;
+import eu.stratosphere.pact.common.io.statistics.BaseStatistics;
+import eu.stratosphere.pact.common.testutils.TestConfigUtils;
+import eu.stratosphere.pact.common.testutils.TestFileSystem;
+import eu.stratosphere.pact.common.testutils.TestFileUtils;
+import eu.stratosphere.pact.common.type.base.PactInteger;
+import eu.stratosphere.pact.common.util.PactConfigConstants;
+
+public class DelimitedInputFormatSamplingTest {
+	
+	private static final String TEST_DATA1 = 
+			"123456789\n" +
+			"123456789\n" +
+			"123456789\n" +
+			"123456789\n" +
+			"123456789\n" +
+			"123456789\n" +
+			"123456789\n" +
+			"123456789\n" +
+			"123456789\n" +
+			"123456789\n";
+	
+	private static final String TEST_DATA2 = 
+			"12345\n" +
+			"12345\n" +
+			"12345\n" +
+			"12345\n" +
+			"12345\n" +
+			"12345\n" +
+			"12345\n" +
+			"12345\n" +
+			"12345\n" +
+			"12345\n";
+			
+	private static final int TEST_DATA_1_LINES = TEST_DATA1.split("\n").length;
+	
+	private static final int TEST_DATA_1_LINEWIDTH = TEST_DATA1.split("\n")[0].length();
+	
+	private static final int TEST_DATA_2_LINEWIDTH = TEST_DATA2.split("\n")[0].length();
+	
+	private static final int TOTAL_SIZE = TEST_DATA1.length() + TEST_DATA2.length();
+	
+	private static final int DEFAULT_NUM_SAMPLES = 4;
+	
+	// ========================================================================
+	//  Setup
+	// ========================================================================
+	
+	@BeforeClass
+	public static void initialize() {
+		try {
+			TestFileSystem.registerTestFileSysten();
+		} catch (Throwable t) {
+			Assert.fail("Could not setup the mock test filesystem.");
+		}
+		
+		try {
+			// make sure we do 4 samples
+			TestConfigUtils.loadGlobalConf(
+				new String[] { PactConfigConstants.DELIMITED_FORMAT_MIN_LINE_SAMPLES_KEY,
+								PactConfigConstants.DELIMITED_FORMAT_MAX_LINE_SAMPLES_KEY },
+				new String[] { "4", "4" });
+		} catch (Throwable t) {
+			Assert.fail("Could not load the global configuration.");
+		}
+	}
+	
+	// ========================================================================
+	//  Tests
+	// ========================================================================
+	
+	@Test
+	public void testNumSamplesOneFile() {
+		try {
+			final String tempFile = TestFileUtils.createTempFile(TEST_DATA1);
+			final Configuration conf = new Configuration();
+			conf.setString(FileInputFormat.FILE_PARAMETER_KEY, "test://" + tempFile);
+			
+			final TestDelimitedInputFormat format = new TestDelimitedInputFormat();
+			format.configure(conf);
+			
+			TestFileSystem.resetStreamOpenCounter();
+			format.getStatistics(null);
+			Assert.assertEquals("Wrong number of samples taken.", DEFAULT_NUM_SAMPLES, TestFileSystem.getNumtimeStreamOpened());
+			
+			conf.setString(TestDelimitedInputFormat.NUM_STATISTICS_SAMPLES, "8");
+			final TestDelimitedInputFormat format2 = new TestDelimitedInputFormat();
+			format2.configure(conf);
+			
+			TestFileSystem.resetStreamOpenCounter();
+			format2.getStatistics(null);
+			Assert.assertEquals("Wrong number of samples taken.", 8, TestFileSystem.getNumtimeStreamOpened());
+			
+		} catch (Exception e) {
+			e.printStackTrace();
+			Assert.fail(e.getMessage());
+		}
+	}
+	
+	@Test
+	public void testNumSamplesMultipleFiles() {
+		try {
+			final String tempFile = TestFileUtils.createTempFileDir(TEST_DATA1, TEST_DATA1, TEST_DATA1, TEST_DATA1);
+			final Configuration conf = new Configuration();
+			conf.setString(FileInputFormat.FILE_PARAMETER_KEY, "test://" + tempFile);
+			
+			final TestDelimitedInputFormat format = new TestDelimitedInputFormat();
+			format.configure(conf);
+			
+			TestFileSystem.resetStreamOpenCounter();
+			format.getStatistics(null);
+			Assert.assertEquals("Wrong number of samples taken.", DEFAULT_NUM_SAMPLES, TestFileSystem.getNumtimeStreamOpened());
+			
+			conf.setString(TestDelimitedInputFormat.NUM_STATISTICS_SAMPLES, "8");
+			final TestDelimitedInputFormat format2 = new TestDelimitedInputFormat();
+			format2.configure(conf);
+			
+			TestFileSystem.resetStreamOpenCounter();
+			format2.getStatistics(null);
+			Assert.assertEquals("Wrong number of samples taken.", 8, TestFileSystem.getNumtimeStreamOpened());
+			
+		} catch (Exception e) {
+			e.printStackTrace();
+			Assert.fail(e.getMessage());
+		}
+	}
+	
+	@Test
+	public void testSamplingOneFile() {
+		try {
+			final String tempFile = TestFileUtils.createTempFile(TEST_DATA1);
+			final Configuration conf = new Configuration();
+			conf.setString(FileInputFormat.FILE_PARAMETER_KEY, "file://" + tempFile);
+			
+			final TestDelimitedInputFormat format = new TestDelimitedInputFormat();
+			format.configure(conf);
+			BaseStatistics stats = format.getStatistics(null);
+			
+			final int numLines = TEST_DATA_1_LINES;
+			final float avgWidth = ((float) TEST_DATA1.length()) / TEST_DATA_1_LINES;
+			Assert.assertTrue("Wrong record count.", stats.getNumberOfRecords() < numLines + 1 & stats.getNumberOfRecords() > numLines - 1);
+			Assert.assertTrue("Wrong avg record size.", stats.getAverageRecordWidth() < avgWidth + 1 & stats.getAverageRecordWidth() > avgWidth - 1);
+		} catch (Exception e) {
+			e.printStackTrace();
+			Assert.fail(e.getMessage());
+		}
+	}
+	
+	@Test
+	public void testSamplingDirectory() {
+		try {
+			final String tempFile = TestFileUtils.createTempFileDir(TEST_DATA1, TEST_DATA2);
+			final Configuration conf = new Configuration();
+			conf.setString(FileInputFormat.FILE_PARAMETER_KEY, "file://" + tempFile);
+			
+			final TestDelimitedInputFormat format = new TestDelimitedInputFormat();
+			format.configure(conf);
+			BaseStatistics stats = format.getStatistics(null);
+			
+			final int maxNumLines = (int) Math.ceil(TOTAL_SIZE / ((double) Math.min(TEST_DATA_1_LINEWIDTH, TEST_DATA_2_LINEWIDTH)));
+			final int minNumLines = (int) (TOTAL_SIZE / ((double) Math.max(TEST_DATA_1_LINEWIDTH, TEST_DATA_2_LINEWIDTH)));
+			final float maxAvgWidth = ((float) (TOTAL_SIZE)) / minNumLines;
+			final float minAvgWidth = ((float) (TOTAL_SIZE)) / maxNumLines;
+			
+			if (!(stats.getNumberOfRecords() <= maxNumLines  & stats.getNumberOfRecords() >= minNumLines)) {
+				System.err.println("Records: " + stats.getNumberOfRecords() + " out of (" + minNumLines + ", " + maxNumLines + ").");
+				Assert.fail("Wrong record count.");
+			}
+			if (!(stats.getAverageRecordWidth() <= maxAvgWidth & stats.getAverageRecordWidth() >= minAvgWidth)) {
+				Assert.fail("Wrong avg record size.");
+			}
+		} catch (Exception e) {
+			e.printStackTrace();
+			Assert.fail(e.getMessage());
+		}
+	}
+	
+	@Test
+	public void testDifferentDelimiter() {
+		try {
+			final String DELIMITER = "12345678-";
+			String testData = TEST_DATA1.replace("\n", DELIMITER);
+			
+			final String tempFile = TestFileUtils.createTempFile(testData);
+			final Configuration conf = new Configuration();
+			conf.setString(FileInputFormat.FILE_PARAMETER_KEY, "file://" + tempFile);
+			conf.setString(TestDelimitedInputFormat.RECORD_DELIMITER, DELIMITER);
+			
+			final TestDelimitedInputFormat format = new TestDelimitedInputFormat();
+			format.configure(conf);
+			
+			BaseStatistics stats = format.getStatistics(null);
+			final int numLines = TEST_DATA_1_LINES;
+			final float avgWidth = ((float) testData.length()) / TEST_DATA_1_LINES;
+			
+			Assert.assertTrue("Wrong record count.", stats.getNumberOfRecords() < numLines + 1 & stats.getNumberOfRecords() > numLines - 1);
+			Assert.assertTrue("Wrong avg record size.", stats.getAverageRecordWidth() < avgWidth + 1 & stats.getAverageRecordWidth() > avgWidth - 1);
+		} catch (Exception e) {
+			e.printStackTrace();
+			Assert.fail(e.getMessage());
+		}
+	}
+	
+	@Test
+	public void testSamplingOverlyLongRecord() {
+		try {
+			final String tempFile = TestFileUtils.createTempFile(2 * PactConfigConstants.DEFAULT_DELIMITED_FORMAT_MAX_SAMPLE_LEN);
+			final Configuration conf = new Configuration();
+			conf.setString(FileInputFormat.FILE_PARAMETER_KEY, "file://" + tempFile);
+			
+			final TestDelimitedInputFormat format = new TestDelimitedInputFormat();
+			format.configure(conf);
+			
+			Assert.assertNull("Expected exception due to overly long record.", format.getStatistics(null));
+		} catch (Exception e) {
+			e.printStackTrace();
+			Assert.fail(e.getMessage());
+		}
+	}
+	
+	@Test
+	public void testCachedStatistics() {
+		try {
+			final String tempFile = TestFileUtils.createTempFile(TEST_DATA1);
+			final Configuration conf = new Configuration();
+			conf.setString(FileInputFormat.FILE_PARAMETER_KEY, "test://" + tempFile);
+			
+			final TestDelimitedInputFormat format = new TestDelimitedInputFormat();
+			format.configure(conf);
+			
+			TestFileSystem.resetStreamOpenCounter();
+			BaseStatistics stats = format.getStatistics(null);
+			Assert.assertEquals("Wrong number of samples taken.", DEFAULT_NUM_SAMPLES, TestFileSystem.getNumtimeStreamOpened());
+			
+			final TestDelimitedInputFormat format2 = new TestDelimitedInputFormat();
+			format2.configure(conf);
+			
+			TestFileSystem.resetStreamOpenCounter();
+			BaseStatistics stats2 = format2.getStatistics(stats);
+			Assert.assertTrue("Using cached statistics should cicumvent sampling.", 0 == TestFileSystem.getNumtimeStreamOpened());
+			Assert.assertTrue("Using cached statistics should cicumvent sampling.", stats == stats2);
+			
+		} catch (Exception e) {
+			e.printStackTrace();
+			Assert.fail(e.getMessage());
+		}
+	}
+	
+	// ========================================================================
+	//  Mocks
+	// ========================================================================
+	
+	private static final class TestDelimitedInputFormat extends eu.stratosphere.pact.generic.io.DelimitedInputFormat<PactInteger> {
+		@Override
+		public boolean readRecord(PactInteger target, byte[] bytes, int offset, int numBytes) {
+			throw new UnsupportedOperationException();
+		}
+	}
+}
diff --git a/pact/pact-common/src/test/java/eu/stratosphere/pact/generic/io/DelimitedInputFormatTest.java b/pact/pact-common/src/test/java/eu/stratosphere/pact/generic/io/DelimitedInputFormatTest.java
new file mode 100644
index 0000000..f549eac
--- /dev/null
+++ b/pact/pact-common/src/test/java/eu/stratosphere/pact/generic/io/DelimitedInputFormatTest.java
@@ -0,0 +1,190 @@
+/***********************************************************************************************************************
+ *
+ * Copyright (C) 2010 by the Stratosphere project (http://stratosphere.eu)
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on
+ * an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
+ * specific language governing permissions and limitations under the License.
+ *
+ **********************************************************************************************************************/
+
+package eu.stratosphere.pact.generic.io;
+
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertFalse;
+import static org.junit.Assert.assertTrue;
+import static org.mockito.Mockito.times;
+import static org.mockito.Mockito.verify;
+import static org.mockito.MockitoAnnotations.initMocks;
+import static org.powermock.api.mockito.PowerMockito.when;
+
+import java.io.File;
+import java.io.FileOutputStream;
+import java.io.IOException;
+import java.io.OutputStreamWriter;
+
+import org.junit.After;
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.mockito.Matchers;
+import org.mockito.Mock;
+import org.powermock.core.classloader.annotations.PowerMockIgnore;
+import org.powermock.modules.junit4.PowerMockRunner;
+
+import eu.stratosphere.nephele.configuration.Configuration;
+import eu.stratosphere.nephele.fs.FileInputSplit;
+import eu.stratosphere.nephele.fs.Path;
+import eu.stratosphere.pact.common.type.PactRecord;
+import eu.stratosphere.pact.common.type.base.PactString;
+
+@RunWith(PowerMockRunner.class)
+@PowerMockIgnore("org.apache.log4j.*")
+public class DelimitedInputFormatTest {
+	
+	@Mock
+	protected Configuration config;
+	
+	protected File tempFile;
+	
+	private final DelimitedInputFormat<PactRecord> format = new MyTextInputFormat();
+	
+	// --------------------------------------------------------------------------------------------
+	
+	@Before
+	public void setup() {
+		initMocks(this);
+	}
+	
+	@After
+	public void setdown() throws Exception {
+		if (this.format != null) {
+			this.format.close();
+		}
+		if (this.tempFile != null) {
+			this.tempFile.delete();
+		}
+	}
+
+	// --------------------------------------------------------------------------------------------
+	// --------------------------------------------------------------------------------------------
+	@Test
+	public void testConfigure() {
+		when(this.config.getString(Matchers.matches(DelimitedInputFormat.RECORD_DELIMITER), Matchers.anyString()))
+			.thenReturn("\n");
+		when(this.config.getString(Matchers.matches(FileInputFormat.FILE_PARAMETER_KEY), Matchers.anyString()))
+		.thenReturn("file:///some/file/that/will/not/be/read");
+		
+		format.configure(this.config);
+		verify(this.config, times(4)).getString(Matchers.any(String.class), Matchers.any(String.class));
+		assertEquals("\n", new String(format.getDelimiter()));
+
+		when(this.config.getString(Matchers.matches(DelimitedInputFormat.RECORD_DELIMITER), Matchers.anyString()))
+			.thenReturn("&-&");
+		format.configure(this.config);
+		verify(this.config, times(8)).getString(Matchers.any(String.class), Matchers.any(String.class));
+		assertEquals("&-&", new String(format.getDelimiter()));
+	}
+
+	@Test
+	public void testOpen() throws IOException {
+		final String myString = "my mocked line 1\nmy mocked line 2\n";
+		final FileInputSplit split = createTempFile(myString);	
+		
+		int bufferSize = 5;
+		format.setBufferSize(bufferSize);
+		format.open(split);
+		assertEquals(0, format.getSplitStart());
+		assertEquals(myString.length() - bufferSize, format.getSplitLength());
+		assertEquals(bufferSize, format.getBufferSize());
+	}
+
+	@Test
+	public void testRead() throws IOException {
+		final String myString = "my key|my val$$$my key2\n$$ctd.$$|my value2";
+		final FileInputSplit split = createTempFile(myString);
+		
+		final Configuration parameters = new Configuration();
+		parameters.setString(FileInputFormat.FILE_PARAMETER_KEY, "file:///some/file/that/will/not/be/read");
+		parameters.setString(DelimitedInputFormat.RECORD_DELIMITER, "$$$");
+		
+		format.configure(parameters);
+		format.open(split);
+		
+		PactRecord theRecord = new PactRecord();
+
+		assertTrue(format.nextRecord(theRecord));
+		assertEquals("my key", theRecord.getField(0, PactString.class).getValue());
+		assertEquals("my val", theRecord.getField(1, PactString.class).getValue());
+		
+		assertTrue(format.nextRecord(theRecord));
+		assertEquals("my key2\n$$ctd.$$", theRecord.getField(0, PactString.class).getValue());
+		assertEquals("my value2", theRecord.getField(1, PactString.class).getValue());
+		
+		assertFalse(format.nextRecord(theRecord));
+		assertTrue(format.reachedEnd());
+	}
+	
+	@Test
+	public void testRead2() throws IOException {
+		// 2. test case
+		final String myString = "my key|my val$$$my key2\n$$ctd.$$|my value2";
+		final FileInputSplit split = createTempFile(myString);
+		
+		final Configuration parameters = new Configuration();
+		parameters.setString(FileInputFormat.FILE_PARAMETER_KEY, "file:///some/file/that/will/not/be/read");
+		parameters.setString(DelimitedInputFormat.RECORD_DELIMITER, "\n");
+		
+		
+		format.configure(parameters);
+		format.open(split);
+
+		PactRecord theRecord = new PactRecord();
+
+		assertTrue(format.nextRecord(theRecord));
+		assertEquals("my key", theRecord.getField(0, PactString.class).getValue());
+		assertEquals("my val$$$my key2", theRecord.getField(1, PactString.class).getValue());
+		
+		assertTrue(format.nextRecord(theRecord));
+		assertEquals("$$ctd.$$", theRecord.getField(0, PactString.class).getValue());
+		assertEquals("my value2", theRecord.getField(1, PactString.class).getValue());
+		
+		assertFalse(format.nextRecord(theRecord));
+		assertTrue(format.reachedEnd());
+	}
+	
+	private FileInputSplit createTempFile(String contents) throws IOException {
+		this.tempFile = File.createTempFile("test_contents", "tmp");
+		OutputStreamWriter wrt = new OutputStreamWriter(new FileOutputStream(this.tempFile));
+		wrt.write(contents);
+		wrt.close();
+		
+		return new FileInputSplit(0, new Path("file://" + this.tempFile.getAbsolutePath()), 0, this.tempFile.length(), new String[] {"localhost"});
+	}
+	
+	protected static final class MyTextInputFormat extends eu.stratosphere.pact.generic.io.DelimitedInputFormat<PactRecord> {
+		
+		private final PactString str1 = new PactString();
+		private final PactString str2 = new PactString();
+		
+		/* (non-Javadoc)
+		 * @see eu.stratosphere.pact.common.io.DelimitedInputFormat#readRecord(eu.stratosphere.pact.common.type.PactRecord, byte[], int)
+		 */
+		@Override
+		public boolean readRecord(PactRecord target, byte[] bytes, int offset, int numBytes) {
+			String theRecord = new String(bytes, offset, numBytes);
+			
+			str1.setValue(theRecord.substring(0, theRecord.indexOf('|')));
+			str2.setValue(theRecord.substring(theRecord.indexOf('|') + 1));
+			
+			target.setField(0, str1);
+			target.setField(1, str2);
+			return true;
+		}
+	}
+}
diff --git a/pact/pact-common/src/test/java/eu/stratosphere/pact/generic/io/FileInputFormatTest.java b/pact/pact-common/src/test/java/eu/stratosphere/pact/generic/io/FileInputFormatTest.java
new file mode 100644
index 0000000..f27f889
--- /dev/null
+++ b/pact/pact-common/src/test/java/eu/stratosphere/pact/generic/io/FileInputFormatTest.java
@@ -0,0 +1,177 @@
+/***********************************************************************************************************************
+ *
+ * Copyright (C) 2012 by the Stratosphere project (http://stratosphere.eu)
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on
+ * an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
+ * specific language governing permissions and limitations under the License.
+ *
+ **********************************************************************************************************************/
+package eu.stratosphere.pact.generic.io;
+
+import java.io.IOException;
+
+import org.junit.Assert;
+import org.junit.Test;
+
+import eu.stratosphere.nephele.configuration.Configuration;
+import eu.stratosphere.pact.common.io.statistics.BaseStatistics;
+import eu.stratosphere.pact.common.testutils.TestFileUtils;
+import eu.stratosphere.pact.common.type.base.PactInteger;
+import eu.stratosphere.pact.generic.io.FileInputFormat.FileBaseStatistics;
+
+public class FileInputFormatTest { 
+
+	@Test
+	public void testGetStatisticsNonExistingFile() {
+		try {
+			final Configuration config = new Configuration();
+			config.setString(FileInputFormat.FILE_PARAMETER_KEY, "file:///some/none/existing/directory/");
+			final DummyFileInputFormat format = new DummyFileInputFormat();
+			format.configure(config);
+			
+			BaseStatistics stats = format.getStatistics(null);
+			Assert.assertNull("The file statistics should be null.", stats);
+		} catch (Exception ex) {
+			ex.printStackTrace();
+			Assert.fail(ex.getMessage());
+		}
+	}
+	
+	@Test
+	public void testGetStatisticsOneFileNoCachedVersion() {
+		try {
+			final long SIZE = 1024 * 500;
+			final Configuration config = TestFileUtils.getConfigForFile(SIZE);
+			
+			final DummyFileInputFormat format = new DummyFileInputFormat();
+			format.configure(config);
+			
+			BaseStatistics stats = format.getStatistics(null);
+			Assert.assertEquals("The file size from the statistics is wrong.", SIZE, stats.getTotalInputSize());
+		} catch (Exception ex) {
+			ex.printStackTrace();
+			Assert.fail(ex.getMessage());
+		}
+	}
+	
+	@Test
+	public void testGetStatisticsMultipleFilesNoCachedVersion() {
+		try {
+			final long SIZE1 = 2077;
+			final long SIZE2 = 31909;
+			final long SIZE3 = 10;
+			final long TOTAL = SIZE1 + SIZE2 + SIZE3;
+			
+			final Configuration config = TestFileUtils.getConfigForDir(SIZE1, SIZE2, SIZE3);
+			
+			final DummyFileInputFormat format = new DummyFileInputFormat();
+			format.configure(config);
+			
+			BaseStatistics stats = format.getStatistics(null);
+			Assert.assertEquals("The file size from the statistics is wrong.", TOTAL, stats.getTotalInputSize());
+		} catch (Exception ex) {
+			ex.printStackTrace();
+			Assert.fail(ex.getMessage());
+		}
+	}
+	
+	@Test
+	public void testGetStatisticsOneFileWithCachedVersion() {
+		try {
+			final long SIZE = 50873;
+			final long FAKE_SIZE = 10065;
+			
+			final Configuration config = TestFileUtils.getConfigForFile(SIZE);
+			
+			DummyFileInputFormat format = new DummyFileInputFormat();
+			format.configure(config);
+			FileBaseStatistics stats = format.getStatistics(null);
+			Assert.assertEquals("The file size from the statistics is wrong.", SIZE, stats.getTotalInputSize());
+			
+			format = new DummyFileInputFormat();
+			format.configure(config);
+			FileBaseStatistics newStats = format.getStatistics(stats);
+			Assert.assertTrue("Statistics object was changed", newStats == stats);
+
+			// insert fake stats with the correct modification time. the call should return the fake stats
+			format = new DummyFileInputFormat();
+			format.configure(config);
+			FileBaseStatistics fakeStats = new FileBaseStatistics(stats.getLastModificationTime(), FAKE_SIZE, BaseStatistics.AVG_RECORD_BYTES_UNKNOWN);
+			BaseStatistics latest = format.getStatistics(fakeStats);
+			Assert.assertEquals("The file size from the statistics is wrong.", FAKE_SIZE, latest.getTotalInputSize());
+			
+			// insert fake stats with the correct modification time. the call should return the fake stats
+			format = new DummyFileInputFormat();
+			format.configure(config);
+			FileBaseStatistics outDatedFakeStats = new FileBaseStatistics(stats.getLastModificationTime()-1, FAKE_SIZE, BaseStatistics.AVG_RECORD_BYTES_UNKNOWN);
+			BaseStatistics reGathered = format.getStatistics(outDatedFakeStats);
+			Assert.assertEquals("The file size from the statistics is wrong.", SIZE, reGathered.getTotalInputSize());
+			
+		} catch (Exception ex) {
+			ex.printStackTrace();
+			Assert.fail(ex.getMessage());
+		}
+	}
+	
+	@Test
+	public void testGetStatisticsMultipleFilesWithCachedVersion() {
+		try {
+			final long SIZE1 = 2077;
+			final long SIZE2 = 31909;
+			final long SIZE3 = 10;
+			final long TOTAL = SIZE1 + SIZE2 + SIZE3;
+			final long FAKE_SIZE = 10065;
+			
+			final Configuration config = TestFileUtils.getConfigForDir(SIZE1, SIZE2, SIZE3);
+			
+			DummyFileInputFormat format = new DummyFileInputFormat();
+			format.configure(config);
+			FileBaseStatistics stats = format.getStatistics(null);
+			Assert.assertEquals("The file size from the statistics is wrong.", TOTAL, stats.getTotalInputSize());
+			
+			format = new DummyFileInputFormat();
+			format.configure(config);
+			FileBaseStatistics newStats = format.getStatistics(stats);
+			Assert.assertTrue("Statistics object was changed", newStats == stats);
+
+			// insert fake stats with the correct modification time. the call should return the fake stats
+			format = new DummyFileInputFormat();
+			format.configure(config);
+			FileBaseStatistics fakeStats = new FileBaseStatistics(stats.getLastModificationTime(), FAKE_SIZE, BaseStatistics.AVG_RECORD_BYTES_UNKNOWN);
+			BaseStatistics latest = format.getStatistics(fakeStats);
+			Assert.assertEquals("The file size from the statistics is wrong.", FAKE_SIZE, latest.getTotalInputSize());
+			
+			// insert fake stats with the correct modification time. the call should return the fake stats
+			format = new DummyFileInputFormat();
+			format.configure(config);
+			FileBaseStatistics outDatedFakeStats = new FileBaseStatistics(stats.getLastModificationTime()-1, FAKE_SIZE, BaseStatistics.AVG_RECORD_BYTES_UNKNOWN);
+			BaseStatistics reGathered = format.getStatistics(outDatedFakeStats);
+			Assert.assertEquals("The file size from the statistics is wrong.", TOTAL, reGathered.getTotalInputSize());
+			
+		} catch (Exception ex) {
+			ex.printStackTrace();
+			Assert.fail(ex.getMessage());
+		}
+	}
+	
+	// ------------------------------------------------------------------------
+	
+	private class DummyFileInputFormat extends FileInputFormat<PactInteger> {
+
+		@Override
+		public boolean reachedEnd() throws IOException {
+			return true;
+		}
+
+		@Override
+		public boolean nextRecord(PactInteger record) throws IOException {
+			return false;
+		}
+	}
+}
diff --git a/pact/pact-compiler/src/main/java/eu/stratosphere/pact/compiler/plan/TwoInputNode.java b/pact/pact-compiler/src/main/java/eu/stratosphere/pact/compiler/plan/TwoInputNode.java
index 4385611..7bdadc7 100644
--- a/pact/pact-compiler/src/main/java/eu/stratosphere/pact/compiler/plan/TwoInputNode.java
+++ b/pact/pact-compiler/src/main/java/eu/stratosphere/pact/compiler/plan/TwoInputNode.java
@@ -725,11 +725,10 @@ public abstract class TwoInputNode extends OptimizerNode
 	
 		double avgRecordWidth = -1;
 		
-		if(this.getFirstPredecessorNode() != null && 
-				this.getFirstPredecessorNode().estimatedOutputSize != -1 &&
-				this.getFirstPredecessorNode().estimatedNumRecords != -1) {
+		if (this.getFirstPredecessorNode() != null && this.getFirstPredecessorNode().estimatedOutputSize != -1 &&
+				this.getFirstPredecessorNode().estimatedNumRecords > 0)
+		{
 			avgRecordWidth = (this.getFirstPredecessorNode().estimatedOutputSize / this.getFirstPredecessorNode().estimatedNumRecords);
-			
 		} else {
 			return -1;
 		}
diff --git a/pact/pact-compiler/src/main/java/eu/stratosphere/pact/compiler/plandump/PlanJSONDumpGenerator.java b/pact/pact-compiler/src/main/java/eu/stratosphere/pact/compiler/plandump/PlanJSONDumpGenerator.java
index 9073041..d2d6c05 100644
--- a/pact/pact-compiler/src/main/java/eu/stratosphere/pact/compiler/plandump/PlanJSONDumpGenerator.java
+++ b/pact/pact-compiler/src/main/java/eu/stratosphere/pact/compiler/plandump/PlanJSONDumpGenerator.java
@@ -40,11 +40,13 @@ import eu.stratosphere.pact.compiler.plan.DataSourceNode;
 import eu.stratosphere.pact.compiler.plan.OptimizerNode;
 import eu.stratosphere.pact.compiler.plan.PactConnection;
 import eu.stratosphere.pact.compiler.plan.TempMode;
+import eu.stratosphere.pact.compiler.plan.candidate.BulkIterationPlanNode;
 import eu.stratosphere.pact.compiler.plan.candidate.Channel;
 import eu.stratosphere.pact.compiler.plan.candidate.OptimizedPlan;
 import eu.stratosphere.pact.compiler.plan.candidate.PlanNode;
 import eu.stratosphere.pact.compiler.plan.candidate.SinkPlanNode;
 import eu.stratosphere.pact.compiler.plan.candidate.UnionPlanNode;
+import eu.stratosphere.pact.compiler.plan.candidate.WorksetIterationPlanNode;
 import eu.stratosphere.pact.compiler.util.Utils;
 import eu.stratosphere.pact.runtime.shipping.ShipStrategyType;
 
@@ -56,8 +58,6 @@ public class PlanJSONDumpGenerator {
 	private Map<DumpableNode<?>, Integer> nodeIds; // resolves pact nodes to ids
 
 	private int nodeCnt;
-	
-	private boolean firstInList = true;
 
 	// --------------------------------------------------------------------------------------------
 	
@@ -116,14 +116,14 @@ public class PlanJSONDumpGenerator {
 
 		// Generate JSON for plan
 		for (int i = 0; i < nodes.size(); i++) {
-			visit(nodes.get(i), writer);
+			visit(nodes.get(i), writer, i == 0);
 		}
 		
 		// JSON Footer
 		writer.println("\n\t]\n}");
 	}
 
-	private void visit(DumpableNode<?> node, PrintWriter writer) {
+	private void visit(DumpableNode<?> node, PrintWriter writer, boolean first) {
 		// check for duplicate traversal
 		if (this.nodeIds.containsKey(node)) {
 			return;
@@ -135,7 +135,8 @@ public class PlanJSONDumpGenerator {
 		// then recurse
 		for (Iterator<? extends DumpableNode<?>> children = node.getPredecessors(); children.hasNext(); ) {
 			final DumpableNode<?> child = children.next();
-			visit(child, writer);
+			visit(child, writer, first);
+			first = false;
 		}
 		
 		// check if this node should be skipped from the dump
@@ -143,13 +144,37 @@ public class PlanJSONDumpGenerator {
 		
 		// ------------------ dump after the ascend ---------------------
 		// start a new node and output node id
-		if (this.firstInList) {
-			// the first does not need to add a comma after the previous node
-			firstInList = false;
-		} else {
+		if (!first) {
 			writer.print(",\n");
 		}
-		writer.print("\t{\n\t\t\"id\": " + this.nodeIds.get(node));
+		// open the node
+		writer.print("\t{\n");
+		
+		// recurse, it is is an iteration node
+		if (node instanceof BulkIterationPlanNode) {
+			BulkIterationPlanNode bipn = (BulkIterationPlanNode) node;
+			
+			writer.print("\t\t\"step_function\": [\n");
+			
+			visit(bipn.getRootOfStepFunction(), writer, true);
+			
+			writer.print("\n\t\t],\n");
+			writer.print("\t\t\"next_partial_solution\": " + this.nodeIds.get(bipn.getRootOfStepFunction()) + ",\n");
+		} else if (node instanceof WorksetIterationPlanNode) {
+			WorksetIterationPlanNode wipn = (WorksetIterationPlanNode) node;
+			
+			writer.print("\t\t\"step_function\": [\n");
+			
+			visit(wipn.getNextWorkSetPlanNode(), writer, true);
+			visit(wipn.getSolutionSetDeltaPlanNode(), writer, false);
+			
+			writer.print("\n\t\t],\n");
+			writer.print("\t\t\"next_workset\": " + this.nodeIds.get(wipn.getNextWorkSetPlanNode()) + ",\n");
+			writer.print("\t\t\"solution_delta\": " + this.nodeIds.get(wipn.getSolutionSetDeltaPlanNode()) + ",\n");
+		}
+		
+		// print the id
+		writer.print("\t\t\"id\": " + this.nodeIds.get(node));
 
 		
 		final String type;
@@ -253,6 +278,9 @@ public class PlanJSONDumpGenerator {
 						case PARTITION_LOCAL_HASH:
 							shipStrategy = "Hash Partition (local)";
 							break;
+						case PARTITION_RANDOM:
+							shipStrategy = "Redistribute";
+							break;
 						default:
 							throw new CompilerException("Unknown ship strategy '" + conn.getShipStrategy().name()
 								+ "' in JSON generator.");
@@ -315,11 +343,10 @@ public class PlanJSONDumpGenerator {
 
 		final PlanNode p = node.getPlanNode();
 		if (p == null) {
-			// finish node and done
+			// finish node
 			writer.print("\n\t}");
-			return ;
+			return;
 		}
-		
 		// local strategy
 		String locString = null;
 		if (p.getDriverStrategy() != null) {
diff --git a/pact/pact-compiler/src/test/java/eu/stratosphere/pact/compiler/CompilerTestBase.java b/pact/pact-compiler/src/test/java/eu/stratosphere/pact/compiler/CompilerTestBase.java
index 38f82a3..5d2011a 100644
--- a/pact/pact-compiler/src/test/java/eu/stratosphere/pact/compiler/CompilerTestBase.java
+++ b/pact/pact-compiler/src/test/java/eu/stratosphere/pact/compiler/CompilerTestBase.java
@@ -39,7 +39,9 @@ import eu.stratosphere.pact.compiler.costs.DefaultCostEstimator;
 import eu.stratosphere.pact.compiler.plan.candidate.OptimizedPlan;
 import eu.stratosphere.pact.compiler.plan.candidate.PlanNode;
 import eu.stratosphere.pact.compiler.plan.candidate.SingleInputPlanNode;
+import eu.stratosphere.pact.generic.contract.BulkIteration;
 import eu.stratosphere.pact.generic.contract.Contract;
+import eu.stratosphere.pact.generic.contract.WorksetIteration;
 import eu.stratosphere.pact.generic.io.FileInputFormat.FileBaseStatistics;
 
 /**
@@ -276,6 +278,7 @@ public abstract class CompilerTestBase {
 		@Override
 		public boolean preVisit(Contract visitable) {
 			if (this.seen.add(visitable)) {
+				// add to  the map
 				final String name = visitable.getName();
 				List<Contract> list = this.map.get(name);
 				if (list == null) {
@@ -283,6 +286,15 @@ public abstract class CompilerTestBase {
 					this.map.put(name, list);
 				}
 				list.add(visitable);
+				
+				// recurse into bulk iterations
+				if (visitable instanceof BulkIteration) {
+					((BulkIteration) visitable).getNextPartialSolution().accept(this);
+				} else if (visitable instanceof WorksetIteration) {
+					((WorksetIteration) visitable).getSolutionSetDelta().accept(this);
+					((WorksetIteration) visitable).getNextWorkset().accept(this);
+				}
+				
 				return true;
 			} else {
 				return false;
diff --git a/pact/pact-compiler/src/test/java/eu/stratosphere/pact/compiler/IterativeJobCompilerTest.java b/pact/pact-compiler/src/test/java/eu/stratosphere/pact/compiler/IterativeJobCompilerTest.java
deleted file mode 100644
index 101d74a..0000000
--- a/pact/pact-compiler/src/test/java/eu/stratosphere/pact/compiler/IterativeJobCompilerTest.java
+++ /dev/null
@@ -1,91 +0,0 @@
-/***********************************************************************************************************************
- *
- * Copyright (C) 2012 by the Stratosphere project (http://stratosphere.eu)
- *
- * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with
- * the License. You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on
- * an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
- * specific language governing permissions and limitations under the License.
- *
- **********************************************************************************************************************/
-package eu.stratosphere.pact.compiler;
-
-import org.junit.Test;
-
-import eu.stratosphere.pact.common.contract.CrossContract;
-import eu.stratosphere.pact.common.contract.GenericDataSink;
-import eu.stratosphere.pact.common.contract.ReduceContract;
-import eu.stratosphere.pact.common.plan.Plan;
-import eu.stratosphere.pact.compiler.plan.candidate.OptimizedPlan;
-import eu.stratosphere.pact.compiler.plantranslate.NepheleJobGraphGenerator;
-import eu.stratosphere.pact.example.iterative.IterativeKMeans;
-import eu.stratosphere.pact.example.iterative.WorksetConnectedComponents;
-import eu.stratosphere.pact.generic.contract.BulkIteration;
-
-
-/**
- *
- */
-public class IterativeJobCompilerTest extends CompilerTestBase {
-	
-	// --------------------------------------------------------------------------------------------
-	//  K-Means (Bulk Iteration)
-	// --------------------------------------------------------------------------------------------
-	
-	@Test
-	public void testCompileKMeansIteration1() {
-		IterativeKMeans kmi = new IterativeKMeans();
-
-		Plan plan = kmi.getPlan(String.valueOf(DEFAULT_PARALLELISM),
-				IN_FILE, IN_FILE, OUT_FILE, String.valueOf(20));
-		setParameterToCross(plan, "INPUT_LEFT_SHIP_STRATEGY", "SHIP_FORWARD");
-
-		OptimizedPlan op = compileNoStats(plan);
-
-		NepheleJobGraphGenerator jgg = new NepheleJobGraphGenerator();
-		jgg.compileJobGraph(op);
-	}
-	
-	@Test
-	public void testCompileKMeansIteration2() {
-		IterativeKMeans kmi = new IterativeKMeans();
-
-		Plan plan = kmi.getPlan(String.valueOf(DEFAULT_PARALLELISM),
-				IN_FILE, IN_FILE, OUT_FILE, String.valueOf(20));
-		setParameterToCross(plan, "INPUT_RIGHT_SHIP_STRATEGY", "SHIP_FORWARD");
-
-		OptimizedPlan op = compileNoStats(plan);
-
-		NepheleJobGraphGenerator jgg = new NepheleJobGraphGenerator();
-		jgg.compileJobGraph(op);
-	}
-	
-	public static void setParameterToCross(Plan p, String key, String value) {
-		GenericDataSink sink = p.getDataSinks().iterator().next();
-		BulkIteration iter = (BulkIteration) sink.getInputs().get(0);
-		ReduceContract reduce2 = (ReduceContract) iter.getNextPartialSolution();
-		ReduceContract reduce1 = (ReduceContract) reduce2.getInputs().get(0);
-		CrossContract cross = (CrossContract) reduce1.getInputs().get(0);
-		cross.getParameters().setString(key, value);
-	}
-	
-	// --------------------------------------------------------------------------------------------
-	//  Connected Components (Workset Iteration)
-	// --------------------------------------------------------------------------------------------
-	
-	@Test
-	public void testCompileConnectedComponents() {
-		WorksetConnectedComponents cc = new WorksetConnectedComponents();
-
-		Plan plan = cc.getPlan(String.valueOf(DEFAULT_PARALLELISM),
-				IN_FILE, IN_FILE, OUT_FILE, String.valueOf(100));
-
-		OptimizedPlan op = compileNoStats(plan);
-		NepheleJobGraphGenerator jgg = new NepheleJobGraphGenerator();
-		jgg.compileJobGraph(op);
-	}
-}
diff --git a/pact/pact-compiler/src/test/java/eu/stratosphere/pact/compiler/examples/KMeansStepCompilerTest.java b/pact/pact-compiler/src/test/java/eu/stratosphere/pact/compiler/examples/KMeansStepCompilerTest.java
index f7ca0d5..715e1f0 100644
--- a/pact/pact-compiler/src/test/java/eu/stratosphere/pact/compiler/examples/KMeansStepCompilerTest.java
+++ b/pact/pact-compiler/src/test/java/eu/stratosphere/pact/compiler/examples/KMeansStepCompilerTest.java
@@ -32,7 +32,6 @@ import eu.stratosphere.pact.compiler.plan.candidate.OptimizedPlan;
 import eu.stratosphere.pact.compiler.plan.candidate.PlanNode;
 import eu.stratosphere.pact.compiler.plan.candidate.SingleInputPlanNode;
 import eu.stratosphere.pact.compiler.plan.candidate.SinkPlanNode;
-import eu.stratosphere.pact.compiler.plandump.PlanJSONDumpGenerator;
 import eu.stratosphere.pact.example.datamining.KMeansIteration;
 import eu.stratosphere.pact.example.datamining.KMeansIteration.ComputeDistance;
 import eu.stratosphere.pact.example.datamining.KMeansIteration.FindNearestCenter;
@@ -58,7 +57,7 @@ public class KMeansStepCompilerTest extends CompilerTestBase {
 	
 	private static final String SINK = "New Center Positions";
 	
-	private final FieldList set0 = new FieldList(0);
+	private static final FieldList set0 = new FieldList(0);
 
 	// ------------------------------------------------------------------------
 	//  Check that the optimizer chooses valid plans
@@ -115,7 +114,6 @@ public class KMeansStepCompilerTest extends CompilerTestBase {
 	private void testQueryRolledOut(int numSteps, boolean unique) {
 		final Plan p = getRolledOutPlan(numSteps, unique);
 		final OptimizedPlan plan = compileNoStats(p);
-		System.out.println(new PlanJSONDumpGenerator().getOptimizerPlanAsJSON(plan));
 		
 		// get the nodes from the final plan
 		final OptimizerPlanNodeResolver or = getOptimizerPlanNodeResolver(plan);
diff --git a/pact/pact-compiler/src/test/java/eu/stratosphere/pact/compiler/examples/TPCHQuery3CompilerTest.java b/pact/pact-compiler/src/test/java/eu/stratosphere/pact/compiler/examples/TPCHQuery3CompilerTest.java
index 8a938f9..5d366e8 100644
--- a/pact/pact-compiler/src/test/java/eu/stratosphere/pact/compiler/examples/TPCHQuery3CompilerTest.java
+++ b/pact/pact-compiler/src/test/java/eu/stratosphere/pact/compiler/examples/TPCHQuery3CompilerTest.java
@@ -90,7 +90,7 @@ public class TPCHQuery3CompilerTest extends CompilerTestBase {
 	/**
 	 * Statistics that push towards a broadcast join.
 	 */
-	@Test
+//	@Test
 	public void testQueryWithStatsForBroadcastHash() {
 		testQueryGeneric(1024l*1024*1024*1024, 100l*1024*1024*1024*1024, true, false, true, false, false);
 	}
@@ -98,7 +98,7 @@ public class TPCHQuery3CompilerTest extends CompilerTestBase {
 	/**
 	 * Statistics that push towards a broadcast join.
 	 */
-	@Test
+//	@Test
 	public void testQueryWithStatsForRepartitionAny() {
 		testQueryGeneric(100l*1024*1024*1024*1024, 100l*1024*1024*1024*1024, false, true, true, true, true);
 	}
@@ -107,7 +107,7 @@ public class TPCHQuery3CompilerTest extends CompilerTestBase {
 	 * Statistics that push towards a repartition merge join. If the join blows the data volume up significantly,
 	 * re-exploiting the sorted order is cheaper.
 	 */
-	@Test
+//	@Test
 	public void testQueryWithStatsForRepartitionMerge() {
 		TPCHQuery3 query = new TPCHQuery3();
 		Plan p = query.getPlan(DEFAULT_PARALLELISM_STRING, IN_FILE, IN_FILE, OUT_FILE);
diff --git a/pact/pact-compiler/src/test/java/eu/stratosphere/pact/compiler/iterations/IncrementalConnectedComponentsTest.java b/pact/pact-compiler/src/test/java/eu/stratosphere/pact/compiler/iterations/IncrementalConnectedComponentsTest.java
new file mode 100644
index 0000000..cee5e26
--- /dev/null
+++ b/pact/pact-compiler/src/test/java/eu/stratosphere/pact/compiler/iterations/IncrementalConnectedComponentsTest.java
@@ -0,0 +1,39 @@
+/***********************************************************************************************************************
+ *
+ * Copyright (C) 2012 by the Stratosphere project (http://stratosphere.eu)
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on
+ * an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
+ * specific language governing permissions and limitations under the License.
+ *
+ **********************************************************************************************************************/
+package eu.stratosphere.pact.compiler.iterations;
+
+import eu.stratosphere.pact.common.plan.Plan;
+import eu.stratosphere.pact.compiler.CompilerTestBase;
+import eu.stratosphere.pact.compiler.plan.candidate.OptimizedPlan;
+import eu.stratosphere.pact.compiler.plantranslate.NepheleJobGraphGenerator;
+import eu.stratosphere.pact.example.iterative.WorksetConnectedComponents;
+
+/**
+ *
+ */
+public class IncrementalConnectedComponentsTest extends CompilerTestBase {
+	
+//	@Test
+	public void testCompileConnectedComponents() {
+		WorksetConnectedComponents cc = new WorksetConnectedComponents();
+
+		Plan plan = cc.getPlan(String.valueOf(DEFAULT_PARALLELISM),
+				IN_FILE, IN_FILE, OUT_FILE, String.valueOf(100));
+
+		OptimizedPlan op = compileNoStats(plan);
+		NepheleJobGraphGenerator jgg = new NepheleJobGraphGenerator();
+		jgg.compileJobGraph(op);
+	}
+}
diff --git a/pact/pact-compiler/src/test/java/eu/stratosphere/pact/compiler/iterations/IterativeKMeansTest.java b/pact/pact-compiler/src/test/java/eu/stratosphere/pact/compiler/iterations/IterativeKMeansTest.java
new file mode 100644
index 0000000..f2d814d
--- /dev/null
+++ b/pact/pact-compiler/src/test/java/eu/stratosphere/pact/compiler/iterations/IterativeKMeansTest.java
@@ -0,0 +1,195 @@
+/***********************************************************************************************************************
+ *
+ * Copyright (C) 2012 by the Stratosphere project (http://stratosphere.eu)
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on
+ * an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
+ * specific language governing permissions and limitations under the License.
+ *
+ **********************************************************************************************************************/
+package eu.stratosphere.pact.compiler.iterations;
+
+import java.util.Arrays;
+
+import org.junit.Assert;
+import org.junit.Test;
+
+import eu.stratosphere.pact.common.contract.CrossContract;
+import eu.stratosphere.pact.common.contract.FileDataSource;
+import eu.stratosphere.pact.common.plan.Plan;
+import eu.stratosphere.pact.common.util.FieldList;
+import eu.stratosphere.pact.compiler.CompilerTestBase;
+import eu.stratosphere.pact.compiler.PactCompiler;
+import eu.stratosphere.pact.compiler.plan.candidate.BulkIterationPlanNode;
+import eu.stratosphere.pact.compiler.plan.candidate.DualInputPlanNode;
+import eu.stratosphere.pact.compiler.plan.candidate.OptimizedPlan;
+import eu.stratosphere.pact.compiler.plan.candidate.SingleInputPlanNode;
+import eu.stratosphere.pact.compiler.plan.candidate.SinkPlanNode;
+import eu.stratosphere.pact.compiler.plantranslate.NepheleJobGraphGenerator;
+import eu.stratosphere.pact.example.iterative.IterativeKMeans;
+import eu.stratosphere.pact.runtime.shipping.ShipStrategyType;
+import eu.stratosphere.pact.runtime.task.DriverStrategy;
+import eu.stratosphere.pact.runtime.task.util.LocalStrategy;
+
+
+/**
+ *
+ */
+public class IterativeKMeansTest extends CompilerTestBase {
+	
+	private static final String DATAPOINTS = "Data Points";
+	private static final String CENTERS = "Centers";
+	
+	private static final String ITERATION_NAME = "K-Means Loop";
+	
+	private static final String CROSS_NAME = "Compute Distances";
+	private static final String NEAREST_CENTER_REDUCER = "Find Nearest Centers";
+	private static final String RECOMPUTE_CENTERS_REDUCER = "Recompute Center Positions";
+	
+	private static final String SINK = "New Center Positions";
+	
+	private final FieldList set0 = new FieldList(0);
+	
+	// --------------------------------------------------------------------------------------------
+	//  K-Means (Bulk Iteration)
+	// --------------------------------------------------------------------------------------------
+	
+	@Test
+	public void testCompileKMeansWithStats() {
+		
+		IterativeKMeans kmi = new IterativeKMeans();
+		Plan p = kmi.getPlan(String.valueOf(DEFAULT_PARALLELISM),
+				IN_FILE, IN_FILE, OUT_FILE, String.valueOf(20));
+		
+		// set the statistics
+		ContractResolver cr = getContractResolver(p);
+		FileDataSource pointsSource = cr.getNode(DATAPOINTS);
+		FileDataSource centersSource = cr.getNode(CENTERS);
+		setSourceStatistics(pointsSource, 100l*1024*1024*1024, 32f);
+		setSourceStatistics(centersSource, 1024*1024, 32f);
+		
+		OptimizedPlan plan = compileWithStats(p);
+		OptimizerPlanNodeResolver or = getOptimizerPlanNodeResolver(plan);
+		
+		final SinkPlanNode sink = or.getNode(SINK);
+		final BulkIterationPlanNode iter = or.getNode(ITERATION_NAME);
+		
+		final SingleInputPlanNode newCenterReducer = or.getNode(RECOMPUTE_CENTERS_REDUCER);
+		final SingleInputPlanNode newCenterCombiner = (SingleInputPlanNode) newCenterReducer.getPredecessor(); 
+		final SingleInputPlanNode nearestCenterReducer = or.getNode(NEAREST_CENTER_REDUCER);
+		final SingleInputPlanNode nearestCenterCombiner = nearestCenterReducer.getPredecessor() instanceof SingleInputPlanNode ?
+				(SingleInputPlanNode) nearestCenterReducer.getPredecessor() : null;
+						
+		final DualInputPlanNode cross = or.getNode(CROSS_NAME);
+		
+		checkIterNodeAndSink(iter, sink);
+		checkStandardStrategies(nearestCenterReducer, nearestCenterCombiner, newCenterReducer, newCenterCombiner);
+		
+		// make sure that the partitioning is pushed down
+		Assert.assertEquals(ShipStrategyType.PARTITION_HASH, cross.getInput1().getShipStrategy());
+		Assert.assertEquals(ShipStrategyType.BROADCAST, cross.getInput2().getShipStrategy());
+		Assert.assertTrue(cross.getInput1().getTempMode().isCached());
+		
+		NepheleJobGraphGenerator jobGen = new NepheleJobGraphGenerator();
+		jobGen.compileJobGraph(plan);
+	}
+	
+	@Test
+	public void testCompileKMeansIterationForwardCenters() {
+		
+		IterativeKMeans kmi = new IterativeKMeans();
+		Plan p = kmi.getPlan(String.valueOf(DEFAULT_PARALLELISM),
+				IN_FILE, IN_FILE, OUT_FILE, String.valueOf(20));
+		
+		// parameterize the cross strategies
+		ContractResolver cr = getContractResolver(p);
+		CrossContract crossNode = cr.getNode(CROSS_NAME);
+		crossNode.setParameter(PactCompiler.HINT_SHIP_STRATEGY_SECOND_INPUT, PactCompiler.HINT_SHIP_STRATEGY_FORWARD);
+		
+		OptimizedPlan plan = compileNoStats(p);
+		OptimizerPlanNodeResolver or = getOptimizerPlanNodeResolver(plan);
+		
+		final SinkPlanNode sink = or.getNode(SINK);
+		final BulkIterationPlanNode iter = or.getNode(ITERATION_NAME);
+		
+		final SingleInputPlanNode newCenterReducer = or.getNode(RECOMPUTE_CENTERS_REDUCER);
+		final SingleInputPlanNode newCenterCombiner = (SingleInputPlanNode) newCenterReducer.getPredecessor(); 
+		final SingleInputPlanNode nearestCenterReducer = or.getNode(NEAREST_CENTER_REDUCER);
+		final SingleInputPlanNode nearestCenterCombiner = nearestCenterReducer.getPredecessor() instanceof SingleInputPlanNode ?
+				(SingleInputPlanNode) nearestCenterReducer.getPredecessor() : null;
+						
+		final DualInputPlanNode cross = or.getNode(CROSS_NAME);
+		
+		checkIterNodeAndSink(iter, sink);
+		checkStandardStrategies(nearestCenterReducer, nearestCenterCombiner, newCenterReducer, newCenterCombiner);
+		
+		// make sure that the partitioning is pushed down
+		Assert.assertEquals(ShipStrategyType.BROADCAST, cross.getInput1().getShipStrategy());
+		Assert.assertEquals(ShipStrategyType.FORWARD, cross.getInput2().getShipStrategy());
+		
+		NepheleJobGraphGenerator jobGen = new NepheleJobGraphGenerator();
+		jobGen.compileJobGraph(plan);
+	}
+	
+	// --------------------------------------------------------------------------------------------
+	//  Check methods for individual cases
+	// --------------------------------------------------------------------------------------------
+	
+	private void checkIterNodeAndSink(BulkIterationPlanNode iterationNode, SinkPlanNode sink) {
+		Assert.assertEquals(ShipStrategyType.PARTITION_RANDOM, iterationNode.getInput().getShipStrategy());
+		Assert.assertEquals(ShipStrategyType.FORWARD, sink.getInput().getShipStrategy());
+		Assert.assertEquals(DriverStrategy.NONE, sink.getDriverStrategy());
+	}
+	
+	private void checkStandardStrategies(
+			SingleInputPlanNode nearestCenterReducer, SingleInputPlanNode nearestCenterCombiner,
+			SingleInputPlanNode newCenterReducer, SingleInputPlanNode newCenterCombiner)
+	{
+		// check that the new centers combiner is always there
+		Assert.assertNotNull(newCenterCombiner);
+		
+		// check ship strategies that are always fix
+		Assert.assertEquals(ShipStrategyType.PARTITION_HASH, newCenterReducer.getInput().getShipStrategy());
+		Assert.assertEquals(ShipStrategyType.FORWARD, newCenterCombiner.getInput().getShipStrategy());
+		if (nearestCenterCombiner != null) {
+			Assert.assertEquals(ShipStrategyType.PARTITION_HASH, nearestCenterReducer.getInput().getShipStrategy());
+			Assert.assertEquals(ShipStrategyType.FORWARD, nearestCenterCombiner.getInput().getShipStrategy());
+		}
+		
+		// check the driver strategies that are always fix
+		Assert.assertEquals(DriverStrategy.SORTED_GROUP, newCenterReducer.getDriverStrategy());
+		Assert.assertEquals(DriverStrategy.SORTED_GROUP, nearestCenterReducer.getDriverStrategy());
+		Assert.assertEquals(DriverStrategy.PARTIAL_GROUP, newCenterCombiner.getDriverStrategy());
+		if (nearestCenterCombiner != null) {
+			Assert.assertEquals(DriverStrategy.PARTIAL_GROUP, nearestCenterCombiner.getDriverStrategy());
+		}
+		
+		// check the local strategies and local strategy keys
+		Assert.assertEquals(LocalStrategy.NONE, newCenterCombiner.getInput().getLocalStrategy());
+		Assert.assertEquals(set0, newCenterCombiner.getKeys());
+		Assert.assertNull(newCenterCombiner.getInput().getLocalStrategyKeys());
+		Assert.assertNull(newCenterCombiner.getInput().getLocalStrategySortOrder());
+		
+		Assert.assertEquals(LocalStrategy.COMBININGSORT, newCenterReducer.getInput().getLocalStrategy());
+		Assert.assertEquals(set0, newCenterReducer.getKeys());
+		Assert.assertEquals(set0, newCenterReducer.getInput().getLocalStrategyKeys());
+		Assert.assertTrue(Arrays.equals(newCenterReducer.getInput().getLocalStrategySortOrder(), newCenterReducer.getSortOrders()));
+		
+		if (nearestCenterCombiner != null) {
+			Assert.assertEquals(LocalStrategy.NONE, nearestCenterCombiner.getInput().getLocalStrategy());
+			Assert.assertEquals(set0, nearestCenterCombiner.getKeys());
+			Assert.assertNull(nearestCenterCombiner.getInput().getLocalStrategyKeys());
+			Assert.assertNull(nearestCenterCombiner.getInput().getLocalStrategySortOrder());
+			
+			Assert.assertEquals(LocalStrategy.COMBININGSORT, nearestCenterReducer.getInput().getLocalStrategy());
+			Assert.assertEquals(set0, nearestCenterReducer.getKeys());
+			Assert.assertEquals(set0, nearestCenterReducer.getInput().getLocalStrategyKeys());
+			Assert.assertTrue(Arrays.equals(nearestCenterReducer.getInput().getLocalStrategySortOrder(), nearestCenterReducer.getSortOrders()));
+		}
+	}
+}
diff --git a/pact/pact-runtime/src/main/java/eu/stratosphere/pact/runtime/iterative/compensatable/danglingpagerank/DanglingPageRankHdfsCheckpointWriter.java b/pact/pact-runtime/src/main/java/eu/stratosphere/pact/runtime/iterative/compensatable/danglingpagerank/DanglingPageRankHdfsCheckpointWriter.java
index 6f26c21..f3fdc71 100644
--- a/pact/pact-runtime/src/main/java/eu/stratosphere/pact/runtime/iterative/compensatable/danglingpagerank/DanglingPageRankHdfsCheckpointWriter.java
+++ b/pact/pact-runtime/src/main/java/eu/stratosphere/pact/runtime/iterative/compensatable/danglingpagerank/DanglingPageRankHdfsCheckpointWriter.java
@@ -15,53 +15,58 @@ import java.io.IOException;
 
 public class DanglingPageRankHdfsCheckpointWriter extends HdfsCheckpointWriter {
 
-  private LongWritable key;
-  private DanglingRankWritable value;
-
-  public DanglingPageRankHdfsCheckpointWriter() throws IOException {
-    key = new LongWritable();
-    value = new DanglingRankWritable();
-  }
-
-  @Override
-  protected Class<? extends WritableComparable> keyClass() {
-    return key.getClass();
-  }
-
-  @Override
-  protected Class<? extends Writable> valueClass() {
-    return value.getClass();
-  }
-
-  @Override
-  protected void add(SequenceFile.Writer writer, PactRecord record) throws IOException {
-    key.set(record.getField(0, PactLong.class).getValue());
-    value.set(record.getField(1, PactDouble.class).getValue(), record.getField(2, BooleanValue.class).get());
-    writer.append(key, value);
-  }
-
-  public static class DanglingRankWritable implements Writable {
-
-    private double rank;
-    private boolean dangling;
-
-    public DanglingRankWritable() {}
-
-    public void set(double rank, boolean dangling) {
-      this.rank = rank;
-      this.dangling = dangling;
-    }
-
-    @Override
-    public void write(DataOutput out) throws IOException {
-      out.writeDouble(rank);
-      out.writeBoolean(dangling);
-    }
-
-    @Override
-    public void readFields(DataInput in) throws IOException {
-      rank = in.readDouble();
-      dangling = in.readBoolean();
-    }
-  }
+	private LongWritable key;
+
+	private DanglingRankWritable value;
+
+	public DanglingPageRankHdfsCheckpointWriter()
+		throws IOException {
+		key = new LongWritable();
+		value = new DanglingRankWritable();
+	}
+
+	@SuppressWarnings("rawtypes")
+	@Override
+	protected Class<? extends WritableComparable> keyClass() {
+		return key.getClass();
+	}
+
+	@Override
+	protected Class<? extends Writable> valueClass() {
+		return value.getClass();
+	}
+
+	@Override
+	protected void add(SequenceFile.Writer writer, PactRecord record) throws IOException {
+		key.set(record.getField(0, PactLong.class).getValue());
+		value.set(record.getField(1, PactDouble.class).getValue(), record.getField(2, BooleanValue.class).get());
+		writer.append(key, value);
+	}
+
+	public static class DanglingRankWritable implements Writable {
+
+		private double rank;
+
+		private boolean dangling;
+
+		public DanglingRankWritable() {
+		}
+
+		public void set(double rank, boolean dangling) {
+			this.rank = rank;
+			this.dangling = dangling;
+		}
+
+		@Override
+		public void write(DataOutput out) throws IOException {
+			out.writeDouble(rank);
+			out.writeBoolean(dangling);
+		}
+
+		@Override
+		public void readFields(DataInput in) throws IOException {
+			rank = in.readDouble();
+			dangling = in.readBoolean();
+		}
+	}
 }
diff --git a/pact/pact-runtime/src/main/java/eu/stratosphere/pact/runtime/iterative/io/HdfsCheckpointWriter.java b/pact/pact-runtime/src/main/java/eu/stratosphere/pact/runtime/iterative/io/HdfsCheckpointWriter.java
index 4e8852d..b082672 100644
--- a/pact/pact-runtime/src/main/java/eu/stratosphere/pact/runtime/iterative/io/HdfsCheckpointWriter.java
+++ b/pact/pact-runtime/src/main/java/eu/stratosphere/pact/runtime/iterative/io/HdfsCheckpointWriter.java
@@ -14,28 +14,30 @@ import java.io.IOException;
 
 public abstract class HdfsCheckpointWriter implements Closeable {
 
-  private SequenceFile.Writer writer;
+	private SequenceFile.Writer writer;
 
-  public HdfsCheckpointWriter() {}
+	public HdfsCheckpointWriter() {}
 
-  protected abstract Class<? extends WritableComparable> keyClass();
-  protected abstract Class<? extends Writable> valueClass();
+	@SuppressWarnings("rawtypes")
+	protected abstract Class<? extends WritableComparable> keyClass();
 
-  public void open(String path) throws IOException {
-    Path hdfsPath = new Path(path);
-    Configuration conf = new Configuration();
-    FileSystem fs = FileSystem.get(hdfsPath.toUri(), conf);
-    writer = new SequenceFile.Writer(fs, conf, hdfsPath, keyClass(), valueClass());
-  }
+	protected abstract Class<? extends Writable> valueClass();
 
-  public void addToCheckpoint(PactRecord record) throws IOException {
-    add(writer, record);
-  }
+	public void open(String path) throws IOException {
+		Path hdfsPath = new Path(path);
+		Configuration conf = new Configuration();
+		FileSystem fs = FileSystem.get(hdfsPath.toUri(), conf);
+		writer = new SequenceFile.Writer(fs, conf, hdfsPath, keyClass(), valueClass());
+	}
 
-  protected abstract void add(SequenceFile.Writer writer, PactRecord record) throws IOException;
+	public void addToCheckpoint(PactRecord record) throws IOException {
+		add(writer, record);
+	}
 
-  @Override
-  public void close() throws IOException {
-    Closeables.closeQuietly(writer);
-  }
+	protected abstract void add(SequenceFile.Writer writer, PactRecord record) throws IOException;
+
+	@Override
+	public void close() throws IOException {
+		Closeables.closeQuietly(writer);
+	}
 }
diff --git a/pact/pact-runtime/src/main/java/eu/stratosphere/pact/runtime/iterative/io/UpdateSolutionsetOutputCollector.java b/pact/pact-runtime/src/main/java/eu/stratosphere/pact/runtime/iterative/io/UpdateSolutionsetOutputCollector.java
index 55c6fed..3c143f2 100644
--- a/pact/pact-runtime/src/main/java/eu/stratosphere/pact/runtime/iterative/io/UpdateSolutionsetOutputCollector.java
+++ b/pact/pact-runtime/src/main/java/eu/stratosphere/pact/runtime/iterative/io/UpdateSolutionsetOutputCollector.java
@@ -25,7 +25,7 @@ public class UpdateSolutionsetOutputCollector<T> implements Collector<T> {
 	private final Collector<T> delegate;
 
 	// TODO type safety
-	private MutableHashTable.HashBucketIterator hashBucket;
+	private MutableHashTable.HashBucketIterator<T, ?> hashBucket;
 
 	private long numUpdatedElements;
 
@@ -34,7 +34,7 @@ public class UpdateSolutionsetOutputCollector<T> implements Collector<T> {
 		numUpdatedElements = 0;
 	}
 
-	public void setHashBucket(MutableHashTable.HashBucketIterator hashBucket) {
+	public void setHashBucket(MutableHashTable.HashBucketIterator<T, ?> hashBucket) {
 		this.hashBucket = hashBucket;
 	}
 
diff --git a/pact/pact-tests/src/test/java/eu/stratosphere/pact/test/cancelling/CancellingTestBase.java b/pact/pact-tests/src/test/java/eu/stratosphere/pact/test/cancelling/CancellingTestBase.java
index 9f7efae..3903e51 100644
--- a/pact/pact-tests/src/test/java/eu/stratosphere/pact/test/cancelling/CancellingTestBase.java
+++ b/pact/pact-tests/src/test/java/eu/stratosphere/pact/test/cancelling/CancellingTestBase.java
@@ -38,6 +38,7 @@ import eu.stratosphere.nephele.jobgraph.JobGraph;
 import eu.stratosphere.nephele.jobgraph.JobStatus;
 import eu.stratosphere.nephele.util.StringUtils;
 import eu.stratosphere.pact.common.plan.Plan;
+import eu.stratosphere.pact.compiler.DataStatistics;
 import eu.stratosphere.pact.compiler.PactCompiler;
 import eu.stratosphere.pact.compiler.plan.candidate.OptimizedPlan;
 import eu.stratosphere.pact.compiler.plantranslate.NepheleJobGraphGenerator;
@@ -220,9 +221,8 @@ public abstract class CancellingTestBase
 		}
 	}
 
-	private JobGraph getJobGraph(final Plan plan) throws Exception
-	{
-		final PactCompiler pc = new PactCompiler();
+	private JobGraph getJobGraph(final Plan plan) throws Exception {
+		final PactCompiler pc = new PactCompiler(new DataStatistics());
 		final OptimizedPlan op = pc.compile(plan);
 		final NepheleJobGraphGenerator jgg = new NepheleJobGraphGenerator();
 		return jgg.compileJobGraph(op);
diff --git a/pact/pact-tests/src/test/java/eu/stratosphere/pact/test/contracts/CoGroupITCase.java b/pact/pact-tests/src/test/java/eu/stratosphere/pact/test/contracts/CoGroupITCase.java
index 441a267..73b9b2f 100644
--- a/pact/pact-tests/src/test/java/eu/stratosphere/pact/test/contracts/CoGroupITCase.java
+++ b/pact/pact-tests/src/test/java/eu/stratosphere/pact/test/contracts/CoGroupITCase.java
@@ -40,6 +40,7 @@ import eu.stratosphere.pact.common.stubs.Collector;
 import eu.stratosphere.pact.common.type.PactRecord;
 import eu.stratosphere.pact.common.type.base.PactInteger;
 import eu.stratosphere.pact.common.type.base.PactString;
+import eu.stratosphere.pact.compiler.DataStatistics;
 import eu.stratosphere.pact.compiler.PactCompiler;
 import eu.stratosphere.pact.compiler.plan.candidate.OptimizedPlan;
 import eu.stratosphere.pact.compiler.plantranslate.NepheleJobGraphGenerator;
@@ -95,8 +96,8 @@ public class CoGroupITCase extends TestBase
 		getFilesystemProvider().createFile(tempPath + "/cogroup_right/cogroupTest_4.txt", COGROUP_RIGHT_IN_4);
 	}
 
-	public static class CoGroupTestInFormat extends DelimitedInputFormat
-	{
+	public static class CoGroupTestInFormat extends DelimitedInputFormat {
+		
 		private final PactString keyString = new PactString();
 		private final PactString valueString = new PactString();
 		
@@ -114,8 +115,8 @@ public class CoGroupITCase extends TestBase
 
 	}
 
-	public static class CoGroupOutFormat extends FileOutputFormat
-	{
+	public static class CoGroupOutFormat extends FileOutputFormat {
+		
 		private final StringBuilder buffer = new StringBuilder();
 		private final PactString keyString = new PactString();
 		private final PactInteger valueInteger = new PactInteger();
@@ -137,15 +138,13 @@ public class CoGroupITCase extends TestBase
 	}
 
 	public static class TestCoGrouper extends CoGroupStub {
-	//CoGroupStub<PactString, PactString, PactString, PactString, PactInteger> {
 
 		private PactString keyString = new PactString();
 		private PactString valueString = new PactString();
 		private PactRecord record = new PactRecord();
 		
 		@Override
-		public void coGroup(Iterator<PactRecord> records1,
-				Iterator<PactRecord> records2, Collector<PactRecord> out) {
+		public void coGroup(Iterator<PactRecord> records1, Iterator<PactRecord> records2, Collector<PactRecord> out) {
 			// TODO Auto-generated method stub
 			
 			int sum = 0;
@@ -207,7 +206,7 @@ public class CoGroupITCase extends TestBase
 
 		Plan plan = new Plan(output);
 
-		PactCompiler pc = new PactCompiler();
+		PactCompiler pc = new PactCompiler(new DataStatistics());
 		OptimizedPlan op = pc.compile(plan);
 
 		NepheleJobGraphGenerator jgg = new NepheleJobGraphGenerator();
diff --git a/pact/pact-tests/src/test/java/eu/stratosphere/pact/test/contracts/CrossITCase.java b/pact/pact-tests/src/test/java/eu/stratosphere/pact/test/contracts/CrossITCase.java
index 9d8425f..1684e6a 100644
--- a/pact/pact-tests/src/test/java/eu/stratosphere/pact/test/contracts/CrossITCase.java
+++ b/pact/pact-tests/src/test/java/eu/stratosphere/pact/test/contracts/CrossITCase.java
@@ -38,6 +38,7 @@ import eu.stratosphere.pact.common.stubs.CrossStub;
 import eu.stratosphere.pact.common.type.PactRecord;
 import eu.stratosphere.pact.common.type.base.PactInteger;
 import eu.stratosphere.pact.common.type.base.PactString;
+import eu.stratosphere.pact.compiler.DataStatistics;
 import eu.stratosphere.pact.compiler.PactCompiler;
 import eu.stratosphere.pact.compiler.plan.candidate.OptimizedPlan;
 import eu.stratosphere.pact.compiler.plantranslate.NepheleJobGraphGenerator;
@@ -179,7 +180,7 @@ public class CrossITCase extends TestBase
 
 		Plan plan = new Plan(output);
 
-		PactCompiler pc = new PactCompiler();
+		PactCompiler pc = new PactCompiler(new DataStatistics());
 		OptimizedPlan op = pc.compile(plan);
 
 		NepheleJobGraphGenerator jgg = new NepheleJobGraphGenerator();
diff --git a/pact/pact-tests/src/test/java/eu/stratosphere/pact/test/contracts/MapITCase.java b/pact/pact-tests/src/test/java/eu/stratosphere/pact/test/contracts/MapITCase.java
index 565fa52..2e5d31b 100644
--- a/pact/pact-tests/src/test/java/eu/stratosphere/pact/test/contracts/MapITCase.java
+++ b/pact/pact-tests/src/test/java/eu/stratosphere/pact/test/contracts/MapITCase.java
@@ -38,6 +38,7 @@ import eu.stratosphere.pact.common.stubs.MapStub;
 import eu.stratosphere.pact.common.type.PactRecord;
 import eu.stratosphere.pact.common.type.base.PactInteger;
 import eu.stratosphere.pact.common.type.base.PactString;
+import eu.stratosphere.pact.compiler.DataStatistics;
 import eu.stratosphere.pact.compiler.PactCompiler;
 import eu.stratosphere.pact.compiler.plan.candidate.OptimizedPlan;
 import eu.stratosphere.pact.compiler.plantranslate.NepheleJobGraphGenerator;
@@ -125,7 +126,7 @@ public class MapITCase extends TestBase
 
 		Plan plan = new Plan(output);
 
-		PactCompiler pc = new PactCompiler();
+		PactCompiler pc = new PactCompiler(new DataStatistics());
 		OptimizedPlan op = pc.compile(plan);
 
 		NepheleJobGraphGenerator jgg = new NepheleJobGraphGenerator();
diff --git a/pact/pact-tests/src/test/java/eu/stratosphere/pact/test/contracts/MatchITCase.java b/pact/pact-tests/src/test/java/eu/stratosphere/pact/test/contracts/MatchITCase.java
index b8dca12..3c40832 100644
--- a/pact/pact-tests/src/test/java/eu/stratosphere/pact/test/contracts/MatchITCase.java
+++ b/pact/pact-tests/src/test/java/eu/stratosphere/pact/test/contracts/MatchITCase.java
@@ -38,6 +38,7 @@ import eu.stratosphere.pact.common.stubs.MatchStub;
 import eu.stratosphere.pact.common.type.PactRecord;
 import eu.stratosphere.pact.common.type.base.PactInteger;
 import eu.stratosphere.pact.common.type.base.PactString;
+import eu.stratosphere.pact.compiler.DataStatistics;
 import eu.stratosphere.pact.compiler.PactCompiler;
 import eu.stratosphere.pact.compiler.plan.candidate.OptimizedPlan;
 import eu.stratosphere.pact.compiler.plantranslate.NepheleJobGraphGenerator;
@@ -175,7 +176,7 @@ public class MatchITCase extends TestBase
 
 		Plan plan = new Plan(output);
 
-		PactCompiler pc = new PactCompiler();
+		PactCompiler pc = new PactCompiler(new DataStatistics());
 		OptimizedPlan op = pc.compile(plan);
 
 		NepheleJobGraphGenerator jgg = new NepheleJobGraphGenerator();
diff --git a/pact/pact-tests/src/test/java/eu/stratosphere/pact/test/contracts/ReduceITCase.java b/pact/pact-tests/src/test/java/eu/stratosphere/pact/test/contracts/ReduceITCase.java
index 87db87f..9974f18 100644
--- a/pact/pact-tests/src/test/java/eu/stratosphere/pact/test/contracts/ReduceITCase.java
+++ b/pact/pact-tests/src/test/java/eu/stratosphere/pact/test/contracts/ReduceITCase.java
@@ -39,6 +39,7 @@ import eu.stratosphere.pact.common.stubs.ReduceStub;
 import eu.stratosphere.pact.common.type.PactRecord;
 import eu.stratosphere.pact.common.type.base.PactInteger;
 import eu.stratosphere.pact.common.type.base.PactString;
+import eu.stratosphere.pact.compiler.DataStatistics;
 import eu.stratosphere.pact.compiler.PactCompiler;
 import eu.stratosphere.pact.compiler.plan.candidate.OptimizedPlan;
 import eu.stratosphere.pact.compiler.plantranslate.NepheleJobGraphGenerator;
@@ -151,7 +152,7 @@ public class ReduceITCase extends TestBase
 
 		Plan plan = new Plan(output);
 
-		PactCompiler pc = new PactCompiler();
+		PactCompiler pc = new PactCompiler(new DataStatistics());
 		OptimizedPlan op = pc.compile(plan);
 
 		NepheleJobGraphGenerator jgg = new NepheleJobGraphGenerator();
diff --git a/pact/pact-tests/src/test/java/eu/stratosphere/pact/test/contracts/UnionITCase.java b/pact/pact-tests/src/test/java/eu/stratosphere/pact/test/contracts/UnionITCase.java
index 224f7a2..9466e29 100644
--- a/pact/pact-tests/src/test/java/eu/stratosphere/pact/test/contracts/UnionITCase.java
+++ b/pact/pact-tests/src/test/java/eu/stratosphere/pact/test/contracts/UnionITCase.java
@@ -38,6 +38,7 @@ import eu.stratosphere.pact.common.stubs.MapStub;
 import eu.stratosphere.pact.common.type.PactRecord;
 import eu.stratosphere.pact.common.type.base.PactInteger;
 import eu.stratosphere.pact.common.type.base.PactString;
+import eu.stratosphere.pact.compiler.DataStatistics;
 import eu.stratosphere.pact.compiler.PactCompiler;
 import eu.stratosphere.pact.compiler.plan.candidate.OptimizedPlan;
 import eu.stratosphere.pact.compiler.plantranslate.NepheleJobGraphGenerator;
@@ -150,7 +151,7 @@ public class UnionITCase extends TestBase
 
 		Plan plan = new Plan(output);
 
-		PactCompiler pc = new PactCompiler();
+		PactCompiler pc = new PactCompiler(new DataStatistics());
 		OptimizedPlan op = pc.compile(plan);
 
 		NepheleJobGraphGenerator jgg = new NepheleJobGraphGenerator();
diff --git a/pact/pact-tests/src/test/java/eu/stratosphere/pact/test/contracts/io/CustomDataTypeTest.java b/pact/pact-tests/src/test/java/eu/stratosphere/pact/test/contracts/io/CustomDataTypeTest.java
index aaa47fd..7a6f938 100644
--- a/pact/pact-tests/src/test/java/eu/stratosphere/pact/test/contracts/io/CustomDataTypeTest.java
+++ b/pact/pact-tests/src/test/java/eu/stratosphere/pact/test/contracts/io/CustomDataTypeTest.java
@@ -33,6 +33,7 @@ import eu.stratosphere.pact.common.contract.GenericDataSource;
 import eu.stratosphere.pact.common.io.GenericInputFormat;
 import eu.stratosphere.pact.common.plan.Plan;
 import eu.stratosphere.pact.common.type.PactRecord;
+import eu.stratosphere.pact.compiler.DataStatistics;
 import eu.stratosphere.pact.compiler.PactCompiler;
 import eu.stratosphere.pact.compiler.plan.candidate.OptimizedPlan;
 import eu.stratosphere.pact.compiler.plantranslate.NepheleJobGraphGenerator;
@@ -61,13 +62,10 @@ public class CustomDataTypeTest extends TestBase
 	}
 	
 	@Override
-	protected void postSubmit() throws Exception
-	{
-	}
+	protected void postSubmit() throws Exception {}
 	
 	@Override
-	protected JobGraph getJobGraph() throws Exception
-	{
+	protected JobGraph getJobGraph() throws Exception {
 		GenericDataSource<EmptyInputFormat> datasource = 
 				new GenericDataSource<EmptyInputFormat>(EmptyInputFormat.class, "Source");
 		datasource.getParameters().setString(CLASS_TO_INSTANTIATE_KEY, CLASS_TO_INSTANTIATE_NAME);
@@ -76,7 +74,7 @@ public class CustomDataTypeTest extends TestBase
 		sink.getParameters().setString(CLASS_TO_INSTANTIATE_KEY, CLASS_TO_INSTANTIATE_NAME);
 		
 		Plan plan = new Plan(sink);
-		PactCompiler pc = new PactCompiler();
+		PactCompiler pc = new PactCompiler(new DataStatistics());
 		OptimizedPlan op = pc.compile(plan);
 
 		NepheleJobGraphGenerator jgg = new NepheleJobGraphGenerator();
@@ -90,8 +88,8 @@ public class CustomDataTypeTest extends TestBase
 		return jobGraph;
 	}
 	
-	public static final class EmptyInputFormat extends GenericInputFormat
-	{
+	public static final class EmptyInputFormat extends GenericInputFormat {
+		
 		@Override
 		public void configure(Configuration parameters)	{
 			super.configure(parameters);
@@ -110,8 +108,8 @@ public class CustomDataTypeTest extends TestBase
 		}
 	}
 	
-	public static final class BlackholeOutputFormat implements OutputFormat<PactRecord>
-	{
+	public static final class BlackholeOutputFormat implements OutputFormat<PactRecord> {
+		
 		@Override
 		public void configure(Configuration parameters) {
 			// instantiate some user defined class
@@ -130,8 +128,7 @@ public class CustomDataTypeTest extends TestBase
 	}
 	
 	@Parameters
-	public static Collection<Object[]> getConfigurations()
-	{
+	public static Collection<Object[]> getConfigurations() {
 		List<Object[]> tConfigs = new ArrayList<Object[]>(1);
 		Configuration config = new Configuration();
 		config.setInteger("EnumTrianglesTest#NoSubtasks", 4);
diff --git a/pact/pact-tests/src/test/java/eu/stratosphere/pact/test/failingPrograms/TaskFailureITCase.java b/pact/pact-tests/src/test/java/eu/stratosphere/pact/test/failingPrograms/TaskFailureITCase.java
index b5d47c3..72fb597 100644
--- a/pact/pact-tests/src/test/java/eu/stratosphere/pact/test/failingPrograms/TaskFailureITCase.java
+++ b/pact/pact-tests/src/test/java/eu/stratosphere/pact/test/failingPrograms/TaskFailureITCase.java
@@ -38,6 +38,7 @@ import eu.stratosphere.pact.common.stubs.MapStub;
 import eu.stratosphere.pact.common.type.PactRecord;
 import eu.stratosphere.pact.common.type.base.PactInteger;
 import eu.stratosphere.pact.common.type.base.PactString;
+import eu.stratosphere.pact.compiler.DataStatistics;
 import eu.stratosphere.pact.compiler.PactCompiler;
 import eu.stratosphere.pact.compiler.plan.candidate.OptimizedPlan;
 import eu.stratosphere.pact.compiler.plantranslate.NepheleJobGraphGenerator;
@@ -124,7 +125,7 @@ public class TaskFailureITCase extends FailingTestBase {
 		Plan plan = new Plan(output);
 
 		// optimize and compile plan 
-		PactCompiler pc = new PactCompiler();
+		PactCompiler pc = new PactCompiler(new DataStatistics());
 		OptimizedPlan op = pc.compile(plan);
 		
 		// return job graph of failing job
@@ -165,7 +166,7 @@ public class TaskFailureITCase extends FailingTestBase {
 		Plan plan = new Plan(output);
 
 		// optimize and compile plan
-		PactCompiler pc = new PactCompiler();
+		PactCompiler pc = new PactCompiler(new DataStatistics());
 		OptimizedPlan op = pc.compile(plan);
 
 		// return job graph of working job
diff --git a/pact/pact-tests/src/test/java/eu/stratosphere/pact/test/iterative/IterativeKMeansITCase.java b/pact/pact-tests/src/test/java/eu/stratosphere/pact/test/iterative/IterativeKMeansITCase.java
index 2aacf36..27f0f92 100644
--- a/pact/pact-tests/src/test/java/eu/stratosphere/pact/test/iterative/IterativeKMeansITCase.java
+++ b/pact/pact-tests/src/test/java/eu/stratosphere/pact/test/iterative/IterativeKMeansITCase.java
@@ -24,15 +24,12 @@ import org.junit.runners.Parameterized.Parameters;
 
 import eu.stratosphere.nephele.configuration.Configuration;
 import eu.stratosphere.nephele.jobgraph.JobGraph;
-import eu.stratosphere.pact.common.contract.CrossContract;
-import eu.stratosphere.pact.common.contract.GenericDataSink;
-import eu.stratosphere.pact.common.contract.ReduceContract;
 import eu.stratosphere.pact.common.plan.Plan;
+import eu.stratosphere.pact.compiler.DataStatistics;
 import eu.stratosphere.pact.compiler.PactCompiler;
 import eu.stratosphere.pact.compiler.plan.candidate.OptimizedPlan;
 import eu.stratosphere.pact.compiler.plantranslate.NepheleJobGraphGenerator;
 import eu.stratosphere.pact.example.iterative.IterativeKMeans;
-import eu.stratosphere.pact.generic.contract.BulkIteration;
 import eu.stratosphere.pact.test.pactPrograms.KMeansIterationITCase;
 
 @RunWith(Parameterized.class)
@@ -52,13 +49,8 @@ public class IterativeKMeansITCase extends KMeansIterationITCase {
 				getFilesystemProvider().getURIPrefix() + clusterPath,  
 				getFilesystemProvider().getURIPrefix() + resultPath,
 				config.getString("IterativeKMeansITCase#NumIterations", "1"));
-		
-		final String presetShipStrat = config.getString("IterativeKMeansITCase#ShipStrategyDataPoints", null);
-		if (presetShipStrat != null) {
-			setParameterToCross(plan, "INPUT_LEFT_SHIP_STRATEGY", presetShipStrat);
-		}
 
-		PactCompiler pc = new PactCompiler();
+		PactCompiler pc = new PactCompiler(new DataStatistics());
 		OptimizedPlan op = pc.compile(plan);
 
 		NepheleJobGraphGenerator jgg = new NepheleJobGraphGenerator();
@@ -72,37 +64,25 @@ public class IterativeKMeansITCase extends KMeansIterationITCase {
 
 		Configuration config1 = new Configuration();
 		config1.setInteger("IterativeKMeansITCase#NoSubtasks", 4);
-		config1.setString("IterativeKMeansITCase#ShipStrategyDataPoints", "SHIP_FORWARD");
-		config1.setString("IterativeKMeansITCase#NumIterations", "1");
+		config1.setString("IterativeKMeansITCase#NumIterations", "20");
 		tConfigs.add(config1);
-		
-		Configuration config2 = new Configuration();
-		config2.setInteger("IterativeKMeansITCase#NoSubtasks", 4);
-		config2.setString("IterativeKMeansITCase#ShipStrategyDataPoints", "SHIP_BROADCAST");
-		config2.setString("IterativeKMeansITCase#NumIterations", "1");
-		tConfigs.add(config2);
-		
-		Configuration config3 = new Configuration();
-		config3.setInteger("IterativeKMeansITCase#NoSubtasks", 4);
-		config3.setString("IterativeKMeansITCase#ShipStrategyDataPoints", "SHIP_FORWARD");
-		config3.setString("IterativeKMeansITCase#NumIterations", "10");
-		tConfigs.add(config3);
-		
-		Configuration config4 = new Configuration();
-		config4.setInteger("IterativeKMeansITCase#NoSubtasks", 4);
-		config4.setString("IterativeKMeansITCase#ShipStrategyDataPoints", "SHIP_BROADCAST");
-		config4.setString("IterativeKMeansITCase#NumIterations", "10");
-		tConfigs.add(config4);
 
 		return toParameterList(tConfigs);
 	}
 	
-	public static void setParameterToCross(Plan p, String key, String value) {
-		GenericDataSink sink = p.getDataSinks().iterator().next();
-		BulkIteration iter = (BulkIteration) sink.getInputs().get(0);
-		ReduceContract reduce2 = (ReduceContract) iter.getNextPartialSolution();
-		ReduceContract reduce1 = (ReduceContract) reduce2.getInputs().get(0);
-		CrossContract cross = (CrossContract) reduce1.getInputs().get(0);
-		cross.getParameters().setString(key, value);
+
+	@Override
+	protected String getNewCenters() {
+		return CENTERS_AFTER_20_ITERATIONS;
 	}
+	
+	private static final String CENTERS_AFTER_20_ITERATIONS =
+			"0|38.25|54.52|19.34|\n" +
+			"1|32.14|83.04|50.35|\n" +
+			"2|87.48|56.57|20.27|\n" +
+			"3|75.40|18.65|67.49|\n" +
+			"4|24.93|29.25|77.56|\n" +
+			"5|78.67|66.07|70.82|\n" +
+			"6|39.51|14.04|18.74|\n";
+	
 }
diff --git a/pact/pact-tests/src/test/java/eu/stratosphere/pact/test/pactPrograms/EnumTrianglesITCase.java b/pact/pact-tests/src/test/java/eu/stratosphere/pact/test/pactPrograms/EnumTrianglesITCase.java
index 2c8cd5e..515e0bb 100644
--- a/pact/pact-tests/src/test/java/eu/stratosphere/pact/test/pactPrograms/EnumTrianglesITCase.java
+++ b/pact/pact-tests/src/test/java/eu/stratosphere/pact/test/pactPrograms/EnumTrianglesITCase.java
@@ -27,6 +27,7 @@ import org.junit.runners.Parameterized.Parameters;
 import eu.stratosphere.nephele.configuration.Configuration;
 import eu.stratosphere.nephele.jobgraph.JobGraph;
 import eu.stratosphere.pact.common.plan.Plan;
+import eu.stratosphere.pact.compiler.DataStatistics;
 import eu.stratosphere.pact.compiler.PactCompiler;
 import eu.stratosphere.pact.compiler.plan.candidate.OptimizedPlan;
 import eu.stratosphere.pact.compiler.plantranslate.NepheleJobGraphGenerator;
@@ -80,7 +81,7 @@ public class EnumTrianglesITCase extends TestBase {
 				getFilesystemProvider().getURIPrefix() + edgesPath, 
 				getFilesystemProvider().getURIPrefix() + resultPath);
 
-		PactCompiler pc = new PactCompiler();
+		PactCompiler pc = new PactCompiler(new DataStatistics());
 		OptimizedPlan op = pc.compile(plan);
 
 		NepheleJobGraphGenerator jgg = new NepheleJobGraphGenerator();
diff --git a/pact/pact-tests/src/test/java/eu/stratosphere/pact/test/pactPrograms/GlobalSortingITCase.java b/pact/pact-tests/src/test/java/eu/stratosphere/pact/test/pactPrograms/GlobalSortingITCase.java
index 83e7796..2984ffc 100644
--- a/pact/pact-tests/src/test/java/eu/stratosphere/pact/test/pactPrograms/GlobalSortingITCase.java
+++ b/pact/pact-tests/src/test/java/eu/stratosphere/pact/test/pactPrograms/GlobalSortingITCase.java
@@ -44,6 +44,7 @@ import eu.stratosphere.pact.common.plan.PlanAssembler;
 import eu.stratosphere.pact.common.type.PactRecord;
 import eu.stratosphere.pact.common.type.base.PactInteger;
 import eu.stratosphere.pact.common.type.base.parser.DecimalTextIntParser;
+import eu.stratosphere.pact.compiler.DataStatistics;
 import eu.stratosphere.pact.compiler.PactCompiler;
 import eu.stratosphere.pact.compiler.plan.candidate.OptimizedPlan;
 import eu.stratosphere.pact.compiler.plantranslate.NepheleJobGraphGenerator;
@@ -102,7 +103,7 @@ public class GlobalSortingITCase extends TestBase {
 				getFilesystemProvider().getURIPrefix()+recordsPath,
 				getFilesystemProvider().getURIPrefix()+resultPath);
 
-		PactCompiler pc = new PactCompiler();
+		PactCompiler pc = new PactCompiler(new DataStatistics());
 		OptimizedPlan op = pc.compile(plan);
 
 		NepheleJobGraphGenerator jgg = new NepheleJobGraphGenerator();
diff --git a/pact/pact-tests/src/test/java/eu/stratosphere/pact/test/pactPrograms/GlobalSortingMixedOrderITCase.java b/pact/pact-tests/src/test/java/eu/stratosphere/pact/test/pactPrograms/GlobalSortingMixedOrderITCase.java
index 73f2f56..014b23c 100644
--- a/pact/pact-tests/src/test/java/eu/stratosphere/pact/test/pactPrograms/GlobalSortingMixedOrderITCase.java
+++ b/pact/pact-tests/src/test/java/eu/stratosphere/pact/test/pactPrograms/GlobalSortingMixedOrderITCase.java
@@ -44,6 +44,7 @@ import eu.stratosphere.pact.common.plan.PlanAssembler;
 import eu.stratosphere.pact.common.type.PactRecord;
 import eu.stratosphere.pact.common.type.base.PactInteger;
 import eu.stratosphere.pact.common.type.base.parser.DecimalTextIntParser;
+import eu.stratosphere.pact.compiler.DataStatistics;
 import eu.stratosphere.pact.compiler.PactCompiler;
 import eu.stratosphere.pact.compiler.plan.candidate.OptimizedPlan;
 import eu.stratosphere.pact.compiler.plantranslate.NepheleJobGraphGenerator;
@@ -107,7 +108,7 @@ public class GlobalSortingMixedOrderITCase extends TestBase {
 				getFilesystemProvider().getURIPrefix()+recordsPath,
 				getFilesystemProvider().getURIPrefix()+resultPath);
 
-		PactCompiler pc = new PactCompiler();
+		PactCompiler pc = new PactCompiler(new DataStatistics());
 		OptimizedPlan op = pc.compile(plan);
 
 		NepheleJobGraphGenerator jgg = new NepheleJobGraphGenerator();
diff --git a/pact/pact-tests/src/test/java/eu/stratosphere/pact/test/pactPrograms/KMeansIteration2ITCase.java b/pact/pact-tests/src/test/java/eu/stratosphere/pact/test/pactPrograms/KMeansIteration2ITCase.java
deleted file mode 100644
index 853af75..0000000
--- a/pact/pact-tests/src/test/java/eu/stratosphere/pact/test/pactPrograms/KMeansIteration2ITCase.java
+++ /dev/null
@@ -1,334 +0,0 @@
-/***********************************************************************************************************************
- *
- * Copyright (C) 2010 by the Stratosphere project (http://stratosphere.eu)
- *
- * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with
- * the License. You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on
- * an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
- * specific language governing permissions and limitations under the License.
- *
- **********************************************************************************************************************/
-
-package eu.stratosphere.pact.test.pactPrograms;
-
-import java.text.DecimalFormat;
-import java.util.Collection;
-import java.util.Comparator;
-import java.util.LinkedList;
-import java.util.Random;
-import java.util.StringTokenizer;
-
-import org.apache.commons.logging.Log;
-import org.apache.commons.logging.LogFactory;
-import org.junit.runner.RunWith;
-import org.junit.runners.Parameterized;
-import org.junit.runners.Parameterized.Parameters;
-
-import eu.stratosphere.nephele.configuration.Configuration;
-import eu.stratosphere.nephele.jobgraph.JobGraph;
-import eu.stratosphere.pact.common.contract.CrossContract;
-import eu.stratosphere.pact.common.contract.GenericDataSink;
-import eu.stratosphere.pact.common.contract.ReduceContract;
-import eu.stratosphere.pact.common.plan.Plan;
-import eu.stratosphere.pact.compiler.PactCompiler;
-import eu.stratosphere.pact.compiler.plan.candidate.OptimizedPlan;
-import eu.stratosphere.pact.compiler.plantranslate.NepheleJobGraphGenerator;
-import eu.stratosphere.pact.example.datamining.KMeansIteration;
-import eu.stratosphere.pact.test.util.TestBase;
-
-@RunWith(Parameterized.class)
-public class KMeansIteration2ITCase extends TestBase {
-
-	private static final Log LOG = LogFactory.getLog(KMeansIteration2ITCase.class);
-
-	private final String DATAPOINTS = "0|50.90|16.20|72.08|\n" + "1|73.65|61.76|62.89|\n" + "2|61.73|49.95|92.74|\n"
-			+ "3|1.60|70.11|16.32|\n" + "4|2.43|19.81|89.56|\n" + "5|67.99|9.00|14.48|\n" + "6|87.80|84.49|55.83|\n"
-			+ "7|90.26|42.99|53.29|\n" + "8|51.36|6.16|9.35|\n" + "9|12.43|9.52|12.54|\n" + "10|80.01|8.78|29.74|\n"
-			+ "11|92.76|2.93|80.07|\n" + "12|46.32|100.00|22.98|\n" + "13|34.11|45.61|58.60|\n"
-			+ "14|68.82|16.36|96.60|\n" + "15|81.47|76.45|28.40|\n" + "16|65.55|40.21|43.43|\n"
-			+ "17|84.22|88.56|13.31|\n" + "18|36.99|68.36|57.12|\n" + "19|28.87|37.69|91.04|\n"
-			+ "20|31.56|13.22|86.00|\n" + "21|18.49|34.45|54.52|\n" + "22|13.33|94.02|92.07|\n"
-			+ "23|91.19|81.62|55.06|\n" + "24|85.78|39.02|25.58|\n" + "25|94.41|47.07|78.23|\n"
-			+ "26|90.62|10.43|80.20|\n" + "27|31.52|85.81|39.79|\n" + "28|24.65|77.98|26.35|\n"
-			+ "29|69.34|75.79|63.96|\n" + "30|22.56|78.61|66.66|\n" + "31|91.74|83.82|73.92|\n"
-			+ "32|76.64|89.53|44.66|\n" + "33|36.02|73.01|92.32|\n" + "34|87.86|18.94|10.74|\n"
-			+ "35|91.94|34.61|5.20|\n" + "36|12.52|47.01|95.29|\n" + "37|44.01|26.19|78.50|\n"
-			+ "38|26.20|73.36|10.08|\n" + "39|15.21|17.37|54.33|\n" + "40|27.96|94.81|44.41|\n"
-			+ "41|26.44|44.81|70.88|\n" + "42|53.29|26.69|2.40|\n" + "43|23.94|11.50|1.71|\n"
-			+ "44|19.00|25.48|50.80|\n" + "45|82.26|1.88|58.08|\n" + "46|47.56|82.54|82.73|\n"
-			+ "47|51.54|35.10|32.95|\n" + "48|86.71|55.51|19.08|\n" + "49|54.16|23.68|32.41|\n"
-			+ "50|71.81|32.83|46.66|\n" + "51|20.70|14.19|64.96|\n" + "52|57.17|88.56|55.23|\n"
-			+ "53|91.39|49.38|70.55|\n" + "54|47.90|62.07|76.03|\n" + "55|55.70|37.77|30.15|\n"
-			+ "56|87.87|74.62|25.95|\n" + "57|95.70|45.04|15.27|\n" + "58|41.61|89.37|24.45|\n"
-			+ "59|82.19|20.84|11.13|\n" + "60|49.88|2.62|18.62|\n" + "61|16.42|53.30|74.13|\n"
-			+ "62|38.37|72.62|35.16|\n" + "63|43.26|49.59|92.56|\n" + "64|28.96|2.36|78.49|\n"
-			+ "65|88.41|91.43|92.55|\n" + "66|98.61|79.58|33.03|\n" + "67|4.94|18.65|30.78|\n"
-			+ "68|75.89|79.30|63.90|\n" + "69|93.18|76.26|9.50|\n" + "70|73.43|70.50|76.49|\n"
-			+ "71|78.64|90.87|34.49|\n" + "72|58.47|63.07|8.82|\n" + "73|69.74|54.36|64.43|\n"
-			+ "74|38.47|36.60|33.39|\n" + "75|51.07|14.75|2.54|\n" + "76|24.18|16.85|15.00|\n"
-			+ "77|7.56|50.72|93.45|\n" + "78|64.28|97.01|57.31|\n" + "79|85.30|24.13|76.57|\n"
-			+ "80|72.78|30.78|13.11|\n" + "81|18.42|17.45|32.20|\n" + "82|87.44|74.98|87.90|\n"
-			+ "83|38.30|17.77|37.33|\n" + "84|63.62|7.90|34.23|\n" + "85|8.84|67.87|30.65|\n"
-			+ "86|76.12|51.83|80.12|\n" + "87|32.30|74.79|4.39|\n" + "88|41.73|45.34|18.66|\n"
-			+ "89|58.13|18.43|83.38|\n" + "90|98.10|33.46|83.07|\n" + "91|17.76|4.10|88.51|\n"
-			+ "92|60.58|18.15|59.96|\n" + "93|50.11|33.25|85.64|\n" + "94|97.74|60.93|38.97|\n"
-			+ "95|76.31|52.50|95.43|\n" + "96|7.71|85.85|36.26|\n" + "97|9.32|72.21|42.17|\n"
-			+ "98|71.29|51.88|57.62|\n" + "99|31.39|7.27|88.74|";
-
-	private final String CLUSTERCENTERS = "0|1.96|65.04|20.82|\n" + "1|53.99|84.23|81.59|\n" + "2|97.28|74.50|40.32|\n"
-			+ "3|63.57|24.53|87.07|\n" + "4|28.10|43.27|86.53|\n" + "5|99.51|62.70|64.48|\n" + "6|30.31|30.36|80.46|";
-
-	private final String NEWCLUSTERCENTERS = "0|28.47|54.80|21.88|\n" + "1|52.74|80.10|73.03|\n"
-			+ "2|83.92|60.45|25.17|\n" + "3|70.73|20.18|67.06|\n" + "4|22.51|47.19|86.23|\n" + "5|82.70|53.79|68.68|\n"
-			+ "6|29.74|19.17|59.16|";
-
-	protected String dataPath = null;
-	protected String clusterPath = null;
-	protected String resultPath = null;
-
-	public KMeansIteration2ITCase(Configuration config) {
-		super(config);
-	}
-
-	@Override
-	protected void preSubmit() throws Exception {
-
-		dataPath = getFilesystemProvider().getTempDirPath() + "/dataPoints";
-		clusterPath = getFilesystemProvider().getTempDirPath() + "/iter_0";
-		resultPath = getFilesystemProvider().getTempDirPath() + "/iter_1";
-		
-		int noPartitions = 4;
-
-		// create data path
-		getFilesystemProvider().createDir(dataPath);
-		
-		String[] splits = splitInputString(DATAPOINTS, '\n', noPartitions);
-
-		int i = 0;
-		for(String split : splits) {
-			getFilesystemProvider().createFile(dataPath + "/part_" + i++ + ".txt", split);
-			LOG.debug("DATAPOINT split "+i+": \n>" + split + "<");
-		}
-		
-		// create cluster path and copy data
-		getFilesystemProvider().createDir(clusterPath);
-		getFilesystemProvider().createFile(clusterPath+"/1", CLUSTERCENTERS);
-		LOG.debug("Clusters: \n>" + CLUSTERCENTERS + "<");
-
-	}
-
-	@Override
-	protected JobGraph getJobGraph() throws Exception {
-
-		KMeansIteration kmi = new KMeansIteration();
-
-		Plan plan = kmi.getPlan(config.getString("KMeansIterationTest#NoSubtasks", "1"), 
-				getFilesystemProvider().getURIPrefix()	+ dataPath, 
-				getFilesystemProvider().getURIPrefix() + clusterPath,  
-				getFilesystemProvider().getURIPrefix()	+ resultPath);
-		
-		setParameterToCross(plan, "INPUT_LEFT_SHIP_STRATEGY", "SHIP_FORWARD");
-
-		PactCompiler pc = new PactCompiler();
-		OptimizedPlan op = pc.compile(plan);
-
-		NepheleJobGraphGenerator jgg = new NepheleJobGraphGenerator();
-		return jgg.compileJobGraph(op);
-
-	}
-
-	@Override
-	protected void postSubmit() throws Exception {
-
-		Comparator<String> deltaComp = new Comparator<String>() {
-
-			private final double DELTA = 0.1;
-			
-			@Override
-			public int compare(String o1, String o2) {
-				
-				StringTokenizer st1 = new StringTokenizer(o1, "|");
-				StringTokenizer st2 = new StringTokenizer(o2, "|");
-				
-				if(st1.countTokens() != st2.countTokens()) {
-					return st1.countTokens() - st2.countTokens();
-				}
-				
-				// first token is ID
-				String t1 = st1.nextToken();
-				String t2 = st2.nextToken();
-				if(!t1.equals(t2)) {
-					return t1.compareTo(t2);
-				}
-				
-				while(st1.hasMoreTokens()) {
-					t1 = st1.nextToken();
-					t2 = st2.nextToken();
-					
-					double d1 = Double.parseDouble(t1);
-					double d2 = Double.parseDouble(t2);
-					
-					if(Math.abs(d1-d2) > DELTA) {
-						return d1 < d2 ? -1 : 1;
-					}
-				}
-				
-				return 0;
-			}
-		};
-		
-		// Test results
-		compareResultsByLinesInMemory(NEWCLUSTERCENTERS, resultPath, deltaComp);
-
-		// clean up file
-		getFilesystemProvider().delete(dataPath, true);
-		getFilesystemProvider().delete(clusterPath, true);
-		getFilesystemProvider().delete(resultPath, true);
-
-	}
-
-	@Parameters
-	public static Collection<Object[]> getConfigurations() {
-
-		LinkedList<Configuration> tConfigs = new LinkedList<Configuration>();
-
-		Configuration config = new Configuration();
-		config.setInteger("KMeansIterationTest#NoSubtasks", 4);
-		tConfigs.add(config);
-
-		return toParameterList(tConfigs);
-	}
-
-	private String[] splitInputString(String inputString, char splitChar, int noSplits) {
-
-		String splitString = inputString.toString();
-		String[] splits = new String[noSplits];
-		int partitionSize = (splitString.length() / noSplits) - 2;
-
-		// split data file and copy parts
-		for (int i = 0; i < noSplits - 1; i++) {
-			int cutPos = splitString.indexOf(splitChar, (partitionSize < splitString.length() ? partitionSize
-				: (splitString.length() - 1)));
-			splits[i] = splitString.substring(0, cutPos) + "\n";
-			splitString = splitString.substring(cutPos + 1);
-		}
-		splits[noSplits - 1] = splitString;
-
-		return splits;
-
-	}
-
-	public static class KMeanDataGenerator {
-
-		int noPoints;
-		int noClusters;
-		int noDims;
-
-		Random rand = new Random(System.currentTimeMillis());
-
-		double[][] dataPoints;
-		double[][] centers;
-		double[][] newCenters;
-
-		public KMeanDataGenerator(int noPoints, int noClusters, int noDims) {
-			this.noPoints = noPoints;
-			this.noClusters = noClusters;
-			this.noDims = noDims;
-
-			this.dataPoints = new double[noPoints][noDims];
-			this.centers = new double[noClusters][noDims];
-			this.newCenters = new double[noClusters][noDims];
-
-			// init data points
-			for (int i = 0; i < noPoints; i++) {
-				for (int j = 0; j < noDims; j++) {
-					dataPoints[i][j] = rand.nextDouble() * 100;
-				}
-			}
-
-			// init centers
-			for (int i = 0; i < noClusters; i++) {
-				for (int j = 0; j < noDims; j++) {
-					centers[i][j] = rand.nextDouble() * 100;
-				}
-			}
-
-			// compute new centers
-			int[] dataPointCnt = new int[noClusters];
-
-			for (int i = 0; i < noPoints; i++) {
-
-				double minDist = Double.MAX_VALUE;
-				int nearestCluster = 0;
-				for (int j = 0; j < noClusters; j++) {
-					double dist = computeDistance(dataPoints[i], centers[j]);
-					if (dist < minDist) {
-						minDist = dist;
-						nearestCluster = j;
-					}
-				}
-
-				for (int k = 0; k < noDims; k++) {
-					newCenters[nearestCluster][k] += dataPoints[i][k];
-				}
-				dataPointCnt[nearestCluster]++;
-
-			}
-
-			for (int i = 0; i < noClusters; i++) {
-				for (int j = 0; j < noDims; j++) {
-					newCenters[i][j] /= (dataPointCnt[i] != 0 ? dataPointCnt[i] : 1);
-				}
-			}
-		}
-
-		public String getDataPoints() {
-			return points2String(this.dataPoints);
-		}
-
-		public String getClusterCenters() {
-			return points2String(centers);
-		}
-
-		public String getNewClusterCenters() {
-			return points2String(newCenters);
-		}
-
-		private String points2String(double[][] points) {
-			StringBuilder sb = new StringBuilder();
-			DecimalFormat df = new DecimalFormat("#.00");
-
-			for (int i = 0; i < points.length; i++) {
-				sb.append(i);
-				sb.append('|');
-				for (int j = 0; j < points[i].length; j++) {
-					sb.append(df.format(points[i][j]));
-					sb.append('|');
-				}
-				sb.append('\n');
-			}
-			return sb.toString();
-		}
-
-		private double computeDistance(double[] a, double[] b) {
-			double sqrdSum = 0.0;
-			for (int i = 0; i < a.length; i++) {
-				sqrdSum += Math.pow(a[i] - b[i], 2);
-			}
-			return Math.sqrt(sqrdSum);
-		}
-
-	}
-	
-	public static void setParameterToCross(Plan p, String key, String value) {
-		GenericDataSink sink = p.getDataSinks().iterator().next();
-		ReduceContract reduce2 = (ReduceContract) sink.getInputs().get(0);
-		ReduceContract reduce1 = (ReduceContract) reduce2.getInputs().get(0);
-		CrossContract cross = (CrossContract) reduce1.getInputs().get(0);
-		cross.getParameters().setString(key, value);
-	}
-}
diff --git a/pact/pact-tests/src/test/java/eu/stratosphere/pact/test/pactPrograms/KMeansIterationITCase.java b/pact/pact-tests/src/test/java/eu/stratosphere/pact/test/pactPrograms/KMeansIterationITCase.java
index 4b112fa..987e79b 100644
--- a/pact/pact-tests/src/test/java/eu/stratosphere/pact/test/pactPrograms/KMeansIterationITCase.java
+++ b/pact/pact-tests/src/test/java/eu/stratosphere/pact/test/pactPrograms/KMeansIterationITCase.java
@@ -15,15 +15,22 @@
 
 package eu.stratosphere.pact.test.pactPrograms;
 
+import java.io.BufferedReader;
+import java.io.InputStream;
+import java.io.InputStreamReader;
 import java.text.DecimalFormat;
+import java.util.ArrayList;
 import java.util.Collection;
+import java.util.Collections;
 import java.util.Comparator;
-import java.util.LinkedList;
+import java.util.List;
+
 import java.util.Random;
 import java.util.StringTokenizer;
 
 import org.apache.commons.logging.Log;
 import org.apache.commons.logging.LogFactory;
+import org.junit.Assert;
 import org.junit.runner.RunWith;
 import org.junit.runners.Parameterized;
 import org.junit.runners.Parameterized.Parameters;
@@ -34,6 +41,7 @@ import eu.stratosphere.pact.common.contract.CrossContract;
 import eu.stratosphere.pact.common.contract.GenericDataSink;
 import eu.stratosphere.pact.common.contract.ReduceContract;
 import eu.stratosphere.pact.common.plan.Plan;
+import eu.stratosphere.pact.compiler.DataStatistics;
 import eu.stratosphere.pact.compiler.PactCompiler;
 import eu.stratosphere.pact.compiler.plan.candidate.OptimizedPlan;
 import eu.stratosphere.pact.compiler.plantranslate.NepheleJobGraphGenerator;
@@ -45,7 +53,7 @@ public class KMeansIterationITCase extends TestBase {
 
 	private static final Log LOG = LogFactory.getLog(KMeansIterationITCase.class);
 
-	private final String DATAPOINTS = "0|50.90|16.20|72.08|\n" + "1|73.65|61.76|62.89|\n" + "2|61.73|49.95|92.74|\n"
+	public final String DATAPOINTS = "0|50.90|16.20|72.08|\n" + "1|73.65|61.76|62.89|\n" + "2|61.73|49.95|92.74|\n"
 			+ "3|1.60|70.11|16.32|\n" + "4|2.43|19.81|89.56|\n" + "5|67.99|9.00|14.48|\n" + "6|87.80|84.49|55.83|\n"
 			+ "7|90.26|42.99|53.29|\n" + "8|51.36|6.16|9.35|\n" + "9|12.43|9.52|12.54|\n" + "10|80.01|8.78|29.74|\n"
 			+ "11|92.76|2.93|80.07|\n" + "12|46.32|100.00|22.98|\n" + "13|34.11|45.61|58.60|\n"
@@ -79,7 +87,7 @@ public class KMeansIterationITCase extends TestBase {
 			+ "95|76.31|52.50|95.43|\n" + "96|7.71|85.85|36.26|\n" + "97|9.32|72.21|42.17|\n"
 			+ "98|71.29|51.88|57.62|\n" + "99|31.39|7.27|88.74|";
 
-	private final String CLUSTERCENTERS = "0|1.96|65.04|20.82|\n" + "1|53.99|84.23|81.59|\n" + "2|97.28|74.50|40.32|\n"
+	public final String CLUSTERCENTERS = "0|1.96|65.04|20.82|\n" + "1|53.99|84.23|81.59|\n" + "2|97.28|74.50|40.32|\n"
 			+ "3|63.57|24.53|87.07|\n" + "4|28.10|43.27|86.53|\n" + "5|99.51|62.70|64.48|\n" + "6|30.31|30.36|80.46|";
 
 	private final String NEWCLUSTERCENTERS = "0|28.47|54.80|21.88|\n" + "1|52.74|80.10|73.03|\n"
@@ -90,9 +98,14 @@ public class KMeansIterationITCase extends TestBase {
 	protected String clusterPath = null;
 	protected String resultPath = null;
 
+	
 	public KMeansIterationITCase(Configuration config) {
 		super(config);
 	}
+	
+	protected String getNewCenters() {
+		return NEWCLUSTERCENTERS;
+	}
 
 	@Override
 	protected void preSubmit() throws Exception {
@@ -109,15 +122,18 @@ public class KMeansIterationITCase extends TestBase {
 		String[] splits = splitInputString(DATAPOINTS, '\n', noPartitions);
 
 		int i = 0;
-		for(String split : splits) {
+		for (String split : splits) {
 			getFilesystemProvider().createFile(dataPath + "/part_" + i++ + ".txt", split);
-			LOG.debug("DATAPOINT split "+i+": \n>" + split + "<");
+			if (LOG.isDebugEnabled())
+				LOG.debug("DATAPOINT split "+i+": \n>" + split + "<");
 		}
 		
 		// create cluster path and copy data
 		getFilesystemProvider().createDir(clusterPath);
 		getFilesystemProvider().createFile(clusterPath+"/1", CLUSTERCENTERS);
-		LOG.debug("Clusters: \n>" + CLUSTERCENTERS + "<");
+		
+		if (LOG.isDebugEnabled())
+			LOG.debug("Clusters: \n>" + CLUSTERCENTERS + "<");
 
 	}
 
@@ -131,9 +147,9 @@ public class KMeansIterationITCase extends TestBase {
 				getFilesystemProvider().getURIPrefix() + clusterPath,  
 				getFilesystemProvider().getURIPrefix()	+ resultPath);
 		
-		setParameterToCross(plan, "INPUT_RIGHT_SHIP_STRATEGY", "SHIP_FORWARD");
+		setParameterToCross(plan, config.getString("KMeansIterationTest#ForwardSide", null), PactCompiler.HINT_SHIP_STRATEGY_FORWARD);
 
-		PactCompiler pc = new PactCompiler();
+		PactCompiler pc = new PactCompiler(new DataStatistics());
 		OptimizedPlan op = pc.compile(plan);
 
 		NepheleJobGraphGenerator jgg = new NepheleJobGraphGenerator();
@@ -144,10 +160,10 @@ public class KMeansIterationITCase extends TestBase {
 	@Override
 	protected void postSubmit() throws Exception {
 
+		final double MAX_DELTA = 0.1;
+		
 		Comparator<String> deltaComp = new Comparator<String>() {
 
-			private final double DELTA = 0.1;
-			
 			@Override
 			public int compare(String o1, String o2) {
 				
@@ -172,7 +188,7 @@ public class KMeansIterationITCase extends TestBase {
 					double d1 = Double.parseDouble(t1);
 					double d2 = Double.parseDouble(t2);
 					
-					if(Math.abs(d1-d2) > DELTA) {
+					if (Math.abs(d1-d2) > MAX_DELTA) {
 						return d1 < d2 ? -1 : 1;
 					}
 				}
@@ -181,9 +197,66 @@ public class KMeansIterationITCase extends TestBase {
 			}
 		};
 		
-		// Test results
-		compareResultsByLinesInMemory(NEWCLUSTERCENTERS, resultPath, deltaComp);
+		// ------- Test results -----------
+		
+		// Determine all result files
+		ArrayList<String> resultFiles = new ArrayList<String>();
+		if (getFilesystemProvider().isDir(resultPath)) {
+			for (String file : getFilesystemProvider().listFiles(resultPath)) {
+				if (!getFilesystemProvider().isDir(file)) {
+					resultFiles.add(resultPath+"/"+file);
+				}
+			}
+		} else {
+			resultFiles.add(resultPath);
+		}
 
+		// collect lines of all result files
+		ArrayList<String> resultLines = new ArrayList<String>();
+		for (String resultFile : resultFiles) {
+			// read each result file
+			InputStream is = getFilesystemProvider().getInputStream(resultFile);
+			BufferedReader reader = new BufferedReader(new InputStreamReader(is));
+			String line = reader.readLine();
+
+			// collect lines
+			while (line != null) {
+				resultLines.add(line);
+				line = reader.readLine();
+			}
+			reader.close();
+		}
+		
+		Collections.sort(resultLines, deltaComp);
+		
+		final String[] should = getNewCenters().split("\n");
+		final String[] is = (String[]) resultLines.toArray(new String[resultLines.size()]);
+		
+		Assert.assertEquals("Wrong number of result lines.", should.length, is.length);
+		
+		for (int i = 0; i < should.length; i++) {
+			StringTokenizer shouldRecord = new StringTokenizer(should[i], "|");
+			StringTokenizer isRecord = new StringTokenizer(is[i], "|");
+			
+			Assert.assertEquals("Records don't match.", shouldRecord.countTokens(), isRecord.countTokens());
+			
+			// first token is ID
+			String shouldToken = shouldRecord.nextToken();
+			String isToken = isRecord.nextToken();
+			
+			Assert.assertEquals("Records don't match.", shouldToken, isToken);
+
+			while (shouldRecord.hasMoreTokens()) {
+				shouldToken = shouldRecord.nextToken();
+				isToken = isRecord.nextToken();
+				
+				double shouldDouble = Double.parseDouble(shouldToken);
+				double isDouble = Double.parseDouble(isToken);
+				
+				Assert.assertTrue(shouldDouble - MAX_DELTA < isDouble && shouldDouble + MAX_DELTA > isDouble);
+			}
+		}
+		
 		// clean up file
 		getFilesystemProvider().delete(dataPath, true);
 		getFilesystemProvider().delete(clusterPath, true);
@@ -194,10 +267,16 @@ public class KMeansIterationITCase extends TestBase {
 	@Parameters
 	public static Collection<Object[]> getConfigurations() {
 
-		LinkedList<Configuration> tConfigs = new LinkedList<Configuration>();
+		List<Configuration> tConfigs = new ArrayList<Configuration>();
 
 		Configuration config = new Configuration();
 		config.setInteger("KMeansIterationTest#NoSubtasks", 4);
+		config.setString("KMeansIterationTest#ForwardSide", PactCompiler.HINT_SHIP_STRATEGY_FIRST_INPUT);
+		tConfigs.add(config);
+		
+		config = new Configuration();
+		config.setInteger("KMeansIterationTest#NoSubtasks", 4);
+		config.setString("KMeansIterationTest#ForwardSide", PactCompiler.HINT_SHIP_STRATEGY_SECOND_INPUT);
 		tConfigs.add(config);
 
 		return toParameterList(tConfigs);
diff --git a/pact/pact-tests/src/test/java/eu/stratosphere/pact/test/pactPrograms/MergeOnlyJoinITCase.java b/pact/pact-tests/src/test/java/eu/stratosphere/pact/test/pactPrograms/MergeOnlyJoinITCase.java
index ea87823..698193b 100644
--- a/pact/pact-tests/src/test/java/eu/stratosphere/pact/test/pactPrograms/MergeOnlyJoinITCase.java
+++ b/pact/pact-tests/src/test/java/eu/stratosphere/pact/test/pactPrograms/MergeOnlyJoinITCase.java
@@ -27,6 +27,7 @@ import org.junit.runners.Parameterized.Parameters;
 import eu.stratosphere.nephele.configuration.Configuration;
 import eu.stratosphere.nephele.jobgraph.JobGraph;
 import eu.stratosphere.pact.common.plan.Plan;
+import eu.stratosphere.pact.compiler.DataStatistics;
 import eu.stratosphere.pact.compiler.PactCompiler;
 import eu.stratosphere.pact.compiler.plan.candidate.OptimizedPlan;
 import eu.stratosphere.pact.compiler.plantranslate.NepheleJobGraphGenerator;
@@ -108,7 +109,7 @@ public class MergeOnlyJoinITCase extends TestBase {
 				getFilesystemProvider().getURIPrefix()+resultPath,
 				config.getString("MergeOnlyJoinTest#NoSubtasksInput2", "1"));
 
-		PactCompiler pc = new PactCompiler();
+		PactCompiler pc = new PactCompiler(new DataStatistics());
 		OptimizedPlan op = pc.compile(plan);
 
 		NepheleJobGraphGenerator jgg = new NepheleJobGraphGenerator();
diff --git a/pact/pact-tests/src/test/java/eu/stratosphere/pact/test/pactPrograms/PairwiseSPITCase.java b/pact/pact-tests/src/test/java/eu/stratosphere/pact/test/pactPrograms/PairwiseSPITCase.java
index 3a772a7..37a7caa 100644
--- a/pact/pact-tests/src/test/java/eu/stratosphere/pact/test/pactPrograms/PairwiseSPITCase.java
+++ b/pact/pact-tests/src/test/java/eu/stratosphere/pact/test/pactPrograms/PairwiseSPITCase.java
@@ -27,6 +27,7 @@ import org.junit.runners.Parameterized.Parameters;
 import eu.stratosphere.nephele.configuration.Configuration;
 import eu.stratosphere.nephele.jobgraph.JobGraph;
 import eu.stratosphere.pact.common.plan.Plan;
+import eu.stratosphere.pact.compiler.DataStatistics;
 import eu.stratosphere.pact.compiler.PactCompiler;
 import eu.stratosphere.pact.compiler.plan.candidate.OptimizedPlan;
 import eu.stratosphere.pact.compiler.plantranslate.NepheleJobGraphGenerator;
@@ -92,7 +93,7 @@ public class PairwiseSPITCase extends TestBase {
 				getFilesystemProvider().getURIPrefix() + resultPath, 
 				"true");
 
-		PactCompiler pc = new PactCompiler();
+		PactCompiler pc = new PactCompiler(new DataStatistics());
 		OptimizedPlan op = pc.compile(plan);
 
 		NepheleJobGraphGenerator jgg = new NepheleJobGraphGenerator();
diff --git a/pact/pact-tests/src/test/java/eu/stratosphere/pact/test/pactPrograms/TPCHQuery10ITCase.java b/pact/pact-tests/src/test/java/eu/stratosphere/pact/test/pactPrograms/TPCHQuery10ITCase.java
index 8388268..4cba2fe 100644
--- a/pact/pact-tests/src/test/java/eu/stratosphere/pact/test/pactPrograms/TPCHQuery10ITCase.java
+++ b/pact/pact-tests/src/test/java/eu/stratosphere/pact/test/pactPrograms/TPCHQuery10ITCase.java
@@ -27,6 +27,7 @@ import org.junit.runners.Parameterized.Parameters;
 import eu.stratosphere.nephele.configuration.Configuration;
 import eu.stratosphere.nephele.jobgraph.JobGraph;
 import eu.stratosphere.pact.common.plan.Plan;
+import eu.stratosphere.pact.compiler.DataStatistics;
 import eu.stratosphere.pact.compiler.PactCompiler;
 import eu.stratosphere.pact.compiler.plan.candidate.OptimizedPlan;
 import eu.stratosphere.pact.compiler.plantranslate.NepheleJobGraphGenerator;
@@ -200,7 +201,7 @@ public class TPCHQuery10ITCase extends TestBase {
 				getFilesystemProvider().getURIPrefix() + nationsPath,
 				getFilesystemProvider().getURIPrefix() + resultPath);
 
-		PactCompiler pc = new PactCompiler();
+		PactCompiler pc = new PactCompiler(new DataStatistics());
 		OptimizedPlan op = pc.compile(plan);
 
 		NepheleJobGraphGenerator jgg = new NepheleJobGraphGenerator();
diff --git a/pact/pact-tests/src/test/java/eu/stratosphere/pact/test/pactPrograms/TPCHQuery3WithUnionITCase.java b/pact/pact-tests/src/test/java/eu/stratosphere/pact/test/pactPrograms/TPCHQuery3WithUnionITCase.java
index b6f7e8f..27eef75 100644
--- a/pact/pact-tests/src/test/java/eu/stratosphere/pact/test/pactPrograms/TPCHQuery3WithUnionITCase.java
+++ b/pact/pact-tests/src/test/java/eu/stratosphere/pact/test/pactPrograms/TPCHQuery3WithUnionITCase.java
@@ -27,6 +27,7 @@ import org.junit.runners.Parameterized.Parameters;
 import eu.stratosphere.nephele.configuration.Configuration;
 import eu.stratosphere.nephele.jobgraph.JobGraph;
 import eu.stratosphere.pact.common.plan.Plan;
+import eu.stratosphere.pact.compiler.DataStatistics;
 import eu.stratosphere.pact.compiler.PactCompiler;
 import eu.stratosphere.pact.compiler.plan.candidate.OptimizedPlan;
 import eu.stratosphere.pact.compiler.plantranslate.NepheleJobGraphGenerator;
@@ -204,7 +205,7 @@ public class TPCHQuery3WithUnionITCase extends TestBase {
 				getFilesystemProvider().getURIPrefix()+lineitemsPath, 
 				getFilesystemProvider().getURIPrefix()+resultPath);
 
-		PactCompiler pc = new PactCompiler();
+		PactCompiler pc = new PactCompiler(new DataStatistics());
 		OptimizedPlan op = pc.compile(plan);
 
 		NepheleJobGraphGenerator jgg = new NepheleJobGraphGenerator();
diff --git a/pact/pact-tests/src/test/java/eu/stratosphere/pact/test/pactPrograms/TPCHQuery4ITCase.java b/pact/pact-tests/src/test/java/eu/stratosphere/pact/test/pactPrograms/TPCHQuery4ITCase.java
index d02d237..c41692f 100644
--- a/pact/pact-tests/src/test/java/eu/stratosphere/pact/test/pactPrograms/TPCHQuery4ITCase.java
+++ b/pact/pact-tests/src/test/java/eu/stratosphere/pact/test/pactPrograms/TPCHQuery4ITCase.java
@@ -27,6 +27,7 @@ import org.junit.runners.Parameterized.Parameters;
 import eu.stratosphere.nephele.configuration.Configuration;
 import eu.stratosphere.nephele.jobgraph.JobGraph;
 import eu.stratosphere.pact.common.plan.Plan;
+import eu.stratosphere.pact.compiler.DataStatistics;
 import eu.stratosphere.pact.compiler.PactCompiler;
 import eu.stratosphere.pact.compiler.plan.candidate.OptimizedPlan;
 import eu.stratosphere.pact.compiler.plantranslate.NepheleJobGraphGenerator;
@@ -173,7 +174,7 @@ public class TPCHQuery4ITCase extends TestBase {
 				getFilesystemProvider().getURIPrefix()+lineitemsPath, 
 				getFilesystemProvider().getURIPrefix()+resultPath);
 
-		PactCompiler pc = new PactCompiler();
+		PactCompiler pc = new PactCompiler(new DataStatistics());
 		OptimizedPlan op = pc.compile(plan);
 
 		NepheleJobGraphGenerator jgg = new NepheleJobGraphGenerator();
diff --git a/pact/pact-tests/src/test/java/eu/stratosphere/pact/test/pactPrograms/TPCHQuery9ITCase.java b/pact/pact-tests/src/test/java/eu/stratosphere/pact/test/pactPrograms/TPCHQuery9ITCase.java
index 1a15224..2d7dd24 100644
--- a/pact/pact-tests/src/test/java/eu/stratosphere/pact/test/pactPrograms/TPCHQuery9ITCase.java
+++ b/pact/pact-tests/src/test/java/eu/stratosphere/pact/test/pactPrograms/TPCHQuery9ITCase.java
@@ -27,6 +27,7 @@ import org.junit.runners.Parameterized.Parameters;
 import eu.stratosphere.nephele.configuration.Configuration;
 import eu.stratosphere.nephele.jobgraph.JobGraph;
 import eu.stratosphere.pact.common.plan.Plan;
+import eu.stratosphere.pact.compiler.DataStatistics;
 import eu.stratosphere.pact.compiler.PactCompiler;
 import eu.stratosphere.pact.compiler.plan.candidate.OptimizedPlan;
 import eu.stratosphere.pact.compiler.plantranslate.NepheleJobGraphGenerator;
@@ -395,7 +396,7 @@ public class TPCHQuery9ITCase extends TestBase {
 				getFilesystemProvider().getURIPrefix()+nationInputPath,
 				getFilesystemProvider().getURIPrefix()+resultPath);
 
-		PactCompiler pc = new PactCompiler();
+		PactCompiler pc = new PactCompiler(new DataStatistics());
 		OptimizedPlan op = pc.compile(plan);
 
 		NepheleJobGraphGenerator jgg = new NepheleJobGraphGenerator();
diff --git a/pact/pact-tests/src/test/java/eu/stratosphere/pact/test/pactPrograms/TPCHQueryAsterixITCase.java b/pact/pact-tests/src/test/java/eu/stratosphere/pact/test/pactPrograms/TPCHQueryAsterixITCase.java
index a72675b..1e3df18 100644
--- a/pact/pact-tests/src/test/java/eu/stratosphere/pact/test/pactPrograms/TPCHQueryAsterixITCase.java
+++ b/pact/pact-tests/src/test/java/eu/stratosphere/pact/test/pactPrograms/TPCHQueryAsterixITCase.java
@@ -27,6 +27,7 @@ import org.junit.runners.Parameterized.Parameters;
 import eu.stratosphere.nephele.configuration.Configuration;
 import eu.stratosphere.nephele.jobgraph.JobGraph;
 import eu.stratosphere.pact.common.plan.Plan;
+import eu.stratosphere.pact.compiler.DataStatistics;
 import eu.stratosphere.pact.compiler.PactCompiler;
 import eu.stratosphere.pact.compiler.plan.candidate.OptimizedPlan;
 import eu.stratosphere.pact.compiler.plantranslate.NepheleJobGraphGenerator;
@@ -118,7 +119,7 @@ public class TPCHQueryAsterixITCase extends TestBase {
 				getFilesystemProvider().getURIPrefix()+custPath, 
 				getFilesystemProvider().getURIPrefix()+resultPath);
 
-		PactCompiler pc = new PactCompiler();
+		PactCompiler pc = new PactCompiler(new DataStatistics());
 		OptimizedPlan op = pc.compile(plan);
 
 		NepheleJobGraphGenerator jgg = new NepheleJobGraphGenerator();
diff --git a/pact/pact-tests/src/test/java/eu/stratosphere/pact/test/pactPrograms/TeraSortITCase.java b/pact/pact-tests/src/test/java/eu/stratosphere/pact/test/pactPrograms/TeraSortITCase.java
index 09bda8b..33a5aa5 100644
--- a/pact/pact-tests/src/test/java/eu/stratosphere/pact/test/pactPrograms/TeraSortITCase.java
+++ b/pact/pact-tests/src/test/java/eu/stratosphere/pact/test/pactPrograms/TeraSortITCase.java
@@ -31,6 +31,7 @@ import org.junit.runners.Parameterized.Parameters;
 import eu.stratosphere.nephele.configuration.Configuration;
 import eu.stratosphere.nephele.jobgraph.JobGraph;
 import eu.stratosphere.pact.common.plan.Plan;
+import eu.stratosphere.pact.compiler.DataStatistics;
 import eu.stratosphere.pact.compiler.PactCompiler;
 import eu.stratosphere.pact.compiler.plan.candidate.OptimizedPlan;
 import eu.stratosphere.pact.compiler.plantranslate.NepheleJobGraphGenerator;
@@ -64,7 +65,7 @@ public class TeraSortITCase extends TestBase
 		Plan plan = ts.getPlan(this.config.getString("TeraSortITCase#NoSubtasks", "1"),
 			inPath, getFilesystemProvider().getURIPrefix() + resultPath);
 
-		PactCompiler pc = new PactCompiler();
+		PactCompiler pc = new PactCompiler(new DataStatistics());
 		OptimizedPlan op = pc.compile(plan);
 
 		NepheleJobGraphGenerator jgg = new NepheleJobGraphGenerator();
diff --git a/pact/pact-tests/src/test/java/eu/stratosphere/pact/test/pactPrograms/WebLogAnalysisITCase.java b/pact/pact-tests/src/test/java/eu/stratosphere/pact/test/pactPrograms/WebLogAnalysisITCase.java
index 3a0068c..d7e3543 100644
--- a/pact/pact-tests/src/test/java/eu/stratosphere/pact/test/pactPrograms/WebLogAnalysisITCase.java
+++ b/pact/pact-tests/src/test/java/eu/stratosphere/pact/test/pactPrograms/WebLogAnalysisITCase.java
@@ -27,6 +27,7 @@ import org.junit.runners.Parameterized.Parameters;
 import eu.stratosphere.nephele.configuration.Configuration;
 import eu.stratosphere.nephele.jobgraph.JobGraph;
 import eu.stratosphere.pact.common.plan.Plan;
+import eu.stratosphere.pact.compiler.DataStatistics;
 import eu.stratosphere.pact.compiler.PactCompiler;
 import eu.stratosphere.pact.compiler.plan.candidate.OptimizedPlan;
 import eu.stratosphere.pact.compiler.plantranslate.NepheleJobGraphGenerator;
@@ -217,7 +218,7 @@ public class WebLogAnalysisITCase extends TestBase {
 			getFilesystemProvider().getURIPrefix()+visitsPath, 
 			getFilesystemProvider().getURIPrefix()+resultPath);
 
-		PactCompiler pc = new PactCompiler();
+		PactCompiler pc = new PactCompiler(new DataStatistics());
 		OptimizedPlan op = pc.compile(plan);
 
 		NepheleJobGraphGenerator jgg = new NepheleJobGraphGenerator();
diff --git a/pact/pact-tests/src/test/java/eu/stratosphere/pact/test/testPrograms/mergeOnlyJoin/MergeOnlyJoin.java b/pact/pact-tests/src/test/java/eu/stratosphere/pact/test/testPrograms/mergeOnlyJoin/MergeOnlyJoin.java
index 481124e..bb22151 100644
--- a/pact/pact-tests/src/test/java/eu/stratosphere/pact/test/testPrograms/mergeOnlyJoin/MergeOnlyJoin.java
+++ b/pact/pact-tests/src/test/java/eu/stratosphere/pact/test/testPrograms/mergeOnlyJoin/MergeOnlyJoin.java
@@ -40,36 +40,30 @@ public class MergeOnlyJoin implements PlanAssembler, PlanAssemblerDescription {
 
 	@ConstantFieldsFirstExcept(fields={2})
 	@OutCardBounds(upperBound=1, lowerBound=1)
-	public static class JoinInputs extends MatchStub
-	{
+	public static class JoinInputs extends MatchStub {
 		@Override
-		public void match(PactRecord input1, PactRecord input2, Collector<PactRecord> out)
-		{
+		public void match(PactRecord input1, PactRecord input2, Collector<PactRecord> out) {
 			input1.setField(2, input2.getField(1, PactInteger.class));
 			out.collect(input1);
 		}
 	}
 
 	@ConstantFieldsExcept(fields={})
-	public static class DummyReduce extends ReduceStub
-	{
+	public static class DummyReduce extends ReduceStub {
 		
 		@Override
-		public void reduce(Iterator<PactRecord> values, Collector<PactRecord> out)
-		{
+		public void reduce(Iterator<PactRecord> values, Collector<PactRecord> out) {
 			while (values.hasNext()) {
 				out.collect(values.next());
 			}
 		}
-
 	}
 
 	/**
 	 * {@inheritDoc}
 	 */
 	@Override
-	public Plan getPlan(final String... args) 
-	{
+	public Plan getPlan(final String... args) {
 		// parse program parameters
 		int noSubtasks       = (args.length > 0 ? Integer.parseInt(args[0]) : 1);
 		String input1Path    = (args.length > 1 ? args[1] : "");
diff --git a/pact/pact-tests/src/test/java/eu/stratosphere/pact/test/util/TestBase.java b/pact/pact-tests/src/test/java/eu/stratosphere/pact/test/util/TestBase.java
index 0840ace..d77b5ea 100644
--- a/pact/pact-tests/src/test/java/eu/stratosphere/pact/test/util/TestBase.java
+++ b/pact/pact-tests/src/test/java/eu/stratosphere/pact/test/util/TestBase.java
@@ -33,13 +33,11 @@ import java.util.PriorityQueue;
 import java.util.Properties;
 import java.util.StringTokenizer;
 
-import junit.framework.Assert;
-import junit.framework.TestCase;
-
 import org.apache.commons.logging.Log;
 import org.apache.commons.logging.LogFactory;
 import org.apache.hadoop.fs.FileSystem;
 import org.junit.After;
+import org.junit.Assert;
 import org.junit.Before;
 import org.junit.Test;
 
@@ -54,8 +52,8 @@ import eu.stratosphere.pact.test.util.minicluster.ClusterProviderPool;
  * @author Erik Nijkamp
  * @author Fabian Hueske
  */
-public abstract class TestBase extends TestCase
-{
+public abstract class TestBase {
+	
 	private static final int MINIMUM_HEAP_SIZE_MB = 192;
 
 	private static final Log LOG = LogFactory.getLog(TestBase.class);
@@ -80,8 +78,6 @@ public abstract class TestBase extends TestCase
 		long heap = Runtime.getRuntime().maxMemory() >> 20;
 		Assert.assertTrue("Insufficient java heap space " + heap + "mb - set JVM option: -Xmx" + MINIMUM_HEAP_SIZE_MB
 				+ "m", heap > MINIMUM_HEAP_SIZE_MB - 50);
-		Assert.assertTrue("IPv4 stack required - set JVM option: -Djava.net.preferIPv4Stack=true", "true".equals(System
-				.getProperty("java.net.preferIPv4Stack")));
 	}
 
 	@Before
@@ -130,7 +126,7 @@ public abstract class TestBase extends TestCase
 	 * Returns the FilesystemProvider of the cluster setup
 	 * 
 	 * @see eu.stratosphere.pact.test.util.filesystem.FilesystemProvider
-	 * 
+	 * Assert.
 	 * @return The FilesystemProvider of the cluster setup
 	 */
 	public FilesystemProvider getFilesystemProvider() {
@@ -255,7 +251,7 @@ public abstract class TestBase extends TestCase
 			while ((line = reader.readLine()) != null) {
 				Assert.assertTrue("More lines in result than expected lines.", expectedLines.hasNext());
 				String nextExpected = expectedLines.next().toString();
-				assertEquals("Expected result and obtained result do not match.", nextExpected, line);
+				Assert.assertEquals("Expected result and obtained result do not match.", nextExpected, line);
 			}
 			reader.close();
 		}
diff --git a/pact/pact-tests/src/test/java/eu/stratosphere/pact/test/util/minicluster/LocalClusterProvider.java b/pact/pact-tests/src/test/java/eu/stratosphere/pact/test/util/minicluster/LocalClusterProvider.java
index 1d37329..cb61ea4 100644
--- a/pact/pact-tests/src/test/java/eu/stratosphere/pact/test/util/minicluster/LocalClusterProvider.java
+++ b/pact/pact-tests/src/test/java/eu/stratosphere/pact/test/util/minicluster/LocalClusterProvider.java
@@ -15,8 +15,6 @@
 
 package eu.stratosphere.pact.test.util.minicluster;
 
-import java.io.File;
-
 import eu.stratosphere.nephele.client.JobClient;
 import eu.stratosphere.nephele.configuration.Configuration;
 import eu.stratosphere.nephele.jobgraph.JobGraph;
@@ -88,12 +86,8 @@ public class LocalClusterProvider extends ClusterProvider {
 		if (!nepheleIsRunning()) {
 			return;
 		}
-
-		nephele.stop();
-		nepheleRunning = false;
-		
-		File f = new File(System.getProperty("java.io.tmpdir") + "/minicluster");
-		f.delete();
+		this.nephele.stop();
+		this.nepheleRunning = false;
 	}
 
 	/* (non-Javadoc)
