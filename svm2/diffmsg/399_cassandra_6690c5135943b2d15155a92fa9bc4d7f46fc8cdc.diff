commit 6690c5135943b2d15155a92fa9bc4d7f46fc8cdc
Author: Jonathan Ellis <jbellis@apache.org>
Date:   Thu Aug 27 20:07:12 2009 +0000

    Update AsyncResult to know when it started waiting so you can get() multiple Results in serial but have them wait in parallel.  Use this to implement multiget methods.  Remove unused MultiAsyncResult code and StorageProxy methods using it.
    Patch by Chris Goffinet; reviewed by jbellis for CASSANDRA-70
    
    git-svn-id: https://svn.apache.org/repos/asf/incubator/cassandra/trunk@808589 13f79535-47bb-0310-9956-ffa450edef68

diff --git a/interface/cassandra.thrift b/interface/cassandra.thrift
index 8ddd2e9..63008fa 100644
--- a/interface/cassandra.thrift
+++ b/interface/cassandra.thrift
@@ -117,12 +117,21 @@ service Cassandra {
   list<ColumnOrSuperColumn> get_slice(1:string keyspace, 2:string key, 3:ColumnParent column_parent, 4:SlicePredicate predicate, 5:ConsistencyLevel consistency_level=1)
   throws (1: InvalidRequestException ire, 2: NotFoundException nfe),
 
+  map<string,list<ColumnOrSuperColumn>> multiget_slice(1:string keyspace, 2:list<string> keys, 3:ColumnParent column_parent, 4:SlicePredicate predicate, 5:ConsistencyLevel consistency_level=1)
+  throws (1: InvalidRequestException ire),
+
   ColumnOrSuperColumn get(1:string keyspace, 2:string key, 3:ColumnPath column_path, 4:ConsistencyLevel consistency_level=1)
   throws (1: InvalidRequestException ire, 2: NotFoundException nfe),
 
+  map<string,ColumnOrSuperColumn> multiget(1:string keyspace, 2:list<string> keys, 3:ColumnPath column_path, 4:ConsistencyLevel consistency_level=1)
+  throws (1: InvalidRequestException ire),
+
   i32 get_count(1:string keyspace, 2:string key, 3:ColumnParent column_parent, 5:ConsistencyLevel consistency_level=1)
   throws (1: InvalidRequestException ire),
 
+  map<string,i32> multiget_count(1:string keyspace, 2:list<string> keys, 3:ColumnParent column_parent, 5:ConsistencyLevel consistency_level=1)
+  throws (1: InvalidRequestException ire),
+
   void     insert(1:string keyspace, 2:string key, 3:ColumnPath column_path, 4:binary value, 5:i64 timestamp, 6:ConsistencyLevel consistency_level=0)
   throws (1: InvalidRequestException ire, 2: UnavailableException ue),
 
diff --git a/interface/gen-java/org/apache/cassandra/service/Cassandra.java b/interface/gen-java/org/apache/cassandra/service/Cassandra.java
index a18c5ed..285c786 100644
--- a/interface/gen-java/org/apache/cassandra/service/Cassandra.java
+++ b/interface/gen-java/org/apache/cassandra/service/Cassandra.java
@@ -47,10 +47,16 @@ public class Cassandra {
 
     public List<ColumnOrSuperColumn> get_slice(String keyspace, String key, ColumnParent column_parent, SlicePredicate predicate, int consistency_level) throws InvalidRequestException, NotFoundException, TException;
 
+    public Map<String,List<ColumnOrSuperColumn>> multiget_slice(String keyspace, List<String> keys, ColumnParent column_parent, SlicePredicate predicate, int consistency_level) throws InvalidRequestException, TException;
+
     public ColumnOrSuperColumn get(String keyspace, String key, ColumnPath column_path, int consistency_level) throws InvalidRequestException, NotFoundException, TException;
 
+    public Map<String,ColumnOrSuperColumn> multiget(String keyspace, List<String> keys, ColumnPath column_path, int consistency_level) throws InvalidRequestException, TException;
+
     public int get_count(String keyspace, String key, ColumnParent column_parent, int consistency_level) throws InvalidRequestException, TException;
 
+    public Map<String,Integer> multiget_count(String keyspace, List<String> keys, ColumnParent column_parent, int consistency_level) throws InvalidRequestException, TException;
+
     public void insert(String keyspace, String key, ColumnPath column_path, byte[] value, long timestamp, int consistency_level) throws InvalidRequestException, UnavailableException, TException;
 
     public void batch_insert(String keyspace, BatchMutation batch_mutation, int consistency_level) throws InvalidRequestException, UnavailableException, TException;
@@ -137,6 +143,46 @@ public class Cassandra {
       throw new TApplicationException(TApplicationException.MISSING_RESULT, "get_slice failed: unknown result");
     }
 
+    public Map<String,List<ColumnOrSuperColumn>> multiget_slice(String keyspace, List<String> keys, ColumnParent column_parent, SlicePredicate predicate, int consistency_level) throws InvalidRequestException, TException
+    {
+      send_multiget_slice(keyspace, keys, column_parent, predicate, consistency_level);
+      return recv_multiget_slice();
+    }
+
+    public void send_multiget_slice(String keyspace, List<String> keys, ColumnParent column_parent, SlicePredicate predicate, int consistency_level) throws TException
+    {
+      oprot_.writeMessageBegin(new TMessage("multiget_slice", TMessageType.CALL, seqid_));
+      multiget_slice_args args = new multiget_slice_args();
+      args.keyspace = keyspace;
+      args.keys = keys;
+      args.column_parent = column_parent;
+      args.predicate = predicate;
+      args.consistency_level = consistency_level;
+      args.write(oprot_);
+      oprot_.writeMessageEnd();
+      oprot_.getTransport().flush();
+    }
+
+    public Map<String,List<ColumnOrSuperColumn>> recv_multiget_slice() throws InvalidRequestException, TException
+    {
+      TMessage msg = iprot_.readMessageBegin();
+      if (msg.type == TMessageType.EXCEPTION) {
+        TApplicationException x = TApplicationException.read(iprot_);
+        iprot_.readMessageEnd();
+        throw x;
+      }
+      multiget_slice_result result = new multiget_slice_result();
+      result.read(iprot_);
+      iprot_.readMessageEnd();
+      if (result.isSetSuccess()) {
+        return result.success;
+      }
+      if (result.ire != null) {
+        throw result.ire;
+      }
+      throw new TApplicationException(TApplicationException.MISSING_RESULT, "multiget_slice failed: unknown result");
+    }
+
     public ColumnOrSuperColumn get(String keyspace, String key, ColumnPath column_path, int consistency_level) throws InvalidRequestException, NotFoundException, TException
     {
       send_get(keyspace, key, column_path, consistency_level);
@@ -179,6 +225,45 @@ public class Cassandra {
       throw new TApplicationException(TApplicationException.MISSING_RESULT, "get failed: unknown result");
     }
 
+    public Map<String,ColumnOrSuperColumn> multiget(String keyspace, List<String> keys, ColumnPath column_path, int consistency_level) throws InvalidRequestException, TException
+    {
+      send_multiget(keyspace, keys, column_path, consistency_level);
+      return recv_multiget();
+    }
+
+    public void send_multiget(String keyspace, List<String> keys, ColumnPath column_path, int consistency_level) throws TException
+    {
+      oprot_.writeMessageBegin(new TMessage("multiget", TMessageType.CALL, seqid_));
+      multiget_args args = new multiget_args();
+      args.keyspace = keyspace;
+      args.keys = keys;
+      args.column_path = column_path;
+      args.consistency_level = consistency_level;
+      args.write(oprot_);
+      oprot_.writeMessageEnd();
+      oprot_.getTransport().flush();
+    }
+
+    public Map<String,ColumnOrSuperColumn> recv_multiget() throws InvalidRequestException, TException
+    {
+      TMessage msg = iprot_.readMessageBegin();
+      if (msg.type == TMessageType.EXCEPTION) {
+        TApplicationException x = TApplicationException.read(iprot_);
+        iprot_.readMessageEnd();
+        throw x;
+      }
+      multiget_result result = new multiget_result();
+      result.read(iprot_);
+      iprot_.readMessageEnd();
+      if (result.isSetSuccess()) {
+        return result.success;
+      }
+      if (result.ire != null) {
+        throw result.ire;
+      }
+      throw new TApplicationException(TApplicationException.MISSING_RESULT, "multiget failed: unknown result");
+    }
+
     public int get_count(String keyspace, String key, ColumnParent column_parent, int consistency_level) throws InvalidRequestException, TException
     {
       send_get_count(keyspace, key, column_parent, consistency_level);
@@ -218,6 +303,45 @@ public class Cassandra {
       throw new TApplicationException(TApplicationException.MISSING_RESULT, "get_count failed: unknown result");
     }
 
+    public Map<String,Integer> multiget_count(String keyspace, List<String> keys, ColumnParent column_parent, int consistency_level) throws InvalidRequestException, TException
+    {
+      send_multiget_count(keyspace, keys, column_parent, consistency_level);
+      return recv_multiget_count();
+    }
+
+    public void send_multiget_count(String keyspace, List<String> keys, ColumnParent column_parent, int consistency_level) throws TException
+    {
+      oprot_.writeMessageBegin(new TMessage("multiget_count", TMessageType.CALL, seqid_));
+      multiget_count_args args = new multiget_count_args();
+      args.keyspace = keyspace;
+      args.keys = keys;
+      args.column_parent = column_parent;
+      args.consistency_level = consistency_level;
+      args.write(oprot_);
+      oprot_.writeMessageEnd();
+      oprot_.getTransport().flush();
+    }
+
+    public Map<String,Integer> recv_multiget_count() throws InvalidRequestException, TException
+    {
+      TMessage msg = iprot_.readMessageBegin();
+      if (msg.type == TMessageType.EXCEPTION) {
+        TApplicationException x = TApplicationException.read(iprot_);
+        iprot_.readMessageEnd();
+        throw x;
+      }
+      multiget_count_result result = new multiget_count_result();
+      result.read(iprot_);
+      iprot_.readMessageEnd();
+      if (result.isSetSuccess()) {
+        return result.success;
+      }
+      if (result.ire != null) {
+        throw result.ire;
+      }
+      throw new TApplicationException(TApplicationException.MISSING_RESULT, "multiget_count failed: unknown result");
+    }
+
     public void insert(String keyspace, String key, ColumnPath column_path, byte[] value, long timestamp, int consistency_level) throws InvalidRequestException, UnavailableException, TException
     {
       send_insert(keyspace, key, column_path, value, timestamp, consistency_level);
@@ -486,8 +610,11 @@ public class Cassandra {
     {
       iface_ = iface;
       processMap_.put("get_slice", new get_slice());
+      processMap_.put("multiget_slice", new multiget_slice());
       processMap_.put("get", new get());
+      processMap_.put("multiget", new multiget());
       processMap_.put("get_count", new get_count());
+      processMap_.put("multiget_count", new multiget_count());
       processMap_.put("insert", new insert());
       processMap_.put("batch_insert", new batch_insert());
       processMap_.put("remove", new remove());
@@ -552,6 +679,34 @@ public class Cassandra {
 
     }
 
+    private class multiget_slice implements ProcessFunction {
+      public void process(int seqid, TProtocol iprot, TProtocol oprot) throws TException
+      {
+        multiget_slice_args args = new multiget_slice_args();
+        args.read(iprot);
+        iprot.readMessageEnd();
+        multiget_slice_result result = new multiget_slice_result();
+        try {
+          result.success = iface_.multiget_slice(args.keyspace, args.keys, args.column_parent, args.predicate, args.consistency_level);
+        } catch (InvalidRequestException ire) {
+          result.ire = ire;
+        } catch (Throwable th) {
+          LOGGER.error("Internal error processing multiget_slice", th);
+          TApplicationException x = new TApplicationException(TApplicationException.INTERNAL_ERROR, "Internal error processing multiget_slice");
+          oprot.writeMessageBegin(new TMessage("multiget_slice", TMessageType.EXCEPTION, seqid));
+          x.write(oprot);
+          oprot.writeMessageEnd();
+          oprot.getTransport().flush();
+          return;
+        }
+        oprot.writeMessageBegin(new TMessage("multiget_slice", TMessageType.REPLY, seqid));
+        result.write(oprot);
+        oprot.writeMessageEnd();
+        oprot.getTransport().flush();
+      }
+
+    }
+
     private class get implements ProcessFunction {
       public void process(int seqid, TProtocol iprot, TProtocol oprot) throws TException
       {
@@ -582,6 +737,34 @@ public class Cassandra {
 
     }
 
+    private class multiget implements ProcessFunction {
+      public void process(int seqid, TProtocol iprot, TProtocol oprot) throws TException
+      {
+        multiget_args args = new multiget_args();
+        args.read(iprot);
+        iprot.readMessageEnd();
+        multiget_result result = new multiget_result();
+        try {
+          result.success = iface_.multiget(args.keyspace, args.keys, args.column_path, args.consistency_level);
+        } catch (InvalidRequestException ire) {
+          result.ire = ire;
+        } catch (Throwable th) {
+          LOGGER.error("Internal error processing multiget", th);
+          TApplicationException x = new TApplicationException(TApplicationException.INTERNAL_ERROR, "Internal error processing multiget");
+          oprot.writeMessageBegin(new TMessage("multiget", TMessageType.EXCEPTION, seqid));
+          x.write(oprot);
+          oprot.writeMessageEnd();
+          oprot.getTransport().flush();
+          return;
+        }
+        oprot.writeMessageBegin(new TMessage("multiget", TMessageType.REPLY, seqid));
+        result.write(oprot);
+        oprot.writeMessageEnd();
+        oprot.getTransport().flush();
+      }
+
+    }
+
     private class get_count implements ProcessFunction {
       public void process(int seqid, TProtocol iprot, TProtocol oprot) throws TException
       {
@@ -611,6 +794,34 @@ public class Cassandra {
 
     }
 
+    private class multiget_count implements ProcessFunction {
+      public void process(int seqid, TProtocol iprot, TProtocol oprot) throws TException
+      {
+        multiget_count_args args = new multiget_count_args();
+        args.read(iprot);
+        iprot.readMessageEnd();
+        multiget_count_result result = new multiget_count_result();
+        try {
+          result.success = iface_.multiget_count(args.keyspace, args.keys, args.column_parent, args.consistency_level);
+        } catch (InvalidRequestException ire) {
+          result.ire = ire;
+        } catch (Throwable th) {
+          LOGGER.error("Internal error processing multiget_count", th);
+          TApplicationException x = new TApplicationException(TApplicationException.INTERNAL_ERROR, "Internal error processing multiget_count");
+          oprot.writeMessageBegin(new TMessage("multiget_count", TMessageType.EXCEPTION, seqid));
+          x.write(oprot);
+          oprot.writeMessageEnd();
+          oprot.getTransport().flush();
+          return;
+        }
+        oprot.writeMessageBegin(new TMessage("multiget_count", TMessageType.REPLY, seqid));
+        result.write(oprot);
+        oprot.writeMessageEnd();
+        oprot.getTransport().flush();
+      }
+
+    }
+
     private class insert implements ProcessFunction {
       public void process(int seqid, TProtocol iprot, TProtocol oprot) throws TException
       {
@@ -1799,25 +2010,28 @@ public class Cassandra {
 
   }
 
-  public static class get_args implements TBase, java.io.Serializable, Cloneable, Comparable<get_args>   {
-    private static final TStruct STRUCT_DESC = new TStruct("get_args");
+  public static class multiget_slice_args implements TBase, java.io.Serializable, Cloneable, Comparable<multiget_slice_args>   {
+    private static final TStruct STRUCT_DESC = new TStruct("multiget_slice_args");
     private static final TField KEYSPACE_FIELD_DESC = new TField("keyspace", TType.STRING, (short)1);
-    private static final TField KEY_FIELD_DESC = new TField("key", TType.STRING, (short)2);
-    private static final TField COLUMN_PATH_FIELD_DESC = new TField("column_path", TType.STRUCT, (short)3);
-    private static final TField CONSISTENCY_LEVEL_FIELD_DESC = new TField("consistency_level", TType.I32, (short)4);
+    private static final TField KEYS_FIELD_DESC = new TField("keys", TType.LIST, (short)2);
+    private static final TField COLUMN_PARENT_FIELD_DESC = new TField("column_parent", TType.STRUCT, (short)3);
+    private static final TField PREDICATE_FIELD_DESC = new TField("predicate", TType.STRUCT, (short)4);
+    private static final TField CONSISTENCY_LEVEL_FIELD_DESC = new TField("consistency_level", TType.I32, (short)5);
 
     public String keyspace;
     public static final int KEYSPACE = 1;
-    public String key;
-    public static final int KEY = 2;
-    public ColumnPath column_path;
-    public static final int COLUMN_PATH = 3;
+    public List<String> keys;
+    public static final int KEYS = 2;
+    public ColumnParent column_parent;
+    public static final int COLUMN_PARENT = 3;
+    public SlicePredicate predicate;
+    public static final int PREDICATE = 4;
     /**
      * 
      * @see ConsistencyLevel
      */
     public int consistency_level;
-    public static final int CONSISTENCY_LEVEL = 4;
+    public static final int CONSISTENCY_LEVEL = 5;
 
     // isset id assignments
     private static final int __CONSISTENCY_LEVEL_ISSET_ID = 0;
@@ -1826,33 +2040,38 @@ public class Cassandra {
     public static final Map<Integer, FieldMetaData> metaDataMap = Collections.unmodifiableMap(new HashMap<Integer, FieldMetaData>() {{
       put(KEYSPACE, new FieldMetaData("keyspace", TFieldRequirementType.DEFAULT, 
           new FieldValueMetaData(TType.STRING)));
-      put(KEY, new FieldMetaData("key", TFieldRequirementType.DEFAULT, 
-          new FieldValueMetaData(TType.STRING)));
-      put(COLUMN_PATH, new FieldMetaData("column_path", TFieldRequirementType.DEFAULT, 
-          new StructMetaData(TType.STRUCT, ColumnPath.class)));
+      put(KEYS, new FieldMetaData("keys", TFieldRequirementType.DEFAULT, 
+          new ListMetaData(TType.LIST, 
+              new FieldValueMetaData(TType.STRING))));
+      put(COLUMN_PARENT, new FieldMetaData("column_parent", TFieldRequirementType.DEFAULT, 
+          new StructMetaData(TType.STRUCT, ColumnParent.class)));
+      put(PREDICATE, new FieldMetaData("predicate", TFieldRequirementType.DEFAULT, 
+          new StructMetaData(TType.STRUCT, SlicePredicate.class)));
       put(CONSISTENCY_LEVEL, new FieldMetaData("consistency_level", TFieldRequirementType.DEFAULT, 
           new FieldValueMetaData(TType.I32)));
     }});
 
     static {
-      FieldMetaData.addStructMetaDataMap(get_args.class, metaDataMap);
+      FieldMetaData.addStructMetaDataMap(multiget_slice_args.class, metaDataMap);
     }
 
-    public get_args() {
+    public multiget_slice_args() {
       this.consistency_level = 1;
 
     }
 
-    public get_args(
+    public multiget_slice_args(
       String keyspace,
-      String key,
-      ColumnPath column_path,
+      List<String> keys,
+      ColumnParent column_parent,
+      SlicePredicate predicate,
       int consistency_level)
     {
       this();
       this.keyspace = keyspace;
-      this.key = key;
-      this.column_path = column_path;
+      this.keys = keys;
+      this.column_parent = column_parent;
+      this.predicate = predicate;
       this.consistency_level = consistency_level;
       setConsistency_levelIsSet(true);
     }
@@ -1860,31 +2079,38 @@ public class Cassandra {
     /**
      * Performs a deep copy on <i>other</i>.
      */
-    public get_args(get_args other) {
+    public multiget_slice_args(multiget_slice_args other) {
       __isset_bit_vector.clear();
       __isset_bit_vector.or(other.__isset_bit_vector);
       if (other.isSetKeyspace()) {
         this.keyspace = other.keyspace;
       }
-      if (other.isSetKey()) {
-        this.key = other.key;
+      if (other.isSetKeys()) {
+        List<String> __this__keys = new ArrayList<String>();
+        for (String other_element : other.keys) {
+          __this__keys.add(other_element);
+        }
+        this.keys = __this__keys;
       }
-      if (other.isSetColumn_path()) {
-        this.column_path = new ColumnPath(other.column_path);
+      if (other.isSetColumn_parent()) {
+        this.column_parent = new ColumnParent(other.column_parent);
+      }
+      if (other.isSetPredicate()) {
+        this.predicate = new SlicePredicate(other.predicate);
       }
       this.consistency_level = other.consistency_level;
     }
 
     @Override
-    public get_args clone() {
-      return new get_args(this);
+    public multiget_slice_args clone() {
+      return new multiget_slice_args(this);
     }
 
     public String getKeyspace() {
       return this.keyspace;
     }
 
-    public get_args setKeyspace(String keyspace) {
+    public multiget_slice_args setKeyspace(String keyspace) {
       this.keyspace = keyspace;
       return this;
     }
@@ -1904,74 +2130,2744 @@ public class Cassandra {
       }
     }
 
-    public String getKey() {
-      return this.key;
+    public List<String> getKeys() {
+      return this.keys;
     }
 
-    public get_args setKey(String key) {
-      this.key = key;
+    public multiget_slice_args setKeys(List<String> keys) {
+      this.keys = keys;
       return this;
     }
 
-    public void unsetKey() {
-      this.key = null;
+    public void unsetKeys() {
+      this.keys = null;
     }
 
-    // Returns true if field key is set (has been asigned a value) and false otherwise
-    public boolean isSetKey() {
-      return this.key != null;
+    // Returns true if field keys is set (has been asigned a value) and false otherwise
+    public boolean isSetKeys() {
+      return this.keys != null;
     }
 
-    public void setKeyIsSet(boolean value) {
+    public void setKeysIsSet(boolean value) {
       if (!value) {
-        this.key = null;
+        this.keys = null;
       }
     }
 
-    public ColumnPath getColumn_path() {
-      return this.column_path;
+    public ColumnParent getColumn_parent() {
+      return this.column_parent;
     }
 
-    public get_args setColumn_path(ColumnPath column_path) {
-      this.column_path = column_path;
+    public multiget_slice_args setColumn_parent(ColumnParent column_parent) {
+      this.column_parent = column_parent;
       return this;
     }
 
-    public void unsetColumn_path() {
-      this.column_path = null;
+    public void unsetColumn_parent() {
+      this.column_parent = null;
     }
 
-    // Returns true if field column_path is set (has been asigned a value) and false otherwise
-    public boolean isSetColumn_path() {
-      return this.column_path != null;
+    // Returns true if field column_parent is set (has been asigned a value) and false otherwise
+    public boolean isSetColumn_parent() {
+      return this.column_parent != null;
     }
 
-    public void setColumn_pathIsSet(boolean value) {
+    public void setColumn_parentIsSet(boolean value) {
       if (!value) {
-        this.column_path = null;
+        this.column_parent = null;
       }
     }
 
-    /**
-     * 
-     * @see ConsistencyLevel
-     */
-    public int getConsistency_level() {
-      return this.consistency_level;
+    public SlicePredicate getPredicate() {
+      return this.predicate;
     }
 
-    /**
-     * 
-     * @see ConsistencyLevel
-     */
-    public get_args setConsistency_level(int consistency_level) {
-      this.consistency_level = consistency_level;
-      setConsistency_levelIsSet(true);
+    public multiget_slice_args setPredicate(SlicePredicate predicate) {
+      this.predicate = predicate;
       return this;
     }
 
-    public void unsetConsistency_level() {
-      __isset_bit_vector.clear(__CONSISTENCY_LEVEL_ISSET_ID);
+    public void unsetPredicate() {
+      this.predicate = null;
+    }
+
+    // Returns true if field predicate is set (has been asigned a value) and false otherwise
+    public boolean isSetPredicate() {
+      return this.predicate != null;
+    }
+
+    public void setPredicateIsSet(boolean value) {
+      if (!value) {
+        this.predicate = null;
+      }
+    }
+
+    /**
+     * 
+     * @see ConsistencyLevel
+     */
+    public int getConsistency_level() {
+      return this.consistency_level;
+    }
+
+    /**
+     * 
+     * @see ConsistencyLevel
+     */
+    public multiget_slice_args setConsistency_level(int consistency_level) {
+      this.consistency_level = consistency_level;
+      setConsistency_levelIsSet(true);
+      return this;
+    }
+
+    public void unsetConsistency_level() {
+      __isset_bit_vector.clear(__CONSISTENCY_LEVEL_ISSET_ID);
+    }
+
+    // Returns true if field consistency_level is set (has been asigned a value) and false otherwise
+    public boolean isSetConsistency_level() {
+      return __isset_bit_vector.get(__CONSISTENCY_LEVEL_ISSET_ID);
+    }
+
+    public void setConsistency_levelIsSet(boolean value) {
+      __isset_bit_vector.set(__CONSISTENCY_LEVEL_ISSET_ID, value);
+    }
+
+    public void setFieldValue(int fieldID, Object value) {
+      switch (fieldID) {
+      case KEYSPACE:
+        if (value == null) {
+          unsetKeyspace();
+        } else {
+          setKeyspace((String)value);
+        }
+        break;
+
+      case KEYS:
+        if (value == null) {
+          unsetKeys();
+        } else {
+          setKeys((List<String>)value);
+        }
+        break;
+
+      case COLUMN_PARENT:
+        if (value == null) {
+          unsetColumn_parent();
+        } else {
+          setColumn_parent((ColumnParent)value);
+        }
+        break;
+
+      case PREDICATE:
+        if (value == null) {
+          unsetPredicate();
+        } else {
+          setPredicate((SlicePredicate)value);
+        }
+        break;
+
+      case CONSISTENCY_LEVEL:
+        if (value == null) {
+          unsetConsistency_level();
+        } else {
+          setConsistency_level((Integer)value);
+        }
+        break;
+
+      default:
+        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
+      }
+    }
+
+    public Object getFieldValue(int fieldID) {
+      switch (fieldID) {
+      case KEYSPACE:
+        return getKeyspace();
+
+      case KEYS:
+        return getKeys();
+
+      case COLUMN_PARENT:
+        return getColumn_parent();
+
+      case PREDICATE:
+        return getPredicate();
+
+      case CONSISTENCY_LEVEL:
+        return getConsistency_level();
+
+      default:
+        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
+      }
+    }
+
+    // Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise
+    public boolean isSet(int fieldID) {
+      switch (fieldID) {
+      case KEYSPACE:
+        return isSetKeyspace();
+      case KEYS:
+        return isSetKeys();
+      case COLUMN_PARENT:
+        return isSetColumn_parent();
+      case PREDICATE:
+        return isSetPredicate();
+      case CONSISTENCY_LEVEL:
+        return isSetConsistency_level();
+      default:
+        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
+      }
+    }
+
+    @Override
+    public boolean equals(Object that) {
+      if (that == null)
+        return false;
+      if (that instanceof multiget_slice_args)
+        return this.equals((multiget_slice_args)that);
+      return false;
+    }
+
+    public boolean equals(multiget_slice_args that) {
+      if (that == null)
+        return false;
+
+      boolean this_present_keyspace = true && this.isSetKeyspace();
+      boolean that_present_keyspace = true && that.isSetKeyspace();
+      if (this_present_keyspace || that_present_keyspace) {
+        if (!(this_present_keyspace && that_present_keyspace))
+          return false;
+        if (!this.keyspace.equals(that.keyspace))
+          return false;
+      }
+
+      boolean this_present_keys = true && this.isSetKeys();
+      boolean that_present_keys = true && that.isSetKeys();
+      if (this_present_keys || that_present_keys) {
+        if (!(this_present_keys && that_present_keys))
+          return false;
+        if (!this.keys.equals(that.keys))
+          return false;
+      }
+
+      boolean this_present_column_parent = true && this.isSetColumn_parent();
+      boolean that_present_column_parent = true && that.isSetColumn_parent();
+      if (this_present_column_parent || that_present_column_parent) {
+        if (!(this_present_column_parent && that_present_column_parent))
+          return false;
+        if (!this.column_parent.equals(that.column_parent))
+          return false;
+      }
+
+      boolean this_present_predicate = true && this.isSetPredicate();
+      boolean that_present_predicate = true && that.isSetPredicate();
+      if (this_present_predicate || that_present_predicate) {
+        if (!(this_present_predicate && that_present_predicate))
+          return false;
+        if (!this.predicate.equals(that.predicate))
+          return false;
+      }
+
+      boolean this_present_consistency_level = true;
+      boolean that_present_consistency_level = true;
+      if (this_present_consistency_level || that_present_consistency_level) {
+        if (!(this_present_consistency_level && that_present_consistency_level))
+          return false;
+        if (this.consistency_level != that.consistency_level)
+          return false;
+      }
+
+      return true;
+    }
+
+    @Override
+    public int hashCode() {
+      return 0;
+    }
+
+    public int compareTo(multiget_slice_args other) {
+      if (!getClass().equals(other.getClass())) {
+        return getClass().getName().compareTo(other.getClass().getName());
+      }
+
+      int lastComparison = 0;
+      multiget_slice_args typedOther = (multiget_slice_args)other;
+
+      lastComparison = Boolean.valueOf(isSetKeyspace()).compareTo(isSetKeyspace());
+      if (lastComparison != 0) {
+        return lastComparison;
+      }
+      lastComparison = TBaseHelper.compareTo(keyspace, typedOther.keyspace);
+      if (lastComparison != 0) {
+        return lastComparison;
+      }
+      lastComparison = Boolean.valueOf(isSetKeys()).compareTo(isSetKeys());
+      if (lastComparison != 0) {
+        return lastComparison;
+      }
+      lastComparison = TBaseHelper.compareTo(keys, typedOther.keys);
+      if (lastComparison != 0) {
+        return lastComparison;
+      }
+      lastComparison = Boolean.valueOf(isSetColumn_parent()).compareTo(isSetColumn_parent());
+      if (lastComparison != 0) {
+        return lastComparison;
+      }
+      lastComparison = TBaseHelper.compareTo(column_parent, typedOther.column_parent);
+      if (lastComparison != 0) {
+        return lastComparison;
+      }
+      lastComparison = Boolean.valueOf(isSetPredicate()).compareTo(isSetPredicate());
+      if (lastComparison != 0) {
+        return lastComparison;
+      }
+      lastComparison = TBaseHelper.compareTo(predicate, typedOther.predicate);
+      if (lastComparison != 0) {
+        return lastComparison;
+      }
+      lastComparison = Boolean.valueOf(isSetConsistency_level()).compareTo(isSetConsistency_level());
+      if (lastComparison != 0) {
+        return lastComparison;
+      }
+      lastComparison = TBaseHelper.compareTo(consistency_level, typedOther.consistency_level);
+      if (lastComparison != 0) {
+        return lastComparison;
+      }
+      return 0;
+    }
+
+    public void read(TProtocol iprot) throws TException {
+      TField field;
+      iprot.readStructBegin();
+      while (true)
+      {
+        field = iprot.readFieldBegin();
+        if (field.type == TType.STOP) { 
+          break;
+        }
+        switch (field.id)
+        {
+          case KEYSPACE:
+            if (field.type == TType.STRING) {
+              this.keyspace = iprot.readString();
+            } else { 
+              TProtocolUtil.skip(iprot, field.type);
+            }
+            break;
+          case KEYS:
+            if (field.type == TType.LIST) {
+              {
+                TList _list21 = iprot.readListBegin();
+                this.keys = new ArrayList<String>(_list21.size);
+                for (int _i22 = 0; _i22 < _list21.size; ++_i22)
+                {
+                  String _elem23;
+                  _elem23 = iprot.readString();
+                  this.keys.add(_elem23);
+                }
+                iprot.readListEnd();
+              }
+            } else { 
+              TProtocolUtil.skip(iprot, field.type);
+            }
+            break;
+          case COLUMN_PARENT:
+            if (field.type == TType.STRUCT) {
+              this.column_parent = new ColumnParent();
+              this.column_parent.read(iprot);
+            } else { 
+              TProtocolUtil.skip(iprot, field.type);
+            }
+            break;
+          case PREDICATE:
+            if (field.type == TType.STRUCT) {
+              this.predicate = new SlicePredicate();
+              this.predicate.read(iprot);
+            } else { 
+              TProtocolUtil.skip(iprot, field.type);
+            }
+            break;
+          case CONSISTENCY_LEVEL:
+            if (field.type == TType.I32) {
+              this.consistency_level = iprot.readI32();
+              setConsistency_levelIsSet(true);
+            } else { 
+              TProtocolUtil.skip(iprot, field.type);
+            }
+            break;
+          default:
+            TProtocolUtil.skip(iprot, field.type);
+            break;
+        }
+        iprot.readFieldEnd();
+      }
+      iprot.readStructEnd();
+
+
+      // check for required fields of primitive type, which can't be checked in the validate method
+      if (!isSetConsistency_level()) {
+        throw new TProtocolException("Required field 'consistency_level' was not found in serialized data! Struct: " + toString());
+      }
+      validate();
+    }
+
+    public void write(TProtocol oprot) throws TException {
+      validate();
+
+      oprot.writeStructBegin(STRUCT_DESC);
+      if (this.keyspace != null) {
+        oprot.writeFieldBegin(KEYSPACE_FIELD_DESC);
+        oprot.writeString(this.keyspace);
+        oprot.writeFieldEnd();
+      }
+      if (this.keys != null) {
+        oprot.writeFieldBegin(KEYS_FIELD_DESC);
+        {
+          oprot.writeListBegin(new TList(TType.STRING, this.keys.size()));
+          for (String _iter24 : this.keys)          {
+            oprot.writeString(_iter24);
+          }
+          oprot.writeListEnd();
+        }
+        oprot.writeFieldEnd();
+      }
+      if (this.column_parent != null) {
+        oprot.writeFieldBegin(COLUMN_PARENT_FIELD_DESC);
+        this.column_parent.write(oprot);
+        oprot.writeFieldEnd();
+      }
+      if (this.predicate != null) {
+        oprot.writeFieldBegin(PREDICATE_FIELD_DESC);
+        this.predicate.write(oprot);
+        oprot.writeFieldEnd();
+      }
+      oprot.writeFieldBegin(CONSISTENCY_LEVEL_FIELD_DESC);
+      oprot.writeI32(this.consistency_level);
+      oprot.writeFieldEnd();
+      oprot.writeFieldStop();
+      oprot.writeStructEnd();
+    }
+
+    @Override
+    public String toString() {
+      StringBuilder sb = new StringBuilder("multiget_slice_args(");
+      boolean first = true;
+
+      sb.append("keyspace:");
+      if (this.keyspace == null) {
+        sb.append("null");
+      } else {
+        sb.append(this.keyspace);
+      }
+      first = false;
+      if (!first) sb.append(", ");
+      sb.append("keys:");
+      if (this.keys == null) {
+        sb.append("null");
+      } else {
+        sb.append(this.keys);
+      }
+      first = false;
+      if (!first) sb.append(", ");
+      sb.append("column_parent:");
+      if (this.column_parent == null) {
+        sb.append("null");
+      } else {
+        sb.append(this.column_parent);
+      }
+      first = false;
+      if (!first) sb.append(", ");
+      sb.append("predicate:");
+      if (this.predicate == null) {
+        sb.append("null");
+      } else {
+        sb.append(this.predicate);
+      }
+      first = false;
+      if (!first) sb.append(", ");
+      sb.append("consistency_level:");
+      String consistency_level_name = ConsistencyLevel.VALUES_TO_NAMES.get(this.consistency_level);
+      if (consistency_level_name != null) {
+        sb.append(consistency_level_name);
+        sb.append(" (");
+      }
+      sb.append(this.consistency_level);
+      if (consistency_level_name != null) {
+        sb.append(")");
+      }
+      first = false;
+      sb.append(")");
+      return sb.toString();
+    }
+
+    public void validate() throws TException {
+      // check for required fields
+      if (keyspace == null) {
+        throw new TProtocolException("Required field 'keyspace' was not present! Struct: " + toString());
+      }
+      if (keys == null) {
+        throw new TProtocolException("Required field 'keys' was not present! Struct: " + toString());
+      }
+      if (column_parent == null) {
+        throw new TProtocolException("Required field 'column_parent' was not present! Struct: " + toString());
+      }
+      if (predicate == null) {
+        throw new TProtocolException("Required field 'predicate' was not present! Struct: " + toString());
+      }
+      // 'consistency_level' is only checked in read() because it's a primitive and you chose the non-beans generator.
+      // check that fields of type enum have valid values
+      if (isSetConsistency_level() && !ConsistencyLevel.VALID_VALUES.contains(consistency_level)){
+        throw new TProtocolException("The field 'consistency_level' has been assigned the invalid value " + consistency_level);
+      }
+    }
+
+  }
+
+  public static class multiget_slice_result implements TBase, java.io.Serializable, Cloneable   {
+    private static final TStruct STRUCT_DESC = new TStruct("multiget_slice_result");
+    private static final TField SUCCESS_FIELD_DESC = new TField("success", TType.MAP, (short)0);
+    private static final TField IRE_FIELD_DESC = new TField("ire", TType.STRUCT, (short)1);
+
+    public Map<String,List<ColumnOrSuperColumn>> success;
+    public static final int SUCCESS = 0;
+    public InvalidRequestException ire;
+    public static final int IRE = 1;
+
+    // isset id assignments
+
+    public static final Map<Integer, FieldMetaData> metaDataMap = Collections.unmodifiableMap(new HashMap<Integer, FieldMetaData>() {{
+      put(SUCCESS, new FieldMetaData("success", TFieldRequirementType.DEFAULT, 
+          new MapMetaData(TType.MAP, 
+              new FieldValueMetaData(TType.STRING), 
+              new ListMetaData(TType.LIST, 
+                  new StructMetaData(TType.STRUCT, ColumnOrSuperColumn.class)))));
+      put(IRE, new FieldMetaData("ire", TFieldRequirementType.DEFAULT, 
+          new FieldValueMetaData(TType.STRUCT)));
+    }});
+
+    static {
+      FieldMetaData.addStructMetaDataMap(multiget_slice_result.class, metaDataMap);
+    }
+
+    public multiget_slice_result() {
+    }
+
+    public multiget_slice_result(
+      Map<String,List<ColumnOrSuperColumn>> success,
+      InvalidRequestException ire)
+    {
+      this();
+      this.success = success;
+      this.ire = ire;
+    }
+
+    /**
+     * Performs a deep copy on <i>other</i>.
+     */
+    public multiget_slice_result(multiget_slice_result other) {
+      if (other.isSetSuccess()) {
+        Map<String,List<ColumnOrSuperColumn>> __this__success = new HashMap<String,List<ColumnOrSuperColumn>>();
+        for (Map.Entry<String, List<ColumnOrSuperColumn>> other_element : other.success.entrySet()) {
+
+          String other_element_key = other_element.getKey();
+          List<ColumnOrSuperColumn> other_element_value = other_element.getValue();
+
+          String __this__success_copy_key = other_element_key;
+
+          List<ColumnOrSuperColumn> __this__success_copy_value = new ArrayList<ColumnOrSuperColumn>();
+          for (ColumnOrSuperColumn other_element_value_element : other_element_value) {
+            __this__success_copy_value.add(new ColumnOrSuperColumn(other_element_value_element));
+          }
+
+          __this__success.put(__this__success_copy_key, __this__success_copy_value);
+        }
+        this.success = __this__success;
+      }
+      if (other.isSetIre()) {
+        this.ire = new InvalidRequestException(other.ire);
+      }
+    }
+
+    @Override
+    public multiget_slice_result clone() {
+      return new multiget_slice_result(this);
+    }
+
+    public Map<String,List<ColumnOrSuperColumn>> getSuccess() {
+      return this.success;
+    }
+
+    public multiget_slice_result setSuccess(Map<String,List<ColumnOrSuperColumn>> success) {
+      this.success = success;
+      return this;
+    }
+
+    public void unsetSuccess() {
+      this.success = null;
+    }
+
+    // Returns true if field success is set (has been asigned a value) and false otherwise
+    public boolean isSetSuccess() {
+      return this.success != null;
+    }
+
+    public void setSuccessIsSet(boolean value) {
+      if (!value) {
+        this.success = null;
+      }
+    }
+
+    public InvalidRequestException getIre() {
+      return this.ire;
+    }
+
+    public multiget_slice_result setIre(InvalidRequestException ire) {
+      this.ire = ire;
+      return this;
+    }
+
+    public void unsetIre() {
+      this.ire = null;
+    }
+
+    // Returns true if field ire is set (has been asigned a value) and false otherwise
+    public boolean isSetIre() {
+      return this.ire != null;
+    }
+
+    public void setIreIsSet(boolean value) {
+      if (!value) {
+        this.ire = null;
+      }
+    }
+
+    public void setFieldValue(int fieldID, Object value) {
+      switch (fieldID) {
+      case SUCCESS:
+        if (value == null) {
+          unsetSuccess();
+        } else {
+          setSuccess((Map<String,List<ColumnOrSuperColumn>>)value);
+        }
+        break;
+
+      case IRE:
+        if (value == null) {
+          unsetIre();
+        } else {
+          setIre((InvalidRequestException)value);
+        }
+        break;
+
+      default:
+        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
+      }
+    }
+
+    public Object getFieldValue(int fieldID) {
+      switch (fieldID) {
+      case SUCCESS:
+        return getSuccess();
+
+      case IRE:
+        return getIre();
+
+      default:
+        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
+      }
+    }
+
+    // Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise
+    public boolean isSet(int fieldID) {
+      switch (fieldID) {
+      case SUCCESS:
+        return isSetSuccess();
+      case IRE:
+        return isSetIre();
+      default:
+        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
+      }
+    }
+
+    @Override
+    public boolean equals(Object that) {
+      if (that == null)
+        return false;
+      if (that instanceof multiget_slice_result)
+        return this.equals((multiget_slice_result)that);
+      return false;
+    }
+
+    public boolean equals(multiget_slice_result that) {
+      if (that == null)
+        return false;
+
+      boolean this_present_success = true && this.isSetSuccess();
+      boolean that_present_success = true && that.isSetSuccess();
+      if (this_present_success || that_present_success) {
+        if (!(this_present_success && that_present_success))
+          return false;
+        if (!this.success.equals(that.success))
+          return false;
+      }
+
+      boolean this_present_ire = true && this.isSetIre();
+      boolean that_present_ire = true && that.isSetIre();
+      if (this_present_ire || that_present_ire) {
+        if (!(this_present_ire && that_present_ire))
+          return false;
+        if (!this.ire.equals(that.ire))
+          return false;
+      }
+
+      return true;
+    }
+
+    @Override
+    public int hashCode() {
+      return 0;
+    }
+
+    public void read(TProtocol iprot) throws TException {
+      TField field;
+      iprot.readStructBegin();
+      while (true)
+      {
+        field = iprot.readFieldBegin();
+        if (field.type == TType.STOP) { 
+          break;
+        }
+        switch (field.id)
+        {
+          case SUCCESS:
+            if (field.type == TType.MAP) {
+              {
+                TMap _map25 = iprot.readMapBegin();
+                this.success = new HashMap<String,List<ColumnOrSuperColumn>>(2*_map25.size);
+                for (int _i26 = 0; _i26 < _map25.size; ++_i26)
+                {
+                  String _key27;
+                  List<ColumnOrSuperColumn> _val28;
+                  _key27 = iprot.readString();
+                  {
+                    TList _list29 = iprot.readListBegin();
+                    _val28 = new ArrayList<ColumnOrSuperColumn>(_list29.size);
+                    for (int _i30 = 0; _i30 < _list29.size; ++_i30)
+                    {
+                      ColumnOrSuperColumn _elem31;
+                      _elem31 = new ColumnOrSuperColumn();
+                      _elem31.read(iprot);
+                      _val28.add(_elem31);
+                    }
+                    iprot.readListEnd();
+                  }
+                  this.success.put(_key27, _val28);
+                }
+                iprot.readMapEnd();
+              }
+            } else { 
+              TProtocolUtil.skip(iprot, field.type);
+            }
+            break;
+          case IRE:
+            if (field.type == TType.STRUCT) {
+              this.ire = new InvalidRequestException();
+              this.ire.read(iprot);
+            } else { 
+              TProtocolUtil.skip(iprot, field.type);
+            }
+            break;
+          default:
+            TProtocolUtil.skip(iprot, field.type);
+            break;
+        }
+        iprot.readFieldEnd();
+      }
+      iprot.readStructEnd();
+
+
+      // check for required fields of primitive type, which can't be checked in the validate method
+      validate();
+    }
+
+    public void write(TProtocol oprot) throws TException {
+      oprot.writeStructBegin(STRUCT_DESC);
+
+      if (this.isSetSuccess()) {
+        oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
+        {
+          oprot.writeMapBegin(new TMap(TType.STRING, TType.LIST, this.success.size()));
+          for (Map.Entry<String, List<ColumnOrSuperColumn>> _iter32 : this.success.entrySet())          {
+            oprot.writeString(_iter32.getKey());
+            {
+              oprot.writeListBegin(new TList(TType.STRUCT, _iter32.getValue().size()));
+              for (ColumnOrSuperColumn _iter33 : _iter32.getValue())              {
+                _iter33.write(oprot);
+              }
+              oprot.writeListEnd();
+            }
+          }
+          oprot.writeMapEnd();
+        }
+        oprot.writeFieldEnd();
+      } else if (this.isSetIre()) {
+        oprot.writeFieldBegin(IRE_FIELD_DESC);
+        this.ire.write(oprot);
+        oprot.writeFieldEnd();
+      }
+      oprot.writeFieldStop();
+      oprot.writeStructEnd();
+    }
+
+    @Override
+    public String toString() {
+      StringBuilder sb = new StringBuilder("multiget_slice_result(");
+      boolean first = true;
+
+      sb.append("success:");
+      if (this.success == null) {
+        sb.append("null");
+      } else {
+        sb.append(this.success);
+      }
+      first = false;
+      if (!first) sb.append(", ");
+      sb.append("ire:");
+      if (this.ire == null) {
+        sb.append("null");
+      } else {
+        sb.append(this.ire);
+      }
+      first = false;
+      sb.append(")");
+      return sb.toString();
+    }
+
+    public void validate() throws TException {
+      // check for required fields
+      if (success == null) {
+        throw new TProtocolException("Required field 'success' was not present! Struct: " + toString());
+      }
+      if (ire == null) {
+        throw new TProtocolException("Required field 'ire' was not present! Struct: " + toString());
+      }
+      // check that fields of type enum have valid values
+    }
+
+  }
+
+  public static class get_args implements TBase, java.io.Serializable, Cloneable, Comparable<get_args>   {
+    private static final TStruct STRUCT_DESC = new TStruct("get_args");
+    private static final TField KEYSPACE_FIELD_DESC = new TField("keyspace", TType.STRING, (short)1);
+    private static final TField KEY_FIELD_DESC = new TField("key", TType.STRING, (short)2);
+    private static final TField COLUMN_PATH_FIELD_DESC = new TField("column_path", TType.STRUCT, (short)3);
+    private static final TField CONSISTENCY_LEVEL_FIELD_DESC = new TField("consistency_level", TType.I32, (short)4);
+
+    public String keyspace;
+    public static final int KEYSPACE = 1;
+    public String key;
+    public static final int KEY = 2;
+    public ColumnPath column_path;
+    public static final int COLUMN_PATH = 3;
+    /**
+     * 
+     * @see ConsistencyLevel
+     */
+    public int consistency_level;
+    public static final int CONSISTENCY_LEVEL = 4;
+
+    // isset id assignments
+    private static final int __CONSISTENCY_LEVEL_ISSET_ID = 0;
+    private BitSet __isset_bit_vector = new BitSet(1);
+
+    public static final Map<Integer, FieldMetaData> metaDataMap = Collections.unmodifiableMap(new HashMap<Integer, FieldMetaData>() {{
+      put(KEYSPACE, new FieldMetaData("keyspace", TFieldRequirementType.DEFAULT, 
+          new FieldValueMetaData(TType.STRING)));
+      put(KEY, new FieldMetaData("key", TFieldRequirementType.DEFAULT, 
+          new FieldValueMetaData(TType.STRING)));
+      put(COLUMN_PATH, new FieldMetaData("column_path", TFieldRequirementType.DEFAULT, 
+          new StructMetaData(TType.STRUCT, ColumnPath.class)));
+      put(CONSISTENCY_LEVEL, new FieldMetaData("consistency_level", TFieldRequirementType.DEFAULT, 
+          new FieldValueMetaData(TType.I32)));
+    }});
+
+    static {
+      FieldMetaData.addStructMetaDataMap(get_args.class, metaDataMap);
+    }
+
+    public get_args() {
+      this.consistency_level = 1;
+
+    }
+
+    public get_args(
+      String keyspace,
+      String key,
+      ColumnPath column_path,
+      int consistency_level)
+    {
+      this();
+      this.keyspace = keyspace;
+      this.key = key;
+      this.column_path = column_path;
+      this.consistency_level = consistency_level;
+      setConsistency_levelIsSet(true);
+    }
+
+    /**
+     * Performs a deep copy on <i>other</i>.
+     */
+    public get_args(get_args other) {
+      __isset_bit_vector.clear();
+      __isset_bit_vector.or(other.__isset_bit_vector);
+      if (other.isSetKeyspace()) {
+        this.keyspace = other.keyspace;
+      }
+      if (other.isSetKey()) {
+        this.key = other.key;
+      }
+      if (other.isSetColumn_path()) {
+        this.column_path = new ColumnPath(other.column_path);
+      }
+      this.consistency_level = other.consistency_level;
+    }
+
+    @Override
+    public get_args clone() {
+      return new get_args(this);
+    }
+
+    public String getKeyspace() {
+      return this.keyspace;
+    }
+
+    public get_args setKeyspace(String keyspace) {
+      this.keyspace = keyspace;
+      return this;
+    }
+
+    public void unsetKeyspace() {
+      this.keyspace = null;
+    }
+
+    // Returns true if field keyspace is set (has been asigned a value) and false otherwise
+    public boolean isSetKeyspace() {
+      return this.keyspace != null;
+    }
+
+    public void setKeyspaceIsSet(boolean value) {
+      if (!value) {
+        this.keyspace = null;
+      }
+    }
+
+    public String getKey() {
+      return this.key;
+    }
+
+    public get_args setKey(String key) {
+      this.key = key;
+      return this;
+    }
+
+    public void unsetKey() {
+      this.key = null;
+    }
+
+    // Returns true if field key is set (has been asigned a value) and false otherwise
+    public boolean isSetKey() {
+      return this.key != null;
+    }
+
+    public void setKeyIsSet(boolean value) {
+      if (!value) {
+        this.key = null;
+      }
+    }
+
+    public ColumnPath getColumn_path() {
+      return this.column_path;
+    }
+
+    public get_args setColumn_path(ColumnPath column_path) {
+      this.column_path = column_path;
+      return this;
+    }
+
+    public void unsetColumn_path() {
+      this.column_path = null;
+    }
+
+    // Returns true if field column_path is set (has been asigned a value) and false otherwise
+    public boolean isSetColumn_path() {
+      return this.column_path != null;
+    }
+
+    public void setColumn_pathIsSet(boolean value) {
+      if (!value) {
+        this.column_path = null;
+      }
+    }
+
+    /**
+     * 
+     * @see ConsistencyLevel
+     */
+    public int getConsistency_level() {
+      return this.consistency_level;
+    }
+
+    /**
+     * 
+     * @see ConsistencyLevel
+     */
+    public get_args setConsistency_level(int consistency_level) {
+      this.consistency_level = consistency_level;
+      setConsistency_levelIsSet(true);
+      return this;
+    }
+
+    public void unsetConsistency_level() {
+      __isset_bit_vector.clear(__CONSISTENCY_LEVEL_ISSET_ID);
+    }
+
+    // Returns true if field consistency_level is set (has been asigned a value) and false otherwise
+    public boolean isSetConsistency_level() {
+      return __isset_bit_vector.get(__CONSISTENCY_LEVEL_ISSET_ID);
+    }
+
+    public void setConsistency_levelIsSet(boolean value) {
+      __isset_bit_vector.set(__CONSISTENCY_LEVEL_ISSET_ID, value);
+    }
+
+    public void setFieldValue(int fieldID, Object value) {
+      switch (fieldID) {
+      case KEYSPACE:
+        if (value == null) {
+          unsetKeyspace();
+        } else {
+          setKeyspace((String)value);
+        }
+        break;
+
+      case KEY:
+        if (value == null) {
+          unsetKey();
+        } else {
+          setKey((String)value);
+        }
+        break;
+
+      case COLUMN_PATH:
+        if (value == null) {
+          unsetColumn_path();
+        } else {
+          setColumn_path((ColumnPath)value);
+        }
+        break;
+
+      case CONSISTENCY_LEVEL:
+        if (value == null) {
+          unsetConsistency_level();
+        } else {
+          setConsistency_level((Integer)value);
+        }
+        break;
+
+      default:
+        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
+      }
+    }
+
+    public Object getFieldValue(int fieldID) {
+      switch (fieldID) {
+      case KEYSPACE:
+        return getKeyspace();
+
+      case KEY:
+        return getKey();
+
+      case COLUMN_PATH:
+        return getColumn_path();
+
+      case CONSISTENCY_LEVEL:
+        return getConsistency_level();
+
+      default:
+        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
+      }
+    }
+
+    // Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise
+    public boolean isSet(int fieldID) {
+      switch (fieldID) {
+      case KEYSPACE:
+        return isSetKeyspace();
+      case KEY:
+        return isSetKey();
+      case COLUMN_PATH:
+        return isSetColumn_path();
+      case CONSISTENCY_LEVEL:
+        return isSetConsistency_level();
+      default:
+        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
+      }
+    }
+
+    @Override
+    public boolean equals(Object that) {
+      if (that == null)
+        return false;
+      if (that instanceof get_args)
+        return this.equals((get_args)that);
+      return false;
+    }
+
+    public boolean equals(get_args that) {
+      if (that == null)
+        return false;
+
+      boolean this_present_keyspace = true && this.isSetKeyspace();
+      boolean that_present_keyspace = true && that.isSetKeyspace();
+      if (this_present_keyspace || that_present_keyspace) {
+        if (!(this_present_keyspace && that_present_keyspace))
+          return false;
+        if (!this.keyspace.equals(that.keyspace))
+          return false;
+      }
+
+      boolean this_present_key = true && this.isSetKey();
+      boolean that_present_key = true && that.isSetKey();
+      if (this_present_key || that_present_key) {
+        if (!(this_present_key && that_present_key))
+          return false;
+        if (!this.key.equals(that.key))
+          return false;
+      }
+
+      boolean this_present_column_path = true && this.isSetColumn_path();
+      boolean that_present_column_path = true && that.isSetColumn_path();
+      if (this_present_column_path || that_present_column_path) {
+        if (!(this_present_column_path && that_present_column_path))
+          return false;
+        if (!this.column_path.equals(that.column_path))
+          return false;
+      }
+
+      boolean this_present_consistency_level = true;
+      boolean that_present_consistency_level = true;
+      if (this_present_consistency_level || that_present_consistency_level) {
+        if (!(this_present_consistency_level && that_present_consistency_level))
+          return false;
+        if (this.consistency_level != that.consistency_level)
+          return false;
+      }
+
+      return true;
+    }
+
+    @Override
+    public int hashCode() {
+      return 0;
+    }
+
+    public int compareTo(get_args other) {
+      if (!getClass().equals(other.getClass())) {
+        return getClass().getName().compareTo(other.getClass().getName());
+      }
+
+      int lastComparison = 0;
+      get_args typedOther = (get_args)other;
+
+      lastComparison = Boolean.valueOf(isSetKeyspace()).compareTo(isSetKeyspace());
+      if (lastComparison != 0) {
+        return lastComparison;
+      }
+      lastComparison = TBaseHelper.compareTo(keyspace, typedOther.keyspace);
+      if (lastComparison != 0) {
+        return lastComparison;
+      }
+      lastComparison = Boolean.valueOf(isSetKey()).compareTo(isSetKey());
+      if (lastComparison != 0) {
+        return lastComparison;
+      }
+      lastComparison = TBaseHelper.compareTo(key, typedOther.key);
+      if (lastComparison != 0) {
+        return lastComparison;
+      }
+      lastComparison = Boolean.valueOf(isSetColumn_path()).compareTo(isSetColumn_path());
+      if (lastComparison != 0) {
+        return lastComparison;
+      }
+      lastComparison = TBaseHelper.compareTo(column_path, typedOther.column_path);
+      if (lastComparison != 0) {
+        return lastComparison;
+      }
+      lastComparison = Boolean.valueOf(isSetConsistency_level()).compareTo(isSetConsistency_level());
+      if (lastComparison != 0) {
+        return lastComparison;
+      }
+      lastComparison = TBaseHelper.compareTo(consistency_level, typedOther.consistency_level);
+      if (lastComparison != 0) {
+        return lastComparison;
+      }
+      return 0;
+    }
+
+    public void read(TProtocol iprot) throws TException {
+      TField field;
+      iprot.readStructBegin();
+      while (true)
+      {
+        field = iprot.readFieldBegin();
+        if (field.type == TType.STOP) { 
+          break;
+        }
+        switch (field.id)
+        {
+          case KEYSPACE:
+            if (field.type == TType.STRING) {
+              this.keyspace = iprot.readString();
+            } else { 
+              TProtocolUtil.skip(iprot, field.type);
+            }
+            break;
+          case KEY:
+            if (field.type == TType.STRING) {
+              this.key = iprot.readString();
+            } else { 
+              TProtocolUtil.skip(iprot, field.type);
+            }
+            break;
+          case COLUMN_PATH:
+            if (field.type == TType.STRUCT) {
+              this.column_path = new ColumnPath();
+              this.column_path.read(iprot);
+            } else { 
+              TProtocolUtil.skip(iprot, field.type);
+            }
+            break;
+          case CONSISTENCY_LEVEL:
+            if (field.type == TType.I32) {
+              this.consistency_level = iprot.readI32();
+              setConsistency_levelIsSet(true);
+            } else { 
+              TProtocolUtil.skip(iprot, field.type);
+            }
+            break;
+          default:
+            TProtocolUtil.skip(iprot, field.type);
+            break;
+        }
+        iprot.readFieldEnd();
+      }
+      iprot.readStructEnd();
+
+
+      // check for required fields of primitive type, which can't be checked in the validate method
+      if (!isSetConsistency_level()) {
+        throw new TProtocolException("Required field 'consistency_level' was not found in serialized data! Struct: " + toString());
+      }
+      validate();
+    }
+
+    public void write(TProtocol oprot) throws TException {
+      validate();
+
+      oprot.writeStructBegin(STRUCT_DESC);
+      if (this.keyspace != null) {
+        oprot.writeFieldBegin(KEYSPACE_FIELD_DESC);
+        oprot.writeString(this.keyspace);
+        oprot.writeFieldEnd();
+      }
+      if (this.key != null) {
+        oprot.writeFieldBegin(KEY_FIELD_DESC);
+        oprot.writeString(this.key);
+        oprot.writeFieldEnd();
+      }
+      if (this.column_path != null) {
+        oprot.writeFieldBegin(COLUMN_PATH_FIELD_DESC);
+        this.column_path.write(oprot);
+        oprot.writeFieldEnd();
+      }
+      oprot.writeFieldBegin(CONSISTENCY_LEVEL_FIELD_DESC);
+      oprot.writeI32(this.consistency_level);
+      oprot.writeFieldEnd();
+      oprot.writeFieldStop();
+      oprot.writeStructEnd();
+    }
+
+    @Override
+    public String toString() {
+      StringBuilder sb = new StringBuilder("get_args(");
+      boolean first = true;
+
+      sb.append("keyspace:");
+      if (this.keyspace == null) {
+        sb.append("null");
+      } else {
+        sb.append(this.keyspace);
+      }
+      first = false;
+      if (!first) sb.append(", ");
+      sb.append("key:");
+      if (this.key == null) {
+        sb.append("null");
+      } else {
+        sb.append(this.key);
+      }
+      first = false;
+      if (!first) sb.append(", ");
+      sb.append("column_path:");
+      if (this.column_path == null) {
+        sb.append("null");
+      } else {
+        sb.append(this.column_path);
+      }
+      first = false;
+      if (!first) sb.append(", ");
+      sb.append("consistency_level:");
+      String consistency_level_name = ConsistencyLevel.VALUES_TO_NAMES.get(this.consistency_level);
+      if (consistency_level_name != null) {
+        sb.append(consistency_level_name);
+        sb.append(" (");
+      }
+      sb.append(this.consistency_level);
+      if (consistency_level_name != null) {
+        sb.append(")");
+      }
+      first = false;
+      sb.append(")");
+      return sb.toString();
+    }
+
+    public void validate() throws TException {
+      // check for required fields
+      if (keyspace == null) {
+        throw new TProtocolException("Required field 'keyspace' was not present! Struct: " + toString());
+      }
+      if (key == null) {
+        throw new TProtocolException("Required field 'key' was not present! Struct: " + toString());
+      }
+      if (column_path == null) {
+        throw new TProtocolException("Required field 'column_path' was not present! Struct: " + toString());
+      }
+      // 'consistency_level' is only checked in read() because it's a primitive and you chose the non-beans generator.
+      // check that fields of type enum have valid values
+      if (isSetConsistency_level() && !ConsistencyLevel.VALID_VALUES.contains(consistency_level)){
+        throw new TProtocolException("The field 'consistency_level' has been assigned the invalid value " + consistency_level);
+      }
+    }
+
+  }
+
+  public static class get_result implements TBase, java.io.Serializable, Cloneable, Comparable<get_result>   {
+    private static final TStruct STRUCT_DESC = new TStruct("get_result");
+    private static final TField SUCCESS_FIELD_DESC = new TField("success", TType.STRUCT, (short)0);
+    private static final TField IRE_FIELD_DESC = new TField("ire", TType.STRUCT, (short)1);
+    private static final TField NFE_FIELD_DESC = new TField("nfe", TType.STRUCT, (short)2);
+
+    public ColumnOrSuperColumn success;
+    public static final int SUCCESS = 0;
+    public InvalidRequestException ire;
+    public static final int IRE = 1;
+    public NotFoundException nfe;
+    public static final int NFE = 2;
+
+    // isset id assignments
+
+    public static final Map<Integer, FieldMetaData> metaDataMap = Collections.unmodifiableMap(new HashMap<Integer, FieldMetaData>() {{
+      put(SUCCESS, new FieldMetaData("success", TFieldRequirementType.DEFAULT, 
+          new StructMetaData(TType.STRUCT, ColumnOrSuperColumn.class)));
+      put(IRE, new FieldMetaData("ire", TFieldRequirementType.DEFAULT, 
+          new FieldValueMetaData(TType.STRUCT)));
+      put(NFE, new FieldMetaData("nfe", TFieldRequirementType.DEFAULT, 
+          new FieldValueMetaData(TType.STRUCT)));
+    }});
+
+    static {
+      FieldMetaData.addStructMetaDataMap(get_result.class, metaDataMap);
+    }
+
+    public get_result() {
+    }
+
+    public get_result(
+      ColumnOrSuperColumn success,
+      InvalidRequestException ire,
+      NotFoundException nfe)
+    {
+      this();
+      this.success = success;
+      this.ire = ire;
+      this.nfe = nfe;
+    }
+
+    /**
+     * Performs a deep copy on <i>other</i>.
+     */
+    public get_result(get_result other) {
+      if (other.isSetSuccess()) {
+        this.success = new ColumnOrSuperColumn(other.success);
+      }
+      if (other.isSetIre()) {
+        this.ire = new InvalidRequestException(other.ire);
+      }
+      if (other.isSetNfe()) {
+        this.nfe = new NotFoundException(other.nfe);
+      }
+    }
+
+    @Override
+    public get_result clone() {
+      return new get_result(this);
+    }
+
+    public ColumnOrSuperColumn getSuccess() {
+      return this.success;
+    }
+
+    public get_result setSuccess(ColumnOrSuperColumn success) {
+      this.success = success;
+      return this;
+    }
+
+    public void unsetSuccess() {
+      this.success = null;
+    }
+
+    // Returns true if field success is set (has been asigned a value) and false otherwise
+    public boolean isSetSuccess() {
+      return this.success != null;
+    }
+
+    public void setSuccessIsSet(boolean value) {
+      if (!value) {
+        this.success = null;
+      }
+    }
+
+    public InvalidRequestException getIre() {
+      return this.ire;
+    }
+
+    public get_result setIre(InvalidRequestException ire) {
+      this.ire = ire;
+      return this;
+    }
+
+    public void unsetIre() {
+      this.ire = null;
+    }
+
+    // Returns true if field ire is set (has been asigned a value) and false otherwise
+    public boolean isSetIre() {
+      return this.ire != null;
+    }
+
+    public void setIreIsSet(boolean value) {
+      if (!value) {
+        this.ire = null;
+      }
+    }
+
+    public NotFoundException getNfe() {
+      return this.nfe;
+    }
+
+    public get_result setNfe(NotFoundException nfe) {
+      this.nfe = nfe;
+      return this;
+    }
+
+    public void unsetNfe() {
+      this.nfe = null;
+    }
+
+    // Returns true if field nfe is set (has been asigned a value) and false otherwise
+    public boolean isSetNfe() {
+      return this.nfe != null;
+    }
+
+    public void setNfeIsSet(boolean value) {
+      if (!value) {
+        this.nfe = null;
+      }
+    }
+
+    public void setFieldValue(int fieldID, Object value) {
+      switch (fieldID) {
+      case SUCCESS:
+        if (value == null) {
+          unsetSuccess();
+        } else {
+          setSuccess((ColumnOrSuperColumn)value);
+        }
+        break;
+
+      case IRE:
+        if (value == null) {
+          unsetIre();
+        } else {
+          setIre((InvalidRequestException)value);
+        }
+        break;
+
+      case NFE:
+        if (value == null) {
+          unsetNfe();
+        } else {
+          setNfe((NotFoundException)value);
+        }
+        break;
+
+      default:
+        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
+      }
+    }
+
+    public Object getFieldValue(int fieldID) {
+      switch (fieldID) {
+      case SUCCESS:
+        return getSuccess();
+
+      case IRE:
+        return getIre();
+
+      case NFE:
+        return getNfe();
+
+      default:
+        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
+      }
+    }
+
+    // Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise
+    public boolean isSet(int fieldID) {
+      switch (fieldID) {
+      case SUCCESS:
+        return isSetSuccess();
+      case IRE:
+        return isSetIre();
+      case NFE:
+        return isSetNfe();
+      default:
+        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
+      }
+    }
+
+    @Override
+    public boolean equals(Object that) {
+      if (that == null)
+        return false;
+      if (that instanceof get_result)
+        return this.equals((get_result)that);
+      return false;
+    }
+
+    public boolean equals(get_result that) {
+      if (that == null)
+        return false;
+
+      boolean this_present_success = true && this.isSetSuccess();
+      boolean that_present_success = true && that.isSetSuccess();
+      if (this_present_success || that_present_success) {
+        if (!(this_present_success && that_present_success))
+          return false;
+        if (!this.success.equals(that.success))
+          return false;
+      }
+
+      boolean this_present_ire = true && this.isSetIre();
+      boolean that_present_ire = true && that.isSetIre();
+      if (this_present_ire || that_present_ire) {
+        if (!(this_present_ire && that_present_ire))
+          return false;
+        if (!this.ire.equals(that.ire))
+          return false;
+      }
+
+      boolean this_present_nfe = true && this.isSetNfe();
+      boolean that_present_nfe = true && that.isSetNfe();
+      if (this_present_nfe || that_present_nfe) {
+        if (!(this_present_nfe && that_present_nfe))
+          return false;
+        if (!this.nfe.equals(that.nfe))
+          return false;
+      }
+
+      return true;
+    }
+
+    @Override
+    public int hashCode() {
+      return 0;
+    }
+
+    public int compareTo(get_result other) {
+      if (!getClass().equals(other.getClass())) {
+        return getClass().getName().compareTo(other.getClass().getName());
+      }
+
+      int lastComparison = 0;
+      get_result typedOther = (get_result)other;
+
+      lastComparison = Boolean.valueOf(isSetSuccess()).compareTo(isSetSuccess());
+      if (lastComparison != 0) {
+        return lastComparison;
+      }
+      lastComparison = TBaseHelper.compareTo(success, typedOther.success);
+      if (lastComparison != 0) {
+        return lastComparison;
+      }
+      lastComparison = Boolean.valueOf(isSetIre()).compareTo(isSetIre());
+      if (lastComparison != 0) {
+        return lastComparison;
+      }
+      lastComparison = TBaseHelper.compareTo(ire, typedOther.ire);
+      if (lastComparison != 0) {
+        return lastComparison;
+      }
+      lastComparison = Boolean.valueOf(isSetNfe()).compareTo(isSetNfe());
+      if (lastComparison != 0) {
+        return lastComparison;
+      }
+      lastComparison = TBaseHelper.compareTo(nfe, typedOther.nfe);
+      if (lastComparison != 0) {
+        return lastComparison;
+      }
+      return 0;
+    }
+
+    public void read(TProtocol iprot) throws TException {
+      TField field;
+      iprot.readStructBegin();
+      while (true)
+      {
+        field = iprot.readFieldBegin();
+        if (field.type == TType.STOP) { 
+          break;
+        }
+        switch (field.id)
+        {
+          case SUCCESS:
+            if (field.type == TType.STRUCT) {
+              this.success = new ColumnOrSuperColumn();
+              this.success.read(iprot);
+            } else { 
+              TProtocolUtil.skip(iprot, field.type);
+            }
+            break;
+          case IRE:
+            if (field.type == TType.STRUCT) {
+              this.ire = new InvalidRequestException();
+              this.ire.read(iprot);
+            } else { 
+              TProtocolUtil.skip(iprot, field.type);
+            }
+            break;
+          case NFE:
+            if (field.type == TType.STRUCT) {
+              this.nfe = new NotFoundException();
+              this.nfe.read(iprot);
+            } else { 
+              TProtocolUtil.skip(iprot, field.type);
+            }
+            break;
+          default:
+            TProtocolUtil.skip(iprot, field.type);
+            break;
+        }
+        iprot.readFieldEnd();
+      }
+      iprot.readStructEnd();
+
+
+      // check for required fields of primitive type, which can't be checked in the validate method
+      validate();
+    }
+
+    public void write(TProtocol oprot) throws TException {
+      oprot.writeStructBegin(STRUCT_DESC);
+
+      if (this.isSetSuccess()) {
+        oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
+        this.success.write(oprot);
+        oprot.writeFieldEnd();
+      } else if (this.isSetIre()) {
+        oprot.writeFieldBegin(IRE_FIELD_DESC);
+        this.ire.write(oprot);
+        oprot.writeFieldEnd();
+      } else if (this.isSetNfe()) {
+        oprot.writeFieldBegin(NFE_FIELD_DESC);
+        this.nfe.write(oprot);
+        oprot.writeFieldEnd();
+      }
+      oprot.writeFieldStop();
+      oprot.writeStructEnd();
+    }
+
+    @Override
+    public String toString() {
+      StringBuilder sb = new StringBuilder("get_result(");
+      boolean first = true;
+
+      sb.append("success:");
+      if (this.success == null) {
+        sb.append("null");
+      } else {
+        sb.append(this.success);
+      }
+      first = false;
+      if (!first) sb.append(", ");
+      sb.append("ire:");
+      if (this.ire == null) {
+        sb.append("null");
+      } else {
+        sb.append(this.ire);
+      }
+      first = false;
+      if (!first) sb.append(", ");
+      sb.append("nfe:");
+      if (this.nfe == null) {
+        sb.append("null");
+      } else {
+        sb.append(this.nfe);
+      }
+      first = false;
+      sb.append(")");
+      return sb.toString();
+    }
+
+    public void validate() throws TException {
+      // check for required fields
+      if (success == null) {
+        throw new TProtocolException("Required field 'success' was not present! Struct: " + toString());
+      }
+      if (ire == null) {
+        throw new TProtocolException("Required field 'ire' was not present! Struct: " + toString());
+      }
+      if (nfe == null) {
+        throw new TProtocolException("Required field 'nfe' was not present! Struct: " + toString());
+      }
+      // check that fields of type enum have valid values
+    }
+
+  }
+
+  public static class multiget_args implements TBase, java.io.Serializable, Cloneable, Comparable<multiget_args>   {
+    private static final TStruct STRUCT_DESC = new TStruct("multiget_args");
+    private static final TField KEYSPACE_FIELD_DESC = new TField("keyspace", TType.STRING, (short)1);
+    private static final TField KEYS_FIELD_DESC = new TField("keys", TType.LIST, (short)2);
+    private static final TField COLUMN_PATH_FIELD_DESC = new TField("column_path", TType.STRUCT, (short)3);
+    private static final TField CONSISTENCY_LEVEL_FIELD_DESC = new TField("consistency_level", TType.I32, (short)4);
+
+    public String keyspace;
+    public static final int KEYSPACE = 1;
+    public List<String> keys;
+    public static final int KEYS = 2;
+    public ColumnPath column_path;
+    public static final int COLUMN_PATH = 3;
+    /**
+     * 
+     * @see ConsistencyLevel
+     */
+    public int consistency_level;
+    public static final int CONSISTENCY_LEVEL = 4;
+
+    // isset id assignments
+    private static final int __CONSISTENCY_LEVEL_ISSET_ID = 0;
+    private BitSet __isset_bit_vector = new BitSet(1);
+
+    public static final Map<Integer, FieldMetaData> metaDataMap = Collections.unmodifiableMap(new HashMap<Integer, FieldMetaData>() {{
+      put(KEYSPACE, new FieldMetaData("keyspace", TFieldRequirementType.DEFAULT, 
+          new FieldValueMetaData(TType.STRING)));
+      put(KEYS, new FieldMetaData("keys", TFieldRequirementType.DEFAULT, 
+          new ListMetaData(TType.LIST, 
+              new FieldValueMetaData(TType.STRING))));
+      put(COLUMN_PATH, new FieldMetaData("column_path", TFieldRequirementType.DEFAULT, 
+          new StructMetaData(TType.STRUCT, ColumnPath.class)));
+      put(CONSISTENCY_LEVEL, new FieldMetaData("consistency_level", TFieldRequirementType.DEFAULT, 
+          new FieldValueMetaData(TType.I32)));
+    }});
+
+    static {
+      FieldMetaData.addStructMetaDataMap(multiget_args.class, metaDataMap);
+    }
+
+    public multiget_args() {
+      this.consistency_level = 1;
+
+    }
+
+    public multiget_args(
+      String keyspace,
+      List<String> keys,
+      ColumnPath column_path,
+      int consistency_level)
+    {
+      this();
+      this.keyspace = keyspace;
+      this.keys = keys;
+      this.column_path = column_path;
+      this.consistency_level = consistency_level;
+      setConsistency_levelIsSet(true);
+    }
+
+    /**
+     * Performs a deep copy on <i>other</i>.
+     */
+    public multiget_args(multiget_args other) {
+      __isset_bit_vector.clear();
+      __isset_bit_vector.or(other.__isset_bit_vector);
+      if (other.isSetKeyspace()) {
+        this.keyspace = other.keyspace;
+      }
+      if (other.isSetKeys()) {
+        List<String> __this__keys = new ArrayList<String>();
+        for (String other_element : other.keys) {
+          __this__keys.add(other_element);
+        }
+        this.keys = __this__keys;
+      }
+      if (other.isSetColumn_path()) {
+        this.column_path = new ColumnPath(other.column_path);
+      }
+      this.consistency_level = other.consistency_level;
+    }
+
+    @Override
+    public multiget_args clone() {
+      return new multiget_args(this);
+    }
+
+    public String getKeyspace() {
+      return this.keyspace;
+    }
+
+    public multiget_args setKeyspace(String keyspace) {
+      this.keyspace = keyspace;
+      return this;
+    }
+
+    public void unsetKeyspace() {
+      this.keyspace = null;
+    }
+
+    // Returns true if field keyspace is set (has been asigned a value) and false otherwise
+    public boolean isSetKeyspace() {
+      return this.keyspace != null;
+    }
+
+    public void setKeyspaceIsSet(boolean value) {
+      if (!value) {
+        this.keyspace = null;
+      }
+    }
+
+    public List<String> getKeys() {
+      return this.keys;
+    }
+
+    public multiget_args setKeys(List<String> keys) {
+      this.keys = keys;
+      return this;
+    }
+
+    public void unsetKeys() {
+      this.keys = null;
+    }
+
+    // Returns true if field keys is set (has been asigned a value) and false otherwise
+    public boolean isSetKeys() {
+      return this.keys != null;
+    }
+
+    public void setKeysIsSet(boolean value) {
+      if (!value) {
+        this.keys = null;
+      }
+    }
+
+    public ColumnPath getColumn_path() {
+      return this.column_path;
+    }
+
+    public multiget_args setColumn_path(ColumnPath column_path) {
+      this.column_path = column_path;
+      return this;
+    }
+
+    public void unsetColumn_path() {
+      this.column_path = null;
+    }
+
+    // Returns true if field column_path is set (has been asigned a value) and false otherwise
+    public boolean isSetColumn_path() {
+      return this.column_path != null;
+    }
+
+    public void setColumn_pathIsSet(boolean value) {
+      if (!value) {
+        this.column_path = null;
+      }
+    }
+
+    /**
+     * 
+     * @see ConsistencyLevel
+     */
+    public int getConsistency_level() {
+      return this.consistency_level;
+    }
+
+    /**
+     * 
+     * @see ConsistencyLevel
+     */
+    public multiget_args setConsistency_level(int consistency_level) {
+      this.consistency_level = consistency_level;
+      setConsistency_levelIsSet(true);
+      return this;
+    }
+
+    public void unsetConsistency_level() {
+      __isset_bit_vector.clear(__CONSISTENCY_LEVEL_ISSET_ID);
+    }
+
+    // Returns true if field consistency_level is set (has been asigned a value) and false otherwise
+    public boolean isSetConsistency_level() {
+      return __isset_bit_vector.get(__CONSISTENCY_LEVEL_ISSET_ID);
+    }
+
+    public void setConsistency_levelIsSet(boolean value) {
+      __isset_bit_vector.set(__CONSISTENCY_LEVEL_ISSET_ID, value);
+    }
+
+    public void setFieldValue(int fieldID, Object value) {
+      switch (fieldID) {
+      case KEYSPACE:
+        if (value == null) {
+          unsetKeyspace();
+        } else {
+          setKeyspace((String)value);
+        }
+        break;
+
+      case KEYS:
+        if (value == null) {
+          unsetKeys();
+        } else {
+          setKeys((List<String>)value);
+        }
+        break;
+
+      case COLUMN_PATH:
+        if (value == null) {
+          unsetColumn_path();
+        } else {
+          setColumn_path((ColumnPath)value);
+        }
+        break;
+
+      case CONSISTENCY_LEVEL:
+        if (value == null) {
+          unsetConsistency_level();
+        } else {
+          setConsistency_level((Integer)value);
+        }
+        break;
+
+      default:
+        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
+      }
+    }
+
+    public Object getFieldValue(int fieldID) {
+      switch (fieldID) {
+      case KEYSPACE:
+        return getKeyspace();
+
+      case KEYS:
+        return getKeys();
+
+      case COLUMN_PATH:
+        return getColumn_path();
+
+      case CONSISTENCY_LEVEL:
+        return getConsistency_level();
+
+      default:
+        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
+      }
+    }
+
+    // Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise
+    public boolean isSet(int fieldID) {
+      switch (fieldID) {
+      case KEYSPACE:
+        return isSetKeyspace();
+      case KEYS:
+        return isSetKeys();
+      case COLUMN_PATH:
+        return isSetColumn_path();
+      case CONSISTENCY_LEVEL:
+        return isSetConsistency_level();
+      default:
+        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
+      }
+    }
+
+    @Override
+    public boolean equals(Object that) {
+      if (that == null)
+        return false;
+      if (that instanceof multiget_args)
+        return this.equals((multiget_args)that);
+      return false;
+    }
+
+    public boolean equals(multiget_args that) {
+      if (that == null)
+        return false;
+
+      boolean this_present_keyspace = true && this.isSetKeyspace();
+      boolean that_present_keyspace = true && that.isSetKeyspace();
+      if (this_present_keyspace || that_present_keyspace) {
+        if (!(this_present_keyspace && that_present_keyspace))
+          return false;
+        if (!this.keyspace.equals(that.keyspace))
+          return false;
+      }
+
+      boolean this_present_keys = true && this.isSetKeys();
+      boolean that_present_keys = true && that.isSetKeys();
+      if (this_present_keys || that_present_keys) {
+        if (!(this_present_keys && that_present_keys))
+          return false;
+        if (!this.keys.equals(that.keys))
+          return false;
+      }
+
+      boolean this_present_column_path = true && this.isSetColumn_path();
+      boolean that_present_column_path = true && that.isSetColumn_path();
+      if (this_present_column_path || that_present_column_path) {
+        if (!(this_present_column_path && that_present_column_path))
+          return false;
+        if (!this.column_path.equals(that.column_path))
+          return false;
+      }
+
+      boolean this_present_consistency_level = true;
+      boolean that_present_consistency_level = true;
+      if (this_present_consistency_level || that_present_consistency_level) {
+        if (!(this_present_consistency_level && that_present_consistency_level))
+          return false;
+        if (this.consistency_level != that.consistency_level)
+          return false;
+      }
+
+      return true;
+    }
+
+    @Override
+    public int hashCode() {
+      return 0;
+    }
+
+    public int compareTo(multiget_args other) {
+      if (!getClass().equals(other.getClass())) {
+        return getClass().getName().compareTo(other.getClass().getName());
+      }
+
+      int lastComparison = 0;
+      multiget_args typedOther = (multiget_args)other;
+
+      lastComparison = Boolean.valueOf(isSetKeyspace()).compareTo(isSetKeyspace());
+      if (lastComparison != 0) {
+        return lastComparison;
+      }
+      lastComparison = TBaseHelper.compareTo(keyspace, typedOther.keyspace);
+      if (lastComparison != 0) {
+        return lastComparison;
+      }
+      lastComparison = Boolean.valueOf(isSetKeys()).compareTo(isSetKeys());
+      if (lastComparison != 0) {
+        return lastComparison;
+      }
+      lastComparison = TBaseHelper.compareTo(keys, typedOther.keys);
+      if (lastComparison != 0) {
+        return lastComparison;
+      }
+      lastComparison = Boolean.valueOf(isSetColumn_path()).compareTo(isSetColumn_path());
+      if (lastComparison != 0) {
+        return lastComparison;
+      }
+      lastComparison = TBaseHelper.compareTo(column_path, typedOther.column_path);
+      if (lastComparison != 0) {
+        return lastComparison;
+      }
+      lastComparison = Boolean.valueOf(isSetConsistency_level()).compareTo(isSetConsistency_level());
+      if (lastComparison != 0) {
+        return lastComparison;
+      }
+      lastComparison = TBaseHelper.compareTo(consistency_level, typedOther.consistency_level);
+      if (lastComparison != 0) {
+        return lastComparison;
+      }
+      return 0;
+    }
+
+    public void read(TProtocol iprot) throws TException {
+      TField field;
+      iprot.readStructBegin();
+      while (true)
+      {
+        field = iprot.readFieldBegin();
+        if (field.type == TType.STOP) { 
+          break;
+        }
+        switch (field.id)
+        {
+          case KEYSPACE:
+            if (field.type == TType.STRING) {
+              this.keyspace = iprot.readString();
+            } else { 
+              TProtocolUtil.skip(iprot, field.type);
+            }
+            break;
+          case KEYS:
+            if (field.type == TType.LIST) {
+              {
+                TList _list34 = iprot.readListBegin();
+                this.keys = new ArrayList<String>(_list34.size);
+                for (int _i35 = 0; _i35 < _list34.size; ++_i35)
+                {
+                  String _elem36;
+                  _elem36 = iprot.readString();
+                  this.keys.add(_elem36);
+                }
+                iprot.readListEnd();
+              }
+            } else { 
+              TProtocolUtil.skip(iprot, field.type);
+            }
+            break;
+          case COLUMN_PATH:
+            if (field.type == TType.STRUCT) {
+              this.column_path = new ColumnPath();
+              this.column_path.read(iprot);
+            } else { 
+              TProtocolUtil.skip(iprot, field.type);
+            }
+            break;
+          case CONSISTENCY_LEVEL:
+            if (field.type == TType.I32) {
+              this.consistency_level = iprot.readI32();
+              setConsistency_levelIsSet(true);
+            } else { 
+              TProtocolUtil.skip(iprot, field.type);
+            }
+            break;
+          default:
+            TProtocolUtil.skip(iprot, field.type);
+            break;
+        }
+        iprot.readFieldEnd();
+      }
+      iprot.readStructEnd();
+
+
+      // check for required fields of primitive type, which can't be checked in the validate method
+      if (!isSetConsistency_level()) {
+        throw new TProtocolException("Required field 'consistency_level' was not found in serialized data! Struct: " + toString());
+      }
+      validate();
+    }
+
+    public void write(TProtocol oprot) throws TException {
+      validate();
+
+      oprot.writeStructBegin(STRUCT_DESC);
+      if (this.keyspace != null) {
+        oprot.writeFieldBegin(KEYSPACE_FIELD_DESC);
+        oprot.writeString(this.keyspace);
+        oprot.writeFieldEnd();
+      }
+      if (this.keys != null) {
+        oprot.writeFieldBegin(KEYS_FIELD_DESC);
+        {
+          oprot.writeListBegin(new TList(TType.STRING, this.keys.size()));
+          for (String _iter37 : this.keys)          {
+            oprot.writeString(_iter37);
+          }
+          oprot.writeListEnd();
+        }
+        oprot.writeFieldEnd();
+      }
+      if (this.column_path != null) {
+        oprot.writeFieldBegin(COLUMN_PATH_FIELD_DESC);
+        this.column_path.write(oprot);
+        oprot.writeFieldEnd();
+      }
+      oprot.writeFieldBegin(CONSISTENCY_LEVEL_FIELD_DESC);
+      oprot.writeI32(this.consistency_level);
+      oprot.writeFieldEnd();
+      oprot.writeFieldStop();
+      oprot.writeStructEnd();
+    }
+
+    @Override
+    public String toString() {
+      StringBuilder sb = new StringBuilder("multiget_args(");
+      boolean first = true;
+
+      sb.append("keyspace:");
+      if (this.keyspace == null) {
+        sb.append("null");
+      } else {
+        sb.append(this.keyspace);
+      }
+      first = false;
+      if (!first) sb.append(", ");
+      sb.append("keys:");
+      if (this.keys == null) {
+        sb.append("null");
+      } else {
+        sb.append(this.keys);
+      }
+      first = false;
+      if (!first) sb.append(", ");
+      sb.append("column_path:");
+      if (this.column_path == null) {
+        sb.append("null");
+      } else {
+        sb.append(this.column_path);
+      }
+      first = false;
+      if (!first) sb.append(", ");
+      sb.append("consistency_level:");
+      String consistency_level_name = ConsistencyLevel.VALUES_TO_NAMES.get(this.consistency_level);
+      if (consistency_level_name != null) {
+        sb.append(consistency_level_name);
+        sb.append(" (");
+      }
+      sb.append(this.consistency_level);
+      if (consistency_level_name != null) {
+        sb.append(")");
+      }
+      first = false;
+      sb.append(")");
+      return sb.toString();
+    }
+
+    public void validate() throws TException {
+      // check for required fields
+      if (keyspace == null) {
+        throw new TProtocolException("Required field 'keyspace' was not present! Struct: " + toString());
+      }
+      if (keys == null) {
+        throw new TProtocolException("Required field 'keys' was not present! Struct: " + toString());
+      }
+      if (column_path == null) {
+        throw new TProtocolException("Required field 'column_path' was not present! Struct: " + toString());
+      }
+      // 'consistency_level' is only checked in read() because it's a primitive and you chose the non-beans generator.
+      // check that fields of type enum have valid values
+      if (isSetConsistency_level() && !ConsistencyLevel.VALID_VALUES.contains(consistency_level)){
+        throw new TProtocolException("The field 'consistency_level' has been assigned the invalid value " + consistency_level);
+      }
+    }
+
+  }
+
+  public static class multiget_result implements TBase, java.io.Serializable, Cloneable   {
+    private static final TStruct STRUCT_DESC = new TStruct("multiget_result");
+    private static final TField SUCCESS_FIELD_DESC = new TField("success", TType.MAP, (short)0);
+    private static final TField IRE_FIELD_DESC = new TField("ire", TType.STRUCT, (short)1);
+
+    public Map<String,ColumnOrSuperColumn> success;
+    public static final int SUCCESS = 0;
+    public InvalidRequestException ire;
+    public static final int IRE = 1;
+
+    // isset id assignments
+
+    public static final Map<Integer, FieldMetaData> metaDataMap = Collections.unmodifiableMap(new HashMap<Integer, FieldMetaData>() {{
+      put(SUCCESS, new FieldMetaData("success", TFieldRequirementType.DEFAULT, 
+          new MapMetaData(TType.MAP, 
+              new FieldValueMetaData(TType.STRING), 
+              new StructMetaData(TType.STRUCT, ColumnOrSuperColumn.class))));
+      put(IRE, new FieldMetaData("ire", TFieldRequirementType.DEFAULT, 
+          new FieldValueMetaData(TType.STRUCT)));
+    }});
+
+    static {
+      FieldMetaData.addStructMetaDataMap(multiget_result.class, metaDataMap);
+    }
+
+    public multiget_result() {
+    }
+
+    public multiget_result(
+      Map<String,ColumnOrSuperColumn> success,
+      InvalidRequestException ire)
+    {
+      this();
+      this.success = success;
+      this.ire = ire;
+    }
+
+    /**
+     * Performs a deep copy on <i>other</i>.
+     */
+    public multiget_result(multiget_result other) {
+      if (other.isSetSuccess()) {
+        Map<String,ColumnOrSuperColumn> __this__success = new HashMap<String,ColumnOrSuperColumn>();
+        for (Map.Entry<String, ColumnOrSuperColumn> other_element : other.success.entrySet()) {
+
+          String other_element_key = other_element.getKey();
+          ColumnOrSuperColumn other_element_value = other_element.getValue();
+
+          String __this__success_copy_key = other_element_key;
+
+          ColumnOrSuperColumn __this__success_copy_value = new ColumnOrSuperColumn(other_element_value);
+
+          __this__success.put(__this__success_copy_key, __this__success_copy_value);
+        }
+        this.success = __this__success;
+      }
+      if (other.isSetIre()) {
+        this.ire = new InvalidRequestException(other.ire);
+      }
+    }
+
+    @Override
+    public multiget_result clone() {
+      return new multiget_result(this);
+    }
+
+    public Map<String,ColumnOrSuperColumn> getSuccess() {
+      return this.success;
+    }
+
+    public multiget_result setSuccess(Map<String,ColumnOrSuperColumn> success) {
+      this.success = success;
+      return this;
+    }
+
+    public void unsetSuccess() {
+      this.success = null;
+    }
+
+    // Returns true if field success is set (has been asigned a value) and false otherwise
+    public boolean isSetSuccess() {
+      return this.success != null;
+    }
+
+    public void setSuccessIsSet(boolean value) {
+      if (!value) {
+        this.success = null;
+      }
+    }
+
+    public InvalidRequestException getIre() {
+      return this.ire;
+    }
+
+    public multiget_result setIre(InvalidRequestException ire) {
+      this.ire = ire;
+      return this;
+    }
+
+    public void unsetIre() {
+      this.ire = null;
+    }
+
+    // Returns true if field ire is set (has been asigned a value) and false otherwise
+    public boolean isSetIre() {
+      return this.ire != null;
+    }
+
+    public void setIreIsSet(boolean value) {
+      if (!value) {
+        this.ire = null;
+      }
+    }
+
+    public void setFieldValue(int fieldID, Object value) {
+      switch (fieldID) {
+      case SUCCESS:
+        if (value == null) {
+          unsetSuccess();
+        } else {
+          setSuccess((Map<String,ColumnOrSuperColumn>)value);
+        }
+        break;
+
+      case IRE:
+        if (value == null) {
+          unsetIre();
+        } else {
+          setIre((InvalidRequestException)value);
+        }
+        break;
+
+      default:
+        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
+      }
+    }
+
+    public Object getFieldValue(int fieldID) {
+      switch (fieldID) {
+      case SUCCESS:
+        return getSuccess();
+
+      case IRE:
+        return getIre();
+
+      default:
+        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
+      }
+    }
+
+    // Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise
+    public boolean isSet(int fieldID) {
+      switch (fieldID) {
+      case SUCCESS:
+        return isSetSuccess();
+      case IRE:
+        return isSetIre();
+      default:
+        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
+      }
+    }
+
+    @Override
+    public boolean equals(Object that) {
+      if (that == null)
+        return false;
+      if (that instanceof multiget_result)
+        return this.equals((multiget_result)that);
+      return false;
+    }
+
+    public boolean equals(multiget_result that) {
+      if (that == null)
+        return false;
+
+      boolean this_present_success = true && this.isSetSuccess();
+      boolean that_present_success = true && that.isSetSuccess();
+      if (this_present_success || that_present_success) {
+        if (!(this_present_success && that_present_success))
+          return false;
+        if (!this.success.equals(that.success))
+          return false;
+      }
+
+      boolean this_present_ire = true && this.isSetIre();
+      boolean that_present_ire = true && that.isSetIre();
+      if (this_present_ire || that_present_ire) {
+        if (!(this_present_ire && that_present_ire))
+          return false;
+        if (!this.ire.equals(that.ire))
+          return false;
+      }
+
+      return true;
+    }
+
+    @Override
+    public int hashCode() {
+      return 0;
+    }
+
+    public void read(TProtocol iprot) throws TException {
+      TField field;
+      iprot.readStructBegin();
+      while (true)
+      {
+        field = iprot.readFieldBegin();
+        if (field.type == TType.STOP) { 
+          break;
+        }
+        switch (field.id)
+        {
+          case SUCCESS:
+            if (field.type == TType.MAP) {
+              {
+                TMap _map38 = iprot.readMapBegin();
+                this.success = new HashMap<String,ColumnOrSuperColumn>(2*_map38.size);
+                for (int _i39 = 0; _i39 < _map38.size; ++_i39)
+                {
+                  String _key40;
+                  ColumnOrSuperColumn _val41;
+                  _key40 = iprot.readString();
+                  _val41 = new ColumnOrSuperColumn();
+                  _val41.read(iprot);
+                  this.success.put(_key40, _val41);
+                }
+                iprot.readMapEnd();
+              }
+            } else { 
+              TProtocolUtil.skip(iprot, field.type);
+            }
+            break;
+          case IRE:
+            if (field.type == TType.STRUCT) {
+              this.ire = new InvalidRequestException();
+              this.ire.read(iprot);
+            } else { 
+              TProtocolUtil.skip(iprot, field.type);
+            }
+            break;
+          default:
+            TProtocolUtil.skip(iprot, field.type);
+            break;
+        }
+        iprot.readFieldEnd();
+      }
+      iprot.readStructEnd();
+
+
+      // check for required fields of primitive type, which can't be checked in the validate method
+      validate();
+    }
+
+    public void write(TProtocol oprot) throws TException {
+      oprot.writeStructBegin(STRUCT_DESC);
+
+      if (this.isSetSuccess()) {
+        oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
+        {
+          oprot.writeMapBegin(new TMap(TType.STRING, TType.STRUCT, this.success.size()));
+          for (Map.Entry<String, ColumnOrSuperColumn> _iter42 : this.success.entrySet())          {
+            oprot.writeString(_iter42.getKey());
+            _iter42.getValue().write(oprot);
+          }
+          oprot.writeMapEnd();
+        }
+        oprot.writeFieldEnd();
+      } else if (this.isSetIre()) {
+        oprot.writeFieldBegin(IRE_FIELD_DESC);
+        this.ire.write(oprot);
+        oprot.writeFieldEnd();
+      }
+      oprot.writeFieldStop();
+      oprot.writeStructEnd();
+    }
+
+    @Override
+    public String toString() {
+      StringBuilder sb = new StringBuilder("multiget_result(");
+      boolean first = true;
+
+      sb.append("success:");
+      if (this.success == null) {
+        sb.append("null");
+      } else {
+        sb.append(this.success);
+      }
+      first = false;
+      if (!first) sb.append(", ");
+      sb.append("ire:");
+      if (this.ire == null) {
+        sb.append("null");
+      } else {
+        sb.append(this.ire);
+      }
+      first = false;
+      sb.append(")");
+      return sb.toString();
+    }
+
+    public void validate() throws TException {
+      // check for required fields
+      if (success == null) {
+        throw new TProtocolException("Required field 'success' was not present! Struct: " + toString());
+      }
+      if (ire == null) {
+        throw new TProtocolException("Required field 'ire' was not present! Struct: " + toString());
+      }
+      // check that fields of type enum have valid values
+    }
+
+  }
+
+  public static class get_count_args implements TBase, java.io.Serializable, Cloneable, Comparable<get_count_args>   {
+    private static final TStruct STRUCT_DESC = new TStruct("get_count_args");
+    private static final TField KEYSPACE_FIELD_DESC = new TField("keyspace", TType.STRING, (short)1);
+    private static final TField KEY_FIELD_DESC = new TField("key", TType.STRING, (short)2);
+    private static final TField COLUMN_PARENT_FIELD_DESC = new TField("column_parent", TType.STRUCT, (short)3);
+    private static final TField CONSISTENCY_LEVEL_FIELD_DESC = new TField("consistency_level", TType.I32, (short)5);
+
+    public String keyspace;
+    public static final int KEYSPACE = 1;
+    public String key;
+    public static final int KEY = 2;
+    public ColumnParent column_parent;
+    public static final int COLUMN_PARENT = 3;
+    /**
+     * 
+     * @see ConsistencyLevel
+     */
+    public int consistency_level;
+    public static final int CONSISTENCY_LEVEL = 5;
+
+    // isset id assignments
+    private static final int __CONSISTENCY_LEVEL_ISSET_ID = 0;
+    private BitSet __isset_bit_vector = new BitSet(1);
+
+    public static final Map<Integer, FieldMetaData> metaDataMap = Collections.unmodifiableMap(new HashMap<Integer, FieldMetaData>() {{
+      put(KEYSPACE, new FieldMetaData("keyspace", TFieldRequirementType.DEFAULT, 
+          new FieldValueMetaData(TType.STRING)));
+      put(KEY, new FieldMetaData("key", TFieldRequirementType.DEFAULT, 
+          new FieldValueMetaData(TType.STRING)));
+      put(COLUMN_PARENT, new FieldMetaData("column_parent", TFieldRequirementType.DEFAULT, 
+          new StructMetaData(TType.STRUCT, ColumnParent.class)));
+      put(CONSISTENCY_LEVEL, new FieldMetaData("consistency_level", TFieldRequirementType.DEFAULT, 
+          new FieldValueMetaData(TType.I32)));
+    }});
+
+    static {
+      FieldMetaData.addStructMetaDataMap(get_count_args.class, metaDataMap);
+    }
+
+    public get_count_args() {
+      this.consistency_level = 1;
+
+    }
+
+    public get_count_args(
+      String keyspace,
+      String key,
+      ColumnParent column_parent,
+      int consistency_level)
+    {
+      this();
+      this.keyspace = keyspace;
+      this.key = key;
+      this.column_parent = column_parent;
+      this.consistency_level = consistency_level;
+      setConsistency_levelIsSet(true);
+    }
+
+    /**
+     * Performs a deep copy on <i>other</i>.
+     */
+    public get_count_args(get_count_args other) {
+      __isset_bit_vector.clear();
+      __isset_bit_vector.or(other.__isset_bit_vector);
+      if (other.isSetKeyspace()) {
+        this.keyspace = other.keyspace;
+      }
+      if (other.isSetKey()) {
+        this.key = other.key;
+      }
+      if (other.isSetColumn_parent()) {
+        this.column_parent = new ColumnParent(other.column_parent);
+      }
+      this.consistency_level = other.consistency_level;
+    }
+
+    @Override
+    public get_count_args clone() {
+      return new get_count_args(this);
+    }
+
+    public String getKeyspace() {
+      return this.keyspace;
+    }
+
+    public get_count_args setKeyspace(String keyspace) {
+      this.keyspace = keyspace;
+      return this;
+    }
+
+    public void unsetKeyspace() {
+      this.keyspace = null;
+    }
+
+    // Returns true if field keyspace is set (has been asigned a value) and false otherwise
+    public boolean isSetKeyspace() {
+      return this.keyspace != null;
+    }
+
+    public void setKeyspaceIsSet(boolean value) {
+      if (!value) {
+        this.keyspace = null;
+      }
+    }
+
+    public String getKey() {
+      return this.key;
+    }
+
+    public get_count_args setKey(String key) {
+      this.key = key;
+      return this;
+    }
+
+    public void unsetKey() {
+      this.key = null;
+    }
+
+    // Returns true if field key is set (has been asigned a value) and false otherwise
+    public boolean isSetKey() {
+      return this.key != null;
+    }
+
+    public void setKeyIsSet(boolean value) {
+      if (!value) {
+        this.key = null;
+      }
+    }
+
+    public ColumnParent getColumn_parent() {
+      return this.column_parent;
+    }
+
+    public get_count_args setColumn_parent(ColumnParent column_parent) {
+      this.column_parent = column_parent;
+      return this;
+    }
+
+    public void unsetColumn_parent() {
+      this.column_parent = null;
+    }
+
+    // Returns true if field column_parent is set (has been asigned a value) and false otherwise
+    public boolean isSetColumn_parent() {
+      return this.column_parent != null;
+    }
+
+    public void setColumn_parentIsSet(boolean value) {
+      if (!value) {
+        this.column_parent = null;
+      }
+    }
+
+    /**
+     * 
+     * @see ConsistencyLevel
+     */
+    public int getConsistency_level() {
+      return this.consistency_level;
+    }
+
+    /**
+     * 
+     * @see ConsistencyLevel
+     */
+    public get_count_args setConsistency_level(int consistency_level) {
+      this.consistency_level = consistency_level;
+      setConsistency_levelIsSet(true);
+      return this;
+    }
+
+    public void unsetConsistency_level() {
+      __isset_bit_vector.clear(__CONSISTENCY_LEVEL_ISSET_ID);
     }
 
     // Returns true if field consistency_level is set (has been asigned a value) and false otherwise
@@ -2001,11 +4897,11 @@ public class Cassandra {
         }
         break;
 
-      case COLUMN_PATH:
+      case COLUMN_PARENT:
         if (value == null) {
-          unsetColumn_path();
+          unsetColumn_parent();
         } else {
-          setColumn_path((ColumnPath)value);
+          setColumn_parent((ColumnParent)value);
         }
         break;
 
@@ -2030,8 +4926,8 @@ public class Cassandra {
       case KEY:
         return getKey();
 
-      case COLUMN_PATH:
-        return getColumn_path();
+      case COLUMN_PARENT:
+        return getColumn_parent();
 
       case CONSISTENCY_LEVEL:
         return getConsistency_level();
@@ -2048,8 +4944,8 @@ public class Cassandra {
         return isSetKeyspace();
       case KEY:
         return isSetKey();
-      case COLUMN_PATH:
-        return isSetColumn_path();
+      case COLUMN_PARENT:
+        return isSetColumn_parent();
       case CONSISTENCY_LEVEL:
         return isSetConsistency_level();
       default:
@@ -2061,12 +4957,12 @@ public class Cassandra {
     public boolean equals(Object that) {
       if (that == null)
         return false;
-      if (that instanceof get_args)
-        return this.equals((get_args)that);
+      if (that instanceof get_count_args)
+        return this.equals((get_count_args)that);
       return false;
     }
 
-    public boolean equals(get_args that) {
+    public boolean equals(get_count_args that) {
       if (that == null)
         return false;
 
@@ -2088,12 +4984,12 @@ public class Cassandra {
           return false;
       }
 
-      boolean this_present_column_path = true && this.isSetColumn_path();
-      boolean that_present_column_path = true && that.isSetColumn_path();
-      if (this_present_column_path || that_present_column_path) {
-        if (!(this_present_column_path && that_present_column_path))
+      boolean this_present_column_parent = true && this.isSetColumn_parent();
+      boolean that_present_column_parent = true && that.isSetColumn_parent();
+      if (this_present_column_parent || that_present_column_parent) {
+        if (!(this_present_column_parent && that_present_column_parent))
           return false;
-        if (!this.column_path.equals(that.column_path))
+        if (!this.column_parent.equals(that.column_parent))
           return false;
       }
 
@@ -2114,13 +5010,13 @@ public class Cassandra {
       return 0;
     }
 
-    public int compareTo(get_args other) {
+    public int compareTo(get_count_args other) {
       if (!getClass().equals(other.getClass())) {
         return getClass().getName().compareTo(other.getClass().getName());
       }
 
       int lastComparison = 0;
-      get_args typedOther = (get_args)other;
+      get_count_args typedOther = (get_count_args)other;
 
       lastComparison = Boolean.valueOf(isSetKeyspace()).compareTo(isSetKeyspace());
       if (lastComparison != 0) {
@@ -2138,11 +5034,11 @@ public class Cassandra {
       if (lastComparison != 0) {
         return lastComparison;
       }
-      lastComparison = Boolean.valueOf(isSetColumn_path()).compareTo(isSetColumn_path());
+      lastComparison = Boolean.valueOf(isSetColumn_parent()).compareTo(isSetColumn_parent());
       if (lastComparison != 0) {
         return lastComparison;
       }
-      lastComparison = TBaseHelper.compareTo(column_path, typedOther.column_path);
+      lastComparison = TBaseHelper.compareTo(column_parent, typedOther.column_parent);
       if (lastComparison != 0) {
         return lastComparison;
       }
@@ -2182,10 +5078,10 @@ public class Cassandra {
               TProtocolUtil.skip(iprot, field.type);
             }
             break;
-          case COLUMN_PATH:
+          case COLUMN_PARENT:
             if (field.type == TType.STRUCT) {
-              this.column_path = new ColumnPath();
-              this.column_path.read(iprot);
+              this.column_parent = new ColumnParent();
+              this.column_parent.read(iprot);
             } else { 
               TProtocolUtil.skip(iprot, field.type);
             }
@@ -2228,9 +5124,9 @@ public class Cassandra {
         oprot.writeString(this.key);
         oprot.writeFieldEnd();
       }
-      if (this.column_path != null) {
-        oprot.writeFieldBegin(COLUMN_PATH_FIELD_DESC);
-        this.column_path.write(oprot);
+      if (this.column_parent != null) {
+        oprot.writeFieldBegin(COLUMN_PARENT_FIELD_DESC);
+        this.column_parent.write(oprot);
         oprot.writeFieldEnd();
       }
       oprot.writeFieldBegin(CONSISTENCY_LEVEL_FIELD_DESC);
@@ -2242,7 +5138,7 @@ public class Cassandra {
 
     @Override
     public String toString() {
-      StringBuilder sb = new StringBuilder("get_args(");
+      StringBuilder sb = new StringBuilder("get_count_args(");
       boolean first = true;
 
       sb.append("keyspace:");
@@ -2261,11 +5157,11 @@ public class Cassandra {
       }
       first = false;
       if (!first) sb.append(", ");
-      sb.append("column_path:");
-      if (this.column_path == null) {
+      sb.append("column_parent:");
+      if (this.column_parent == null) {
         sb.append("null");
       } else {
-        sb.append(this.column_path);
+        sb.append(this.column_parent);
       }
       first = false;
       if (!first) sb.append(", ");
@@ -2292,8 +5188,8 @@ public class Cassandra {
       if (key == null) {
         throw new TProtocolException("Required field 'key' was not present! Struct: " + toString());
       }
-      if (column_path == null) {
-        throw new TProtocolException("Required field 'column_path' was not present! Struct: " + toString());
+      if (column_parent == null) {
+        throw new TProtocolException("Required field 'column_parent' was not present! Struct: " + toString());
       }
       // 'consistency_level' is only checked in read() because it's a primitive and you chose the non-beans generator.
       // check that fields of type enum have valid values
@@ -2304,97 +5200,89 @@ public class Cassandra {
 
   }
 
-  public static class get_result implements TBase, java.io.Serializable, Cloneable, Comparable<get_result>   {
-    private static final TStruct STRUCT_DESC = new TStruct("get_result");
-    private static final TField SUCCESS_FIELD_DESC = new TField("success", TType.STRUCT, (short)0);
+  public static class get_count_result implements TBase, java.io.Serializable, Cloneable, Comparable<get_count_result>   {
+    private static final TStruct STRUCT_DESC = new TStruct("get_count_result");
+    private static final TField SUCCESS_FIELD_DESC = new TField("success", TType.I32, (short)0);
     private static final TField IRE_FIELD_DESC = new TField("ire", TType.STRUCT, (short)1);
-    private static final TField NFE_FIELD_DESC = new TField("nfe", TType.STRUCT, (short)2);
 
-    public ColumnOrSuperColumn success;
+    public int success;
     public static final int SUCCESS = 0;
     public InvalidRequestException ire;
     public static final int IRE = 1;
-    public NotFoundException nfe;
-    public static final int NFE = 2;
 
     // isset id assignments
+    private static final int __SUCCESS_ISSET_ID = 0;
+    private BitSet __isset_bit_vector = new BitSet(1);
 
     public static final Map<Integer, FieldMetaData> metaDataMap = Collections.unmodifiableMap(new HashMap<Integer, FieldMetaData>() {{
       put(SUCCESS, new FieldMetaData("success", TFieldRequirementType.DEFAULT, 
-          new StructMetaData(TType.STRUCT, ColumnOrSuperColumn.class)));
+          new FieldValueMetaData(TType.I32)));
       put(IRE, new FieldMetaData("ire", TFieldRequirementType.DEFAULT, 
           new FieldValueMetaData(TType.STRUCT)));
-      put(NFE, new FieldMetaData("nfe", TFieldRequirementType.DEFAULT, 
-          new FieldValueMetaData(TType.STRUCT)));
     }});
 
     static {
-      FieldMetaData.addStructMetaDataMap(get_result.class, metaDataMap);
+      FieldMetaData.addStructMetaDataMap(get_count_result.class, metaDataMap);
     }
 
-    public get_result() {
+    public get_count_result() {
     }
 
-    public get_result(
-      ColumnOrSuperColumn success,
-      InvalidRequestException ire,
-      NotFoundException nfe)
+    public get_count_result(
+      int success,
+      InvalidRequestException ire)
     {
       this();
       this.success = success;
+      setSuccessIsSet(true);
       this.ire = ire;
-      this.nfe = nfe;
     }
 
     /**
      * Performs a deep copy on <i>other</i>.
      */
-    public get_result(get_result other) {
-      if (other.isSetSuccess()) {
-        this.success = new ColumnOrSuperColumn(other.success);
-      }
+    public get_count_result(get_count_result other) {
+      __isset_bit_vector.clear();
+      __isset_bit_vector.or(other.__isset_bit_vector);
+      this.success = other.success;
       if (other.isSetIre()) {
         this.ire = new InvalidRequestException(other.ire);
       }
-      if (other.isSetNfe()) {
-        this.nfe = new NotFoundException(other.nfe);
-      }
     }
 
     @Override
-    public get_result clone() {
-      return new get_result(this);
+    public get_count_result clone() {
+      return new get_count_result(this);
     }
 
-    public ColumnOrSuperColumn getSuccess() {
+    public int getSuccess() {
       return this.success;
     }
 
-    public get_result setSuccess(ColumnOrSuperColumn success) {
+    public get_count_result setSuccess(int success) {
       this.success = success;
+      setSuccessIsSet(true);
       return this;
     }
 
     public void unsetSuccess() {
-      this.success = null;
+      __isset_bit_vector.clear(__SUCCESS_ISSET_ID);
     }
 
     // Returns true if field success is set (has been asigned a value) and false otherwise
     public boolean isSetSuccess() {
-      return this.success != null;
+      return __isset_bit_vector.get(__SUCCESS_ISSET_ID);
     }
 
     public void setSuccessIsSet(boolean value) {
-      if (!value) {
-        this.success = null;
-      }
+      __isset_bit_vector.set(__SUCCESS_ISSET_ID, value);
     }
 
     public InvalidRequestException getIre() {
       return this.ire;
     }
 
-    public get_result setIre(InvalidRequestException ire) {
+    public get_count_result setIre(InvalidRequestException ire) {
       this.ire = ire;
       return this;
     }
@@ -2414,37 +5302,13 @@ public class Cassandra {
       }
     }
 
-    public NotFoundException getNfe() {
-      return this.nfe;
-    }
-
-    public get_result setNfe(NotFoundException nfe) {
-      this.nfe = nfe;
-      return this;
-    }
-
-    public void unsetNfe() {
-      this.nfe = null;
-    }
-
-    // Returns true if field nfe is set (has been asigned a value) and false otherwise
-    public boolean isSetNfe() {
-      return this.nfe != null;
-    }
-
-    public void setNfeIsSet(boolean value) {
-      if (!value) {
-        this.nfe = null;
-      }
-    }
-
     public void setFieldValue(int fieldID, Object value) {
       switch (fieldID) {
       case SUCCESS:
         if (value == null) {
           unsetSuccess();
         } else {
-          setSuccess((ColumnOrSuperColumn)value);
+          setSuccess((Integer)value);
         }
         break;
 
@@ -2456,14 +5320,6 @@ public class Cassandra {
         }
         break;
 
-      case NFE:
-        if (value == null) {
-          unsetNfe();
-        } else {
-          setNfe((NotFoundException)value);
-        }
-        break;
-
       default:
         throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
       }
@@ -2472,14 +5328,11 @@ public class Cassandra {
     public Object getFieldValue(int fieldID) {
       switch (fieldID) {
       case SUCCESS:
-        return getSuccess();
+        return new Integer(getSuccess());
 
       case IRE:
         return getIre();
 
-      case NFE:
-        return getNfe();
-
       default:
         throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
       }
@@ -2492,8 +5345,6 @@ public class Cassandra {
         return isSetSuccess();
       case IRE:
         return isSetIre();
-      case NFE:
-        return isSetNfe();
       default:
         throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
       }
@@ -2503,39 +5354,30 @@ public class Cassandra {
     public boolean equals(Object that) {
       if (that == null)
         return false;
-      if (that instanceof get_result)
-        return this.equals((get_result)that);
+      if (that instanceof get_count_result)
+        return this.equals((get_count_result)that);
       return false;
     }
 
-    public boolean equals(get_result that) {
+    public boolean equals(get_count_result that) {
       if (that == null)
         return false;
 
-      boolean this_present_success = true && this.isSetSuccess();
-      boolean that_present_success = true && that.isSetSuccess();
+      boolean this_present_success = true;
+      boolean that_present_success = true;
       if (this_present_success || that_present_success) {
         if (!(this_present_success && that_present_success))
           return false;
-        if (!this.success.equals(that.success))
-          return false;
-      }
-
-      boolean this_present_ire = true && this.isSetIre();
-      boolean that_present_ire = true && that.isSetIre();
-      if (this_present_ire || that_present_ire) {
-        if (!(this_present_ire && that_present_ire))
-          return false;
-        if (!this.ire.equals(that.ire))
+        if (this.success != that.success)
           return false;
       }
-
-      boolean this_present_nfe = true && this.isSetNfe();
-      boolean that_present_nfe = true && that.isSetNfe();
-      if (this_present_nfe || that_present_nfe) {
-        if (!(this_present_nfe && that_present_nfe))
+
+      boolean this_present_ire = true && this.isSetIre();
+      boolean that_present_ire = true && that.isSetIre();
+      if (this_present_ire || that_present_ire) {
+        if (!(this_present_ire && that_present_ire))
           return false;
-        if (!this.nfe.equals(that.nfe))
+        if (!this.ire.equals(that.ire))
           return false;
       }
 
@@ -2547,13 +5389,13 @@ public class Cassandra {
       return 0;
     }
 
-    public int compareTo(get_result other) {
+    public int compareTo(get_count_result other) {
       if (!getClass().equals(other.getClass())) {
         return getClass().getName().compareTo(other.getClass().getName());
       }
 
       int lastComparison = 0;
-      get_result typedOther = (get_result)other;
+      get_count_result typedOther = (get_count_result)other;
 
       lastComparison = Boolean.valueOf(isSetSuccess()).compareTo(isSetSuccess());
       if (lastComparison != 0) {
@@ -2571,14 +5413,6 @@ public class Cassandra {
       if (lastComparison != 0) {
         return lastComparison;
       }
-      lastComparison = Boolean.valueOf(isSetNfe()).compareTo(isSetNfe());
-      if (lastComparison != 0) {
-        return lastComparison;
-      }
-      lastComparison = TBaseHelper.compareTo(nfe, typedOther.nfe);
-      if (lastComparison != 0) {
-        return lastComparison;
-      }
       return 0;
     }
 
@@ -2594,9 +5428,9 @@ public class Cassandra {
         switch (field.id)
         {
           case SUCCESS:
-            if (field.type == TType.STRUCT) {
-              this.success = new ColumnOrSuperColumn();
-              this.success.read(iprot);
+            if (field.type == TType.I32) {
+              this.success = iprot.readI32();
+              setSuccessIsSet(true);
             } else { 
               TProtocolUtil.skip(iprot, field.type);
             }
@@ -2609,14 +5443,6 @@ public class Cassandra {
               TProtocolUtil.skip(iprot, field.type);
             }
             break;
-          case NFE:
-            if (field.type == TType.STRUCT) {
-              this.nfe = new NotFoundException();
-              this.nfe.read(iprot);
-            } else { 
-              TProtocolUtil.skip(iprot, field.type);
-            }
-            break;
           default:
             TProtocolUtil.skip(iprot, field.type);
             break;
@@ -2627,6 +5453,9 @@ public class Cassandra {
 
 
       // check for required fields of primitive type, which can't be checked in the validate method
+      if (!isSetSuccess()) {
+        throw new TProtocolException("Required field 'success' was not found in serialized data! Struct: " + toString());
+      }
       validate();
     }
 
@@ -2635,16 +5464,12 @@ public class Cassandra {
 
       if (this.isSetSuccess()) {
         oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
-        this.success.write(oprot);
+        oprot.writeI32(this.success);
         oprot.writeFieldEnd();
       } else if (this.isSetIre()) {
         oprot.writeFieldBegin(IRE_FIELD_DESC);
         this.ire.write(oprot);
         oprot.writeFieldEnd();
-      } else if (this.isSetNfe()) {
-        oprot.writeFieldBegin(NFE_FIELD_DESC);
-        this.nfe.write(oprot);
-        oprot.writeFieldEnd();
       }
       oprot.writeFieldStop();
       oprot.writeStructEnd();
@@ -2652,15 +5477,11 @@ public class Cassandra {
 
     @Override
     public String toString() {
-      StringBuilder sb = new StringBuilder("get_result(");
+      StringBuilder sb = new StringBuilder("get_count_result(");
       boolean first = true;
 
       sb.append("success:");
-      if (this.success == null) {
-        sb.append("null");
-      } else {
-        sb.append(this.success);
-      }
+      sb.append(this.success);
       first = false;
       if (!first) sb.append(", ");
       sb.append("ire:");
@@ -2670,45 +5491,32 @@ public class Cassandra {
         sb.append(this.ire);
       }
       first = false;
-      if (!first) sb.append(", ");
-      sb.append("nfe:");
-      if (this.nfe == null) {
-        sb.append("null");
-      } else {
-        sb.append(this.nfe);
-      }
-      first = false;
       sb.append(")");
       return sb.toString();
     }
 
     public void validate() throws TException {
       // check for required fields
-      if (success == null) {
-        throw new TProtocolException("Required field 'success' was not present! Struct: " + toString());
-      }
+      // 'success' is only checked in read() because it's a primitive and you chose the non-beans generator.
       if (ire == null) {
         throw new TProtocolException("Required field 'ire' was not present! Struct: " + toString());
       }
-      if (nfe == null) {
-        throw new TProtocolException("Required field 'nfe' was not present! Struct: " + toString());
-      }
       // check that fields of type enum have valid values
     }
 
   }
 
-  public static class get_count_args implements TBase, java.io.Serializable, Cloneable, Comparable<get_count_args>   {
-    private static final TStruct STRUCT_DESC = new TStruct("get_count_args");
+  public static class multiget_count_args implements TBase, java.io.Serializable, Cloneable, Comparable<multiget_count_args>   {
+    private static final TStruct STRUCT_DESC = new TStruct("multiget_count_args");
     private static final TField KEYSPACE_FIELD_DESC = new TField("keyspace", TType.STRING, (short)1);
-    private static final TField KEY_FIELD_DESC = new TField("key", TType.STRING, (short)2);
+    private static final TField KEYS_FIELD_DESC = new TField("keys", TType.LIST, (short)2);
     private static final TField COLUMN_PARENT_FIELD_DESC = new TField("column_parent", TType.STRUCT, (short)3);
     private static final TField CONSISTENCY_LEVEL_FIELD_DESC = new TField("consistency_level", TType.I32, (short)5);
 
     public String keyspace;
     public static final int KEYSPACE = 1;
-    public String key;
-    public static final int KEY = 2;
+    public List<String> keys;
+    public static final int KEYS = 2;
     public ColumnParent column_parent;
     public static final int COLUMN_PARENT = 3;
     /**
@@ -2725,8 +5533,9 @@ public class Cassandra {
     public static final Map<Integer, FieldMetaData> metaDataMap = Collections.unmodifiableMap(new HashMap<Integer, FieldMetaData>() {{
       put(KEYSPACE, new FieldMetaData("keyspace", TFieldRequirementType.DEFAULT, 
           new FieldValueMetaData(TType.STRING)));
-      put(KEY, new FieldMetaData("key", TFieldRequirementType.DEFAULT, 
-          new FieldValueMetaData(TType.STRING)));
+      put(KEYS, new FieldMetaData("keys", TFieldRequirementType.DEFAULT, 
+          new ListMetaData(TType.LIST, 
+              new FieldValueMetaData(TType.STRING))));
       put(COLUMN_PARENT, new FieldMetaData("column_parent", TFieldRequirementType.DEFAULT, 
           new StructMetaData(TType.STRUCT, ColumnParent.class)));
       put(CONSISTENCY_LEVEL, new FieldMetaData("consistency_level", TFieldRequirementType.DEFAULT, 
@@ -2734,23 +5543,23 @@ public class Cassandra {
     }});
 
     static {
-      FieldMetaData.addStructMetaDataMap(get_count_args.class, metaDataMap);
+      FieldMetaData.addStructMetaDataMap(multiget_count_args.class, metaDataMap);
     }
 
-    public get_count_args() {
+    public multiget_count_args() {
       this.consistency_level = 1;
 
     }
 
-    public get_count_args(
+    public multiget_count_args(
       String keyspace,
-      String key,
+      List<String> keys,
       ColumnParent column_parent,
       int consistency_level)
     {
       this();
       this.keyspace = keyspace;
-      this.key = key;
+      this.keys = keys;
       this.column_parent = column_parent;
       this.consistency_level = consistency_level;
       setConsistency_levelIsSet(true);
@@ -2759,14 +5568,18 @@ public class Cassandra {
     /**
      * Performs a deep copy on <i>other</i>.
      */
-    public get_count_args(get_count_args other) {
+    public multiget_count_args(multiget_count_args other) {
       __isset_bit_vector.clear();
       __isset_bit_vector.or(other.__isset_bit_vector);
       if (other.isSetKeyspace()) {
         this.keyspace = other.keyspace;
       }
-      if (other.isSetKey()) {
-        this.key = other.key;
+      if (other.isSetKeys()) {
+        List<String> __this__keys = new ArrayList<String>();
+        for (String other_element : other.keys) {
+          __this__keys.add(other_element);
+        }
+        this.keys = __this__keys;
       }
       if (other.isSetColumn_parent()) {
         this.column_parent = new ColumnParent(other.column_parent);
@@ -2775,15 +5588,15 @@ public class Cassandra {
     }
 
     @Override
-    public get_count_args clone() {
-      return new get_count_args(this);
+    public multiget_count_args clone() {
+      return new multiget_count_args(this);
     }
 
     public String getKeyspace() {
       return this.keyspace;
     }
 
-    public get_count_args setKeyspace(String keyspace) {
+    public multiget_count_args setKeyspace(String keyspace) {
       this.keyspace = keyspace;
       return this;
     }
@@ -2803,27 +5616,27 @@ public class Cassandra {
       }
     }
 
-    public String getKey() {
-      return this.key;
+    public List<String> getKeys() {
+      return this.keys;
     }
 
-    public get_count_args setKey(String key) {
-      this.key = key;
+    public multiget_count_args setKeys(List<String> keys) {
+      this.keys = keys;
       return this;
     }
 
-    public void unsetKey() {
-      this.key = null;
+    public void unsetKeys() {
+      this.keys = null;
     }
 
-    // Returns true if field key is set (has been asigned a value) and false otherwise
-    public boolean isSetKey() {
-      return this.key != null;
+    // Returns true if field keys is set (has been asigned a value) and false otherwise
+    public boolean isSetKeys() {
+      return this.keys != null;
     }
 
-    public void setKeyIsSet(boolean value) {
+    public void setKeysIsSet(boolean value) {
       if (!value) {
-        this.key = null;
+        this.keys = null;
       }
     }
 
@@ -2831,7 +5644,7 @@ public class Cassandra {
       return this.column_parent;
     }
 
-    public get_count_args setColumn_parent(ColumnParent column_parent) {
+    public multiget_count_args setColumn_parent(ColumnParent column_parent) {
       this.column_parent = column_parent;
       return this;
     }
@@ -2863,7 +5676,7 @@ public class Cassandra {
      * 
      * @see ConsistencyLevel
      */
-    public get_count_args setConsistency_level(int consistency_level) {
+    public multiget_count_args setConsistency_level(int consistency_level) {
       this.consistency_level = consistency_level;
       setConsistency_levelIsSet(true);
       return this;
@@ -2892,11 +5705,11 @@ public class Cassandra {
         }
         break;
 
-      case KEY:
+      case KEYS:
         if (value == null) {
-          unsetKey();
+          unsetKeys();
         } else {
-          setKey((String)value);
+          setKeys((List<String>)value);
         }
         break;
 
@@ -2926,8 +5739,8 @@ public class Cassandra {
       case KEYSPACE:
         return getKeyspace();
 
-      case KEY:
-        return getKey();
+      case KEYS:
+        return getKeys();
 
       case COLUMN_PARENT:
         return getColumn_parent();
@@ -2945,8 +5758,8 @@ public class Cassandra {
       switch (fieldID) {
       case KEYSPACE:
         return isSetKeyspace();
-      case KEY:
-        return isSetKey();
+      case KEYS:
+        return isSetKeys();
       case COLUMN_PARENT:
         return isSetColumn_parent();
       case CONSISTENCY_LEVEL:
@@ -2960,12 +5773,12 @@ public class Cassandra {
     public boolean equals(Object that) {
       if (that == null)
         return false;
-      if (that instanceof get_count_args)
-        return this.equals((get_count_args)that);
+      if (that instanceof multiget_count_args)
+        return this.equals((multiget_count_args)that);
       return false;
     }
 
-    public boolean equals(get_count_args that) {
+    public boolean equals(multiget_count_args that) {
       if (that == null)
         return false;
 
@@ -2978,12 +5791,12 @@ public class Cassandra {
           return false;
       }
 
-      boolean this_present_key = true && this.isSetKey();
-      boolean that_present_key = true && that.isSetKey();
-      if (this_present_key || that_present_key) {
-        if (!(this_present_key && that_present_key))
+      boolean this_present_keys = true && this.isSetKeys();
+      boolean that_present_keys = true && that.isSetKeys();
+      if (this_present_keys || that_present_keys) {
+        if (!(this_present_keys && that_present_keys))
           return false;
-        if (!this.key.equals(that.key))
+        if (!this.keys.equals(that.keys))
           return false;
       }
 
@@ -3013,13 +5826,13 @@ public class Cassandra {
       return 0;
     }
 
-    public int compareTo(get_count_args other) {
+    public int compareTo(multiget_count_args other) {
       if (!getClass().equals(other.getClass())) {
         return getClass().getName().compareTo(other.getClass().getName());
       }
 
       int lastComparison = 0;
-      get_count_args typedOther = (get_count_args)other;
+      multiget_count_args typedOther = (multiget_count_args)other;
 
       lastComparison = Boolean.valueOf(isSetKeyspace()).compareTo(isSetKeyspace());
       if (lastComparison != 0) {
@@ -3029,11 +5842,11 @@ public class Cassandra {
       if (lastComparison != 0) {
         return lastComparison;
       }
-      lastComparison = Boolean.valueOf(isSetKey()).compareTo(isSetKey());
+      lastComparison = Boolean.valueOf(isSetKeys()).compareTo(isSetKeys());
       if (lastComparison != 0) {
         return lastComparison;
       }
-      lastComparison = TBaseHelper.compareTo(key, typedOther.key);
+      lastComparison = TBaseHelper.compareTo(keys, typedOther.keys);
       if (lastComparison != 0) {
         return lastComparison;
       }
@@ -3074,9 +5887,19 @@ public class Cassandra {
               TProtocolUtil.skip(iprot, field.type);
             }
             break;
-          case KEY:
-            if (field.type == TType.STRING) {
-              this.key = iprot.readString();
+          case KEYS:
+            if (field.type == TType.LIST) {
+              {
+                TList _list43 = iprot.readListBegin();
+                this.keys = new ArrayList<String>(_list43.size);
+                for (int _i44 = 0; _i44 < _list43.size; ++_i44)
+                {
+                  String _elem45;
+                  _elem45 = iprot.readString();
+                  this.keys.add(_elem45);
+                }
+                iprot.readListEnd();
+              }
             } else { 
               TProtocolUtil.skip(iprot, field.type);
             }
@@ -3122,9 +5945,15 @@ public class Cassandra {
         oprot.writeString(this.keyspace);
         oprot.writeFieldEnd();
       }
-      if (this.key != null) {
-        oprot.writeFieldBegin(KEY_FIELD_DESC);
-        oprot.writeString(this.key);
+      if (this.keys != null) {
+        oprot.writeFieldBegin(KEYS_FIELD_DESC);
+        {
+          oprot.writeListBegin(new TList(TType.STRING, this.keys.size()));
+          for (String _iter46 : this.keys)          {
+            oprot.writeString(_iter46);
+          }
+          oprot.writeListEnd();
+        }
         oprot.writeFieldEnd();
       }
       if (this.column_parent != null) {
@@ -3141,7 +5970,7 @@ public class Cassandra {
 
     @Override
     public String toString() {
-      StringBuilder sb = new StringBuilder("get_count_args(");
+      StringBuilder sb = new StringBuilder("multiget_count_args(");
       boolean first = true;
 
       sb.append("keyspace:");
@@ -3152,11 +5981,11 @@ public class Cassandra {
       }
       first = false;
       if (!first) sb.append(", ");
-      sb.append("key:");
-      if (this.key == null) {
+      sb.append("keys:");
+      if (this.keys == null) {
         sb.append("null");
       } else {
-        sb.append(this.key);
+        sb.append(this.keys);
       }
       first = false;
       if (!first) sb.append(", ");
@@ -3188,8 +6017,8 @@ public class Cassandra {
       if (keyspace == null) {
         throw new TProtocolException("Required field 'keyspace' was not present! Struct: " + toString());
       }
-      if (key == null) {
-        throw new TProtocolException("Required field 'key' was not present! Struct: " + toString());
+      if (keys == null) {
+        throw new TProtocolException("Required field 'keys' was not present! Struct: " + toString());
       }
       if (column_parent == null) {
         throw new TProtocolException("Required field 'column_parent' was not present! Struct: " + toString());
@@ -3203,89 +6032,101 @@ public class Cassandra {
 
   }
 
-  public static class get_count_result implements TBase, java.io.Serializable, Cloneable, Comparable<get_count_result>   {
-    private static final TStruct STRUCT_DESC = new TStruct("get_count_result");
-    private static final TField SUCCESS_FIELD_DESC = new TField("success", TType.I32, (short)0);
+  public static class multiget_count_result implements TBase, java.io.Serializable, Cloneable   {
+    private static final TStruct STRUCT_DESC = new TStruct("multiget_count_result");
+    private static final TField SUCCESS_FIELD_DESC = new TField("success", TType.MAP, (short)0);
     private static final TField IRE_FIELD_DESC = new TField("ire", TType.STRUCT, (short)1);
 
-    public int success;
+    public Map<String,Integer> success;
     public static final int SUCCESS = 0;
     public InvalidRequestException ire;
     public static final int IRE = 1;
 
     // isset id assignments
-    private static final int __SUCCESS_ISSET_ID = 0;
-    private BitSet __isset_bit_vector = new BitSet(1);
 
     public static final Map<Integer, FieldMetaData> metaDataMap = Collections.unmodifiableMap(new HashMap<Integer, FieldMetaData>() {{
       put(SUCCESS, new FieldMetaData("success", TFieldRequirementType.DEFAULT, 
-          new FieldValueMetaData(TType.I32)));
+          new MapMetaData(TType.MAP, 
+              new FieldValueMetaData(TType.STRING), 
+              new FieldValueMetaData(TType.I32))));
       put(IRE, new FieldMetaData("ire", TFieldRequirementType.DEFAULT, 
           new FieldValueMetaData(TType.STRUCT)));
     }});
 
     static {
-      FieldMetaData.addStructMetaDataMap(get_count_result.class, metaDataMap);
+      FieldMetaData.addStructMetaDataMap(multiget_count_result.class, metaDataMap);
     }
 
-    public get_count_result() {
+    public multiget_count_result() {
     }
 
-    public get_count_result(
-      int success,
+    public multiget_count_result(
+      Map<String,Integer> success,
       InvalidRequestException ire)
     {
       this();
       this.success = success;
-      setSuccessIsSet(true);
       this.ire = ire;
     }
 
     /**
      * Performs a deep copy on <i>other</i>.
      */
-    public get_count_result(get_count_result other) {
-      __isset_bit_vector.clear();
-      __isset_bit_vector.or(other.__isset_bit_vector);
-      this.success = other.success;
+    public multiget_count_result(multiget_count_result other) {
+      if (other.isSetSuccess()) {
+        Map<String,Integer> __this__success = new HashMap<String,Integer>();
+        for (Map.Entry<String, Integer> other_element : other.success.entrySet()) {
+
+          String other_element_key = other_element.getKey();
+          Integer other_element_value = other_element.getValue();
+
+          String __this__success_copy_key = other_element_key;
+
+          Integer __this__success_copy_value = other_element_value;
+
+          __this__success.put(__this__success_copy_key, __this__success_copy_value);
+        }
+        this.success = __this__success;
+      }
       if (other.isSetIre()) {
         this.ire = new InvalidRequestException(other.ire);
       }
     }
 
     @Override
-    public get_count_result clone() {
-      return new get_count_result(this);
+    public multiget_count_result clone() {
+      return new multiget_count_result(this);
     }
 
-    public int getSuccess() {
+    public Map<String,Integer> getSuccess() {
       return this.success;
     }
 
-    public get_count_result setSuccess(int success) {
+    public multiget_count_result setSuccess(Map<String,Integer> success) {
       this.success = success;
-      setSuccessIsSet(true);
       return this;
     }
 
     public void unsetSuccess() {
-      __isset_bit_vector.clear(__SUCCESS_ISSET_ID);
+      this.success = null;
     }
 
     // Returns true if field success is set (has been asigned a value) and false otherwise
     public boolean isSetSuccess() {
-      return __isset_bit_vector.get(__SUCCESS_ISSET_ID);
+      return this.success != null;
     }
 
     public void setSuccessIsSet(boolean value) {
-      __isset_bit_vector.set(__SUCCESS_ISSET_ID, value);
+      if (!value) {
+        this.success = null;
+      }
     }
 
     public InvalidRequestException getIre() {
       return this.ire;
     }
 
-    public get_count_result setIre(InvalidRequestException ire) {
+    public multiget_count_result setIre(InvalidRequestException ire) {
       this.ire = ire;
       return this;
     }
@@ -3311,7 +6152,7 @@ public class Cassandra {
         if (value == null) {
           unsetSuccess();
         } else {
-          setSuccess((Integer)value);
+          setSuccess((Map<String,Integer>)value);
         }
         break;
 
@@ -3331,7 +6172,7 @@ public class Cassandra {
     public Object getFieldValue(int fieldID) {
       switch (fieldID) {
       case SUCCESS:
-        return new Integer(getSuccess());
+        return getSuccess();
 
       case IRE:
         return getIre();
@@ -3357,21 +6198,21 @@ public class Cassandra {
     public boolean equals(Object that) {
       if (that == null)
         return false;
-      if (that instanceof get_count_result)
-        return this.equals((get_count_result)that);
+      if (that instanceof multiget_count_result)
+        return this.equals((multiget_count_result)that);
       return false;
     }
 
-    public boolean equals(get_count_result that) {
+    public boolean equals(multiget_count_result that) {
       if (that == null)
         return false;
 
-      boolean this_present_success = true;
-      boolean that_present_success = true;
+      boolean this_present_success = true && this.isSetSuccess();
+      boolean that_present_success = true && that.isSetSuccess();
       if (this_present_success || that_present_success) {
         if (!(this_present_success && that_present_success))
           return false;
-        if (this.success != that.success)
+        if (!this.success.equals(that.success))
           return false;
       }
 
@@ -3392,33 +6233,6 @@ public class Cassandra {
       return 0;
     }
 
-    public int compareTo(get_count_result other) {
-      if (!getClass().equals(other.getClass())) {
-        return getClass().getName().compareTo(other.getClass().getName());
-      }
-
-      int lastComparison = 0;
-      get_count_result typedOther = (get_count_result)other;
-
-      lastComparison = Boolean.valueOf(isSetSuccess()).compareTo(isSetSuccess());
-      if (lastComparison != 0) {
-        return lastComparison;
-      }
-      lastComparison = TBaseHelper.compareTo(success, typedOther.success);
-      if (lastComparison != 0) {
-        return lastComparison;
-      }
-      lastComparison = Boolean.valueOf(isSetIre()).compareTo(isSetIre());
-      if (lastComparison != 0) {
-        return lastComparison;
-      }
-      lastComparison = TBaseHelper.compareTo(ire, typedOther.ire);
-      if (lastComparison != 0) {
-        return lastComparison;
-      }
-      return 0;
-    }
-
     public void read(TProtocol iprot) throws TException {
       TField field;
       iprot.readStructBegin();
@@ -3431,9 +6245,20 @@ public class Cassandra {
         switch (field.id)
         {
           case SUCCESS:
-            if (field.type == TType.I32) {
-              this.success = iprot.readI32();
-              setSuccessIsSet(true);
+            if (field.type == TType.MAP) {
+              {
+                TMap _map47 = iprot.readMapBegin();
+                this.success = new HashMap<String,Integer>(2*_map47.size);
+                for (int _i48 = 0; _i48 < _map47.size; ++_i48)
+                {
+                  String _key49;
+                  int _val50;
+                  _key49 = iprot.readString();
+                  _val50 = iprot.readI32();
+                  this.success.put(_key49, _val50);
+                }
+                iprot.readMapEnd();
+              }
             } else { 
               TProtocolUtil.skip(iprot, field.type);
             }
@@ -3456,9 +6281,6 @@ public class Cassandra {
 
 
       // check for required fields of primitive type, which can't be checked in the validate method
-      if (!isSetSuccess()) {
-        throw new TProtocolException("Required field 'success' was not found in serialized data! Struct: " + toString());
-      }
       validate();
     }
 
@@ -3467,7 +6289,14 @@ public class Cassandra {
 
       if (this.isSetSuccess()) {
         oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
-        oprot.writeI32(this.success);
+        {
+          oprot.writeMapBegin(new TMap(TType.STRING, TType.I32, this.success.size()));
+          for (Map.Entry<String, Integer> _iter51 : this.success.entrySet())          {
+            oprot.writeString(_iter51.getKey());
+            oprot.writeI32(_iter51.getValue());
+          }
+          oprot.writeMapEnd();
+        }
         oprot.writeFieldEnd();
       } else if (this.isSetIre()) {
         oprot.writeFieldBegin(IRE_FIELD_DESC);
@@ -3480,11 +6309,15 @@ public class Cassandra {
 
     @Override
     public String toString() {
-      StringBuilder sb = new StringBuilder("get_count_result(");
+      StringBuilder sb = new StringBuilder("multiget_count_result(");
       boolean first = true;
 
       sb.append("success:");
-      sb.append(this.success);
+      if (this.success == null) {
+        sb.append("null");
+      } else {
+        sb.append(this.success);
+      }
       first = false;
       if (!first) sb.append(", ");
       sb.append("ire:");
@@ -3500,7 +6333,9 @@ public class Cassandra {
 
     public void validate() throws TException {
       // check for required fields
-      // 'success' is only checked in read() because it's a primitive and you chose the non-beans generator.
+      if (success == null) {
+        throw new TProtocolException("Required field 'success' was not present! Struct: " + toString());
+      }
       if (ire == null) {
         throw new TProtocolException("Required field 'ire' was not present! Struct: " + toString());
       }
@@ -6885,13 +9720,13 @@ public class Cassandra {
           case SUCCESS:
             if (field.type == TType.LIST) {
               {
-                TList _list21 = iprot.readListBegin();
-                this.success = new ArrayList<String>(_list21.size);
-                for (int _i22 = 0; _i22 < _list21.size; ++_i22)
+                TList _list52 = iprot.readListBegin();
+                this.success = new ArrayList<String>(_list52.size);
+                for (int _i53 = 0; _i53 < _list52.size; ++_i53)
                 {
-                  String _elem23;
-                  _elem23 = iprot.readString();
-                  this.success.add(_elem23);
+                  String _elem54;
+                  _elem54 = iprot.readString();
+                  this.success.add(_elem54);
                 }
                 iprot.readListEnd();
               }
@@ -6927,8 +9762,8 @@ public class Cassandra {
         oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
         {
           oprot.writeListBegin(new TList(TType.STRING, this.success.size()));
-          for (String _iter24 : this.success)          {
-            oprot.writeString(_iter24);
+          for (String _iter55 : this.success)          {
+            oprot.writeString(_iter55);
           }
           oprot.writeListEnd();
         }
@@ -7807,13 +10642,13 @@ public class Cassandra {
           case SUCCESS:
             if (field.type == TType.LIST) {
               {
-                TList _list25 = iprot.readListBegin();
-                this.success = new ArrayList<String>(_list25.size);
-                for (int _i26 = 0; _i26 < _list25.size; ++_i26)
+                TList _list56 = iprot.readListBegin();
+                this.success = new ArrayList<String>(_list56.size);
+                for (int _i57 = 0; _i57 < _list56.size; ++_i57)
                 {
-                  String _elem27;
-                  _elem27 = iprot.readString();
-                  this.success.add(_elem27);
+                  String _elem58;
+                  _elem58 = iprot.readString();
+                  this.success.add(_elem58);
                 }
                 iprot.readListEnd();
               }
@@ -7841,8 +10676,8 @@ public class Cassandra {
         oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
         {
           oprot.writeListBegin(new TList(TType.STRING, this.success.size()));
-          for (String _iter28 : this.success)          {
-            oprot.writeString(_iter28);
+          for (String _iter59 : this.success)          {
+            oprot.writeString(_iter59);
           }
           oprot.writeListEnd();
         }
@@ -8326,27 +11161,27 @@ public class Cassandra {
           case SUCCESS:
             if (field.type == TType.MAP) {
               {
-                TMap _map29 = iprot.readMapBegin();
-                this.success = new HashMap<String,Map<String,String>>(2*_map29.size);
-                for (int _i30 = 0; _i30 < _map29.size; ++_i30)
+                TMap _map60 = iprot.readMapBegin();
+                this.success = new HashMap<String,Map<String,String>>(2*_map60.size);
+                for (int _i61 = 0; _i61 < _map60.size; ++_i61)
                 {
-                  String _key31;
-                  Map<String,String> _val32;
-                  _key31 = iprot.readString();
+                  String _key62;
+                  Map<String,String> _val63;
+                  _key62 = iprot.readString();
                   {
-                    TMap _map33 = iprot.readMapBegin();
-                    _val32 = new HashMap<String,String>(2*_map33.size);
-                    for (int _i34 = 0; _i34 < _map33.size; ++_i34)
+                    TMap _map64 = iprot.readMapBegin();
+                    _val63 = new HashMap<String,String>(2*_map64.size);
+                    for (int _i65 = 0; _i65 < _map64.size; ++_i65)
                     {
-                      String _key35;
-                      String _val36;
-                      _key35 = iprot.readString();
-                      _val36 = iprot.readString();
-                      _val32.put(_key35, _val36);
+                      String _key66;
+                      String _val67;
+                      _key66 = iprot.readString();
+                      _val67 = iprot.readString();
+                      _val63.put(_key66, _val67);
                     }
                     iprot.readMapEnd();
                   }
-                  this.success.put(_key31, _val32);
+                  this.success.put(_key62, _val63);
                 }
                 iprot.readMapEnd();
               }
@@ -8382,13 +11217,13 @@ public class Cassandra {
         oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
         {
           oprot.writeMapBegin(new TMap(TType.STRING, TType.MAP, this.success.size()));
-          for (Map.Entry<String, Map<String,String>> _iter37 : this.success.entrySet())          {
-            oprot.writeString(_iter37.getKey());
+          for (Map.Entry<String, Map<String,String>> _iter68 : this.success.entrySet())          {
+            oprot.writeString(_iter68.getKey());
             {
-              oprot.writeMapBegin(new TMap(TType.STRING, TType.STRING, _iter37.getValue().size()));
-              for (Map.Entry<String, String> _iter38 : _iter37.getValue().entrySet())              {
-                oprot.writeString(_iter38.getKey());
-                oprot.writeString(_iter38.getValue());
+              oprot.writeMapBegin(new TMap(TType.STRING, TType.STRING, _iter68.getValue().size()));
+              for (Map.Entry<String, String> _iter69 : _iter68.getValue().entrySet())              {
+                oprot.writeString(_iter69.getKey());
+                oprot.writeString(_iter69.getValue());
               }
               oprot.writeMapEnd();
             }
diff --git a/src/java/org/apache/cassandra/net/AsyncResult.java b/src/java/org/apache/cassandra/net/AsyncResult.java
index b65d2fe..14d9a0b 100644
--- a/src/java/org/apache/cassandra/net/AsyncResult.java
+++ b/src/java/org/apache/cassandra/net/AsyncResult.java
@@ -36,10 +36,12 @@ class AsyncResult implements IAsyncResult
     private AtomicBoolean done_ = new AtomicBoolean(false);
     private Lock lock_ = new ReentrantLock();
     private Condition condition_;
+    private long startTime_;
 
     public AsyncResult()
     {        
         condition_ = lock_.newCondition();
+        startTime_ = System.currentTimeMillis();
     }    
     
     public byte[] get()
@@ -77,8 +79,12 @@ class AsyncResult implements IAsyncResult
             try
             {
                 if ( !done_.get() )
-                {                    
-                    bVal = condition_.await(timeout, tu);
+                {
+                    long overall_timeout = System.currentTimeMillis() - startTime_ + timeout;
+                    if(overall_timeout > 0)
+                        bVal = condition_.await(overall_timeout, TimeUnit.MILLISECONDS);
+                    else
+                        bVal = false;
                 }
             }
             catch ( InterruptedException ex )
@@ -97,17 +103,7 @@ class AsyncResult implements IAsyncResult
         }
         return result_;
     }
-    
-    public List<byte[]> multiget()
-    {
-        throw new UnsupportedOperationException("This operation is not supported in the AsyncResult abstraction.");
-    }
-    
-    public List<byte[]> multiget(long timeout, TimeUnit tu) throws TimeoutException
-    {
-        throw new UnsupportedOperationException("This operation is not supported in the AsyncResult abstraction.");
-    }
-    
+      
     public void result(Message response)
     {        
         try
diff --git a/src/java/org/apache/cassandra/net/IAsyncResult.java b/src/java/org/apache/cassandra/net/IAsyncResult.java
index a745aa7..39f1b21 100644
--- a/src/java/org/apache/cassandra/net/IAsyncResult.java
+++ b/src/java/org/apache/cassandra/net/IAsyncResult.java
@@ -45,22 +45,7 @@ public interface IAsyncResult
      * @return the result wrapped in an Object[]
     */
     public byte[] get(long timeout, TimeUnit tu) throws TimeoutException;
-    
-    /**
-     * Returns the result for all tasks that was submitted.
-     * @return the list of results wrapped in an Object[]
-    */
-    public List<byte[]> multiget();
-    
-    /**
-     * Same operation as the above get() but allows the calling
-     * thread to specify a timeout.
-     * @param timeout the maximum time to wait
-     * @param tu the time unit of the timeout argument
-     * @return the result wrapped in an Object[]
-    */
-    public List<byte[]> multiget(long timeout, TimeUnit tu) throws TimeoutException;
-    
+        
     /**
      * Store the result obtained for the submitted task.
      * @param result the response message
diff --git a/src/java/org/apache/cassandra/net/IMessagingService.java b/src/java/org/apache/cassandra/net/IMessagingService.java
index fd3bb81..758966c 100644
--- a/src/java/org/apache/cassandra/net/IMessagingService.java
+++ b/src/java/org/apache/cassandra/net/IMessagingService.java
@@ -119,19 +119,6 @@ public interface IMessagingService
      * array is sent to the ith element in the <code>to</code> array.This method assumes
      * there is a one-one mapping between the <code>messages</code> array and
      * the <code>to</code> array. Otherwise an  IllegalArgumentException will be thrown.
-     * This method also informs the MessagingService to wait for at least
-     * <code>howManyResults</code> responses to determine success of failure.
-     * @param messages messages to be sent.
-     * @param to endpoints to which the message needs to be sent
-     * @return an reference to IAsyncResult
-     */
-    public IAsyncResult sendRR(Message[] messages, EndPoint[] to);
-    
-    /**
-     * Send a message to a given endpoint. The ith element in the <code>messages</code>
-     * array is sent to the ith element in the <code>to</code> array.This method assumes
-     * there is a one-one mapping between the <code>messages</code> array and
-     * the <code>to</code> array. Otherwise an  IllegalArgumentException will be thrown.
      * The idea is that multi-groups of messages are grouped as one logical message
      * whose results are harnessed via the <i>IAsyncResult</i>
      * @param messages groups of grouped messages.
diff --git a/src/java/org/apache/cassandra/net/MessagingService.java b/src/java/org/apache/cassandra/net/MessagingService.java
index e719417..954324b 100644
--- a/src/java/org/apache/cassandra/net/MessagingService.java
+++ b/src/java/org/apache/cassandra/net/MessagingService.java
@@ -379,25 +379,6 @@ public class MessagingService implements IMessagingService
         return groupId;
     } 
     
-    public IAsyncResult sendRR(Message[] messages, EndPoint[] to)
-    {
-        if ( messages.length != to.length )
-        {
-            throw new IllegalArgumentException("Number of messages and the number of endpoints need to be same.");
-        }
-        
-        IAsyncResult iar = new MultiAsyncResult(messages.length);
-        String groupId = GuidGenerator.guid();
-        taskCompletionMap_.put(groupId, iar);
-        for ( int i = 0; i < messages.length; ++i )
-        {
-            messages[i].setMessageId(groupId);
-            sendOneWay(messages[i], to[i]);
-        }
-        
-        return iar;
-    }
-    
     public String sendRR(Message[][] messages, EndPoint[][] to, IAsyncCallback cb)
     {
         if ( messages.length != to.length )
diff --git a/src/java/org/apache/cassandra/net/MultiAsyncResult.java b/src/java/org/apache/cassandra/net/MultiAsyncResult.java
deleted file mode 100644
index 62ab747..0000000
--- a/src/java/org/apache/cassandra/net/MultiAsyncResult.java
+++ /dev/null
@@ -1,133 +0,0 @@
-/**
- * Licensed to the Apache Software Foundation (ASF) under one
- * or more contributor license agreements.  See the NOTICE file
- * distributed with this work for additional information
- * regarding copyright ownership.  The ASF licenses this file
- * to you under the Apache License, Version 2.0 (the
- * "License"); you may not use this file except in compliance
- * with the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.cassandra.net;
-
-import java.util.ArrayList;
-import java.util.List;
-import java.util.concurrent.TimeUnit;
-import java.util.concurrent.TimeoutException;
-import java.util.concurrent.atomic.AtomicBoolean;
-import java.util.concurrent.locks.Condition;
-import java.util.concurrent.locks.Lock;
-import java.util.concurrent.locks.ReentrantLock;
-import org.apache.cassandra.utils.LogUtil;
-import org.apache.log4j.Logger;
-
-public class MultiAsyncResult implements IAsyncResult
-{
-    private static Logger logger_ = Logger.getLogger( AsyncResult.class );
-    private int expectedResults_;
-    private List<byte[]> result_ = new ArrayList<byte[]>();
-    private AtomicBoolean done_ = new AtomicBoolean(false);
-    private Lock lock_ = new ReentrantLock();
-    private Condition condition_;
-    
-    MultiAsyncResult(int expectedResults)
-    {
-        expectedResults_ = expectedResults;
-        condition_ = lock_.newCondition();
-    }
-    
-    public byte[] get()
-    {
-        throw new UnsupportedOperationException("This operation is not supported in the AsyncResult abstraction.");
-    }
-    
-    public byte[] get(long timeout, TimeUnit tu) throws TimeoutException
-    {
-        throw new UnsupportedOperationException("This operation is not supported in the AsyncResult abstraction.");
-    }
-    
-    public List<byte[]> multiget()
-    {
-        lock_.lock();
-        try
-        {
-            if ( !done_.get() )
-            {
-                condition_.await();                    
-            }
-        }
-        catch ( InterruptedException ex )
-        {
-            logger_.warn( LogUtil.throwableToString(ex) );
-        }
-        finally
-        {
-            lock_.unlock();            
-        }        
-        return result_;
-    }
-    
-    public boolean isDone()
-    {
-        return done_.get();
-    }
-    
-    public List<byte[]> multiget(long timeout, TimeUnit tu) throws TimeoutException
-    {
-        lock_.lock();
-        try
-        {            
-            boolean bVal = true;
-            try
-            {
-                if ( !done_.get() )
-                {                    
-                    bVal = condition_.await(timeout, tu);
-                }
-            }
-            catch ( InterruptedException ex )
-            {
-                logger_.warn( LogUtil.throwableToString(ex) );
-            }
-            
-            if ( !bVal && !done_.get() )
-            {                                           
-                throw new TimeoutException("Operation timed out.");
-            }
-        }
-        finally
-        {
-            lock_.unlock();      
-        }
-        return result_;
-    }
-    
-    public void result(Message result)
-    {        
-        try
-        {
-            lock_.lock();
-            if ( !done_.get() )
-            {
-                result_.add(result.getMessageBody());
-                if ( result_.size() == expectedResults_ )
-                {
-                    done_.set(true);
-                    condition_.signal();
-                }
-            }
-        }
-        finally
-        {
-            lock_.unlock();
-        }        
-    }    
-}
diff --git a/src/java/org/apache/cassandra/service/CassandraServer.java b/src/java/org/apache/cassandra/service/CassandraServer.java
index 5238382..6e4928f 100644
--- a/src/java/org/apache/cassandra/service/CassandraServer.java
+++ b/src/java/org/apache/cassandra/service/CassandraServer.java
@@ -36,7 +36,6 @@ import org.apache.cassandra.db.filter.QueryPath;
 import org.apache.cassandra.net.EndPoint;
 import org.apache.cassandra.service.StorageService;
 import org.apache.cassandra.utils.LogUtil;
-import org.apache.cassandra.dht.IPartitioner;
 import org.apache.cassandra.dht.Token;
 import org.apache.thrift.TException;
 
@@ -73,10 +72,17 @@ public class CassandraServer implements Cassandra.Iface
 		storageService.start();
 	}
 
-    protected ColumnFamily readColumnFamily(ReadCommand command, int consistency_level) throws InvalidRequestException
+    protected Map<String, ColumnFamily> readColumnFamily(List<ReadCommand> commands, int consistency_level) throws InvalidRequestException
     {
-        String cfName = command.getColumnFamilyName();
-        ThriftValidation.validateKey(command.key);
+        // TODO - Support multiple column families per row, right now row only contains 1 column family
+        String cfName = commands.get(0).getColumnFamilyName();
+
+        Map<String, ColumnFamily> columnFamilyKeyMap = new HashMap<String,ColumnFamily>();
+
+        for (ReadCommand command: commands)
+        {
+            ThriftValidation.validateKey(command.key);
+        }
 
         if (consistency_level == ConsistencyLevel.ZERO)
         {
@@ -87,10 +93,10 @@ public class CassandraServer implements Cassandra.Iface
             throw new InvalidRequestException("Consistency level all is not yet supported on read operations");
         }
 
-        Row row;
+        List<Row> rows;
         try
         {
-            row = StorageProxy.readProtocol(command, consistency_level);
+            rows = StorageProxy.readProtocol(commands, consistency_level);
         }
         catch (IOException e)
         {
@@ -101,11 +107,11 @@ public class CassandraServer implements Cassandra.Iface
             throw new RuntimeException(e);
         }
 
-        if (row == null)
+        for (Row row: rows)
         {
-            return null;
+            columnFamilyKeyMap.put(row.key(), row.getColumnFamily(cfName));
         }
-        return row.getColumnFamily(cfName);
+        return columnFamilyKeyMap;
 	}
 
     public List<Column> thriftifySubColumns(Collection<IColumn> columns)
@@ -169,50 +175,78 @@ public class CassandraServer implements Cassandra.Iface
         return thriftSuperColumns;
     }
 
-    private List<ColumnOrSuperColumn> getSlice(ReadCommand command, int consistency_level) throws InvalidRequestException
+    private Map<String, List<ColumnOrSuperColumn>> getSlice(List<ReadCommand> commands, int consistency_level) throws InvalidRequestException
     {
-        ColumnFamily cfamily = readColumnFamily(command, consistency_level);
-        boolean reverseOrder = command instanceof SliceFromReadCommand && ((SliceFromReadCommand)command).reversed;
-
-        if (cfamily == null || cfamily.getColumnsMap().size() == 0)
-        {
-            return EMPTY_COLUMNS;
-        }
-        if (command.queryPath.superColumnName != null)
+        Map<String, ColumnFamily> cfamilies = readColumnFamily(commands, consistency_level);
+        Map<String, List<ColumnOrSuperColumn>> columnFamiliesMap = new HashMap<String, List<ColumnOrSuperColumn>>();
+        for (ReadCommand command: commands)
         {
-            IColumn column = cfamily.getColumnsMap().values().iterator().next();
-            Collection<IColumn> subcolumns = column.getSubColumns();
-            if (subcolumns == null || subcolumns.isEmpty())
+            ColumnFamily cfamily = cfamilies.get(command.key);
+            boolean reverseOrder = command instanceof SliceFromReadCommand && ((SliceFromReadCommand)command).reversed;
+
+            if (cfamily == null || cfamily.getColumnsMap().size() == 0)
             {
-                return EMPTY_COLUMNS;
+                columnFamiliesMap.put(command.key, EMPTY_COLUMNS);
+                continue;
             }
-            return thriftifyColumns(subcolumns, reverseOrder);
-        }
-        if (cfamily.isSuper())
-        {
-            return thriftifySuperColumns(cfamily.getSortedColumns(), reverseOrder);
+            if (command.queryPath.superColumnName != null)
+            {
+                IColumn column = cfamily.getColumnsMap().values().iterator().next();
+                Collection<IColumn> subcolumns = column.getSubColumns();
+                if (subcolumns == null || subcolumns.isEmpty())
+                {
+                    columnFamiliesMap.put(command.key, EMPTY_COLUMNS);
+                    continue;
+                }
+                columnFamiliesMap.put(command.key, thriftifyColumns(subcolumns, reverseOrder));
+                continue;
+            }
+            if (cfamily.isSuper())
+                columnFamiliesMap.put(command.key, thriftifySuperColumns(cfamily.getSortedColumns(), reverseOrder));
+            else
+                columnFamiliesMap.put(command.key, thriftifyColumns(cfamily.getSortedColumns(), reverseOrder));
         }
-        return thriftifyColumns(cfamily.getSortedColumns(), reverseOrder);
+
+        return columnFamiliesMap;
     }
 
     public List<ColumnOrSuperColumn> get_slice(String keyspace, String key, ColumnParent column_parent, SlicePredicate predicate, int consistency_level)
     throws InvalidRequestException, NotFoundException
     {
         if (logger.isDebugEnabled())
-            logger.debug("get_slice_from");
+            logger.debug("get_slice");
+        return multigetSliceInternal(keyspace, Arrays.asList(key), column_parent, predicate, consistency_level).get(key);
+    }
+    
+    public Map<String, List<ColumnOrSuperColumn>> multiget_slice(String keyspace, List<String> keys, ColumnParent column_parent, SlicePredicate predicate, int consistency_level)
+    throws InvalidRequestException
+    {
+        if (logger.isDebugEnabled())
+            logger.debug("multiget_slice");
+        return multigetSliceInternal(keyspace, keys, column_parent, predicate, consistency_level);
+    }
+
+    private Map<String, List<ColumnOrSuperColumn>> multigetSliceInternal(String keyspace, List<String> keys, ColumnParent column_parent, SlicePredicate predicate, int consistency_level)
+    throws InvalidRequestException
+    {
         ThriftValidation.validateColumnParent(keyspace, column_parent);
+        List<ReadCommand> commands = new ArrayList<ReadCommand>();
+        SliceRange range = predicate.slice_range;
 
         if (predicate.column_names != null)
         {
+            for (String key: keys)
+                commands.add(new SliceByNamesReadCommand(keyspace, key, column_parent, predicate.column_names));
             ThriftValidation.validateColumns(keyspace, column_parent, predicate.column_names);
-            return getSlice(new SliceByNamesReadCommand(keyspace, key, column_parent, predicate.column_names), consistency_level);
         }
         else
         {
-            SliceRange range = predicate.slice_range;
+            for (String key: keys)
+                commands.add(new SliceFromReadCommand(keyspace, key, column_parent, range.start, range.finish, range.reversed, range.count));
             ThriftValidation.validateRange(keyspace, column_parent, range);
-            return getSlice(new SliceFromReadCommand(keyspace, key, column_parent, range.start, range.finish, range.reversed, range.count), consistency_level);
         }
+
+        return getSlice(commands, consistency_level);
     }
 
     public ColumnOrSuperColumn get(String table, String key, ColumnPath column_path, int consistency_level)
@@ -220,50 +254,127 @@ public class CassandraServer implements Cassandra.Iface
     {
         if (logger.isDebugEnabled())
             logger.debug("get");
-        ThriftValidation.validateColumnPath(table, column_path);
-
-        QueryPath path = new QueryPath(column_path.column_family, column_path.super_column);
-        List<byte[]> nameAsList = Arrays.asList(column_path.column == null ? column_path.super_column : column_path.column);
-        ColumnFamily cfamily = readColumnFamily(new SliceByNamesReadCommand(table, key, path, nameAsList), consistency_level);
-        if (cfamily == null)
+        ColumnOrSuperColumn column = multiget(table, Arrays.asList(key), column_path, consistency_level).get(key);
+        if (!column.isSetColumn() && !column.isSetSuper_column())
         {
             throw new NotFoundException();
         }
-        Collection<IColumn> columns = null;
-        if (column_path.super_column != null && column_path.column != null)
+        return column;
+    }
+
+    /** no values will be mapped to keys with no data */
+    private Map<String, Collection<IColumn>> multigetColumns(List<ReadCommand> commands, int consistency_level)
+    throws InvalidRequestException
+    {
+        Map<String, ColumnFamily> cfamilies = readColumnFamily(commands, consistency_level);
+        Map<String, Collection<IColumn>> columnFamiliesMap = new HashMap<String, Collection<IColumn>>();
+
+        for (ReadCommand command: commands)
         {
-            IColumn column = cfamily.getColumn(column_path.super_column);
-            if (column != null)
+            ColumnFamily cfamily = cfamilies.get(command.key);
+            if (cfamily == null)
+                continue;
+
+            Collection<IColumn> columns = null;
+            if (command.queryPath.superColumnName != null)
             {
-                columns = column.getSubColumns();
+                IColumn column = cfamily.getColumn(command.queryPath.superColumnName);
+                if (column != null)
+                {
+                    columns = column.getSubColumns();
+                }
+            }
+            else
+            {
+                columns = cfamily.getSortedColumns();
+            }
+
+            if (columns != null && columns.size() != 0)
+            {
+                columnFamiliesMap.put(command.key, columns);
             }
         }
-        else
-        {
-            columns = cfamily.getSortedColumns();
-        }
-        if (columns == null || columns.size() == 0)
+        return columnFamiliesMap;
+    }
+
+    /** always returns a ColumnOrSuperColumn for each key, even if there is no data for it */
+    public Map<String, ColumnOrSuperColumn> multiget(String table, List<String> keys, ColumnPath column_path, int consistency_level)
+    throws InvalidRequestException
+    {
+        if (logger.isDebugEnabled())
+            logger.debug("multiget");
+        return multigetInternal(table, keys, column_path, consistency_level);
+    }
+
+    private Map<String, ColumnOrSuperColumn> multigetInternal(String table, List<String> keys, ColumnPath column_path, int consistency_level)
+    throws InvalidRequestException
+    {
+        ThriftValidation.validateColumnPath(table, column_path);
+
+        QueryPath path = new QueryPath(column_path.column_family, column_path.super_column);
+        List<byte[]> nameAsList = Arrays.asList(column_path.column == null ? column_path.super_column : column_path.column);
+        List<ReadCommand> commands = new ArrayList<ReadCommand>();
+        for (String key: keys)
         {
-            throw new NotFoundException();
+            commands.add(new SliceByNamesReadCommand(table, key, path, nameAsList));
         }
 
-        assert columns.size() == 1;
-        IColumn column = columns.iterator().next();
-        if (column.isMarkedForDelete())
+        Map<String, ColumnOrSuperColumn> columnFamiliesMap = new HashMap<String, ColumnOrSuperColumn>();
+        Map<String, Collection<IColumn>> columnsMap = multigetColumns(commands, consistency_level);
+
+        for (ReadCommand command: commands)
         {
-            throw new NotFoundException();
+            ColumnOrSuperColumn columnorsupercolumn;
+
+            Collection<IColumn> columns = columnsMap.get(command.key);
+            if (columns == null)
+            {
+               columnorsupercolumn = new ColumnOrSuperColumn();
+            }
+            else
+            {
+                assert columns.size() == 1;
+                IColumn column = columns.iterator().next();
+
+
+                if (column.isMarkedForDelete())
+                {
+                    columnorsupercolumn = new ColumnOrSuperColumn();
+                }
+                else
+                {
+                    columnorsupercolumn = column instanceof org.apache.cassandra.db.Column
+                                          ? new ColumnOrSuperColumn(new Column(column.name(), column.value(), column.timestamp()), null)
+                                          : new ColumnOrSuperColumn(null, new SuperColumn(column.name(), thriftifySubColumns(column.getSubColumns())));
+                }
+
+            }
+            columnFamiliesMap.put(command.key, columnorsupercolumn);
         }
 
-        return column instanceof org.apache.cassandra.db.Column
-               ? new ColumnOrSuperColumn(new Column(column.name(), column.value(), column.timestamp()), null)
-               : new ColumnOrSuperColumn(null, new SuperColumn(column.name(), thriftifySubColumns(column.getSubColumns())));
+        return columnFamiliesMap;
     }
 
     public int get_count(String table, String key, ColumnParent column_parent, int consistency_level)
     throws InvalidRequestException
     {
         if (logger.isDebugEnabled())
-            logger.debug("get_column_count");
+            logger.debug("get_count");
+        return multigetCountInternal(table, Arrays.asList(key), column_parent, consistency_level).get(key);
+    }
+
+    public Map<String, Integer> multiget_count(String table, List<String> keys, ColumnParent column_parent, int consistency_level)
+    throws InvalidRequestException
+    {
+        if (logger.isDebugEnabled())
+            logger.debug("multiget_count");
+        return multigetCountInternal(table, keys, column_parent, consistency_level);
+
+    }
+
+    private Map<String, Integer> multigetCountInternal(String table, List<String> keys, ColumnParent column_parent, int consistency_level)
+    throws InvalidRequestException
+    {
         // validateColumnParent assumes we require simple columns; g_c_c is the only
         // one of the columnParent-taking apis that can also work at the SC level.
         // so we roll a one-off validator here.
@@ -273,31 +384,29 @@ public class CassandraServer implements Cassandra.Iface
             throw new InvalidRequestException("columnfamily alone is required for standard CF " + column_parent.column_family);
         }
 
-        ColumnFamily cfamily;
-        cfamily = readColumnFamily(new SliceFromReadCommand(table, key, column_parent, ArrayUtils.EMPTY_BYTE_ARRAY, ArrayUtils.EMPTY_BYTE_ARRAY, true, Integer.MAX_VALUE), consistency_level);
-        if (cfamily == null)
+        List<ReadCommand> commands = new ArrayList<ReadCommand>();
+        for (String key: keys)
         {
-            return 0;
+            commands.add(new SliceFromReadCommand(table, key, column_parent, ArrayUtils.EMPTY_BYTE_ARRAY, ArrayUtils.EMPTY_BYTE_ARRAY, true, Integer.MAX_VALUE));
         }
-        Collection<IColumn> columns = null;
-        if (column_parent.super_column != null)
+
+        Map<String, Integer> columnFamiliesMap = new HashMap<String, Integer>();
+        Map<String, Collection<IColumn>> columnsMap = multigetColumns(commands, consistency_level);
+
+        for (ReadCommand command: commands)
         {
-            IColumn column = cfamily.getColumn(column_parent.super_column);
-            if (column != null)
+            Collection<IColumn> columns = columnsMap.get(command.key);
+            if(columns == null)
             {
-                columns = column.getSubColumns();
+               columnFamiliesMap.put(command.key, 0);
+            }
+            else
+            {
+               columnFamiliesMap.put(command.key, columns.size());
             }
         }
-        else
-        {
-            columns = cfamily.getSortedColumns();
-        }
-        if (columns == null || columns.size() == 0)
-        {
-            return 0;
-        }
-        return columns.size();
-	}
+        return columnFamiliesMap;
+    }
 
     public void insert(String table, String key, ColumnPath column_path, byte[] value, long timestamp, int consistency_level)
     throws InvalidRequestException, UnavailableException
diff --git a/src/java/org/apache/cassandra/service/QuorumResponseHandler.java b/src/java/org/apache/cassandra/service/QuorumResponseHandler.java
index be63c40..840d9a0 100644
--- a/src/java/org/apache/cassandra/service/QuorumResponseHandler.java
+++ b/src/java/org/apache/cassandra/service/QuorumResponseHandler.java
@@ -41,6 +41,7 @@ public class QuorumResponseHandler<T> implements IAsyncCallback
     private List<Message> responses_ = new ArrayList<Message>();
     private IResponseResolver<T> responseResolver_;
     private AtomicBoolean done_ = new AtomicBoolean(false);
+    private long startTime_;
 
     public QuorumResponseHandler(int responseCount, IResponseResolver<T> responseResolver) throws InvalidRequestException
     {
@@ -51,6 +52,7 @@ public class QuorumResponseHandler<T> implements IAsyncCallback
         condition_ = lock_.newCondition();
         responseCount_ = responseCount;
         responseResolver_ =  responseResolver;
+        startTime_ = System.currentTimeMillis();
     }
     
     public T get() throws TimeoutException, DigestMismatchException
@@ -62,8 +64,12 @@ public class QuorumResponseHandler<T> implements IAsyncCallback
             try
             {
             	if ( !done_.get() )
-                {            		
-            		bVal = condition_.await(DatabaseDescriptor.getRpcTimeout(), TimeUnit.MILLISECONDS);
+                {
+                    long timeout = System.currentTimeMillis() - startTime_ + DatabaseDescriptor.getRpcTimeout();
+                    if(timeout > 0)
+                        bVal = condition_.await(timeout, TimeUnit.MILLISECONDS);
+                    else
+                        bVal = false;
                 }
             }
             catch ( InterruptedException ex )
diff --git a/src/java/org/apache/cassandra/service/StorageProxy.java b/src/java/org/apache/cassandra/service/StorageProxy.java
index 989c513..f7993b9 100644
--- a/src/java/org/apache/cassandra/service/StorageProxy.java
+++ b/src/java/org/apache/cassandra/service/StorageProxy.java
@@ -238,171 +238,101 @@ public class StorageProxy implements StorageProxyMBean
         insertBlocking(rm, ConsistencyLevel.QUORUM);
     }
     
-    private static Map<String, Message> constructMessages(Map<String, ReadCommand> readMessages) throws IOException
-    {
-        Map<String, Message> messages = new HashMap<String, Message>();
-        Set<String> keys = readMessages.keySet();        
-        for ( String key : keys )
-        {
-            Message message = readMessages.get(key).makeReadMessage();
-            messages.put(key, message);
-        }        
-        return messages;
-    }
-    
-    private static IAsyncResult dispatchMessages(Map<String, EndPoint> endPoints, Map<String, Message> messages)
-    {
-        Set<String> keys = endPoints.keySet();
-        EndPoint[] eps = new EndPoint[keys.size()];
-        Message[] msgs  = new Message[keys.size()];
-        
-        int i = 0;
-        for ( String key : keys )
-        {
-            eps[i] = endPoints.get(key);
-            msgs[i] = messages.get(key);
-            ++i;
-        }
-        
-        IAsyncResult iar = MessagingService.getMessagingInstance().sendRR(msgs, eps);
-        return iar;
-    }
-    
-    /**
-     * This is an implementation for the multiget version. 
-     * @param readMessages map of key --> ReadMessage to be sent
-     * @return map of key --> Row
-     * @throws IOException
-     * @throws TimeoutException
-     */
-    public static Map<String, Row> doReadProtocol(Map<String, ReadCommand> readMessages) throws IOException,TimeoutException
-    {
-        Map<String, Row> rows = new HashMap<String, Row>();
-        Set<String> keys = readMessages.keySet();
-        /* Find all the suitable endpoints for the keys */
-        Map<String, EndPoint> endPoints = StorageService.instance().findSuitableEndPoints(keys.toArray( new String[0] ));
-        /* Construct the messages to be sent out */
-        Map<String, Message> messages = constructMessages(readMessages);
-        /* Dispatch the messages to the respective endpoints */
-        IAsyncResult iar = dispatchMessages(endPoints, messages);        
-        List<byte[]> results = iar.multiget(2*DatabaseDescriptor.getRpcTimeout(), TimeUnit.MILLISECONDS);
-        
-        for ( byte[] body : results )
-        {
-            DataInputBuffer bufIn = new DataInputBuffer();
-            bufIn.reset(body, body.length);
-            ReadResponse response = ReadResponse.serializer().deserialize(bufIn);
-            Row row = response.row();
-            rows.put(row.key(), row);
-        }        
-        return rows;
-    }
 
     /**
      * Read the data from one replica.  If there is no reply, read the data from another.  In the event we get
      * the data we perform consistency checks and figure out if any repairs need to be done to the replicas.
-     * @param command the read to perform
+     * @param commands a set of commands to perform reads
      * @return the row associated with command.key
      * @throws Exception
      */
-    private static Row weakReadRemote(ReadCommand command) throws IOException
+    private static List<Row> weakReadRemote(List<ReadCommand> commands) throws IOException
     {
-        EndPoint endPoint = StorageService.instance().findSuitableEndPoint(command.key);
-        assert endPoint != null;
-        Message message = command.makeReadMessage();
         if (logger.isDebugEnabled())
-            logger.debug("weakreadremote reading " + command + " from " + message.getMessageId() + "@" + endPoint);
-        message.addHeader(ReadCommand.DO_REPAIR, ReadCommand.DO_REPAIR.getBytes());
-        IAsyncResult iar = MessagingService.getMessagingInstance().sendRR(message, endPoint);
-        byte[] body;
-        try
+            logger.debug("weakreadlocal reading " + StringUtils.join(commands, ", "));
+
+        List<Row> rows = new ArrayList<Row>();
+        List<IAsyncResult> iars = new ArrayList<IAsyncResult>();
+        int commandIndex = 0;
+
+        for (ReadCommand command: commands)
         {
-            body = iar.get(DatabaseDescriptor.getRpcTimeout(), TimeUnit.MILLISECONDS);
+            EndPoint endPoint = StorageService.instance().findSuitableEndPoint(command.key);
+            assert endPoint != null;
+            Message message = command.makeReadMessage();
+
+            if (logger.isDebugEnabled())
+                logger.debug("weakreadremote reading " + command + " from " + message.getMessageId() + "@" + endPoint);
+            message.addHeader(ReadCommand.DO_REPAIR, ReadCommand.DO_REPAIR.getBytes());
+            iars.add(MessagingService.getMessagingInstance().sendRR(message, endPoint));
         }
-        catch (TimeoutException e)
+
+        for (IAsyncResult iar: iars)
         {
-            throw new RuntimeException("error reading key " + command.key, e);
-            // TODO retry to a different endpoint?
+            byte[] body;
+            try
+            {
+                body = iar.get(DatabaseDescriptor.getRpcTimeout(), TimeUnit.MILLISECONDS);
+            }
+            catch (TimeoutException e)
+            {
+                throw new RuntimeException("error reading key " + commands.get(commandIndex).key, e);
+                // TODO retry to a different endpoint?
+            }
+            DataInputBuffer bufIn = new DataInputBuffer();
+            bufIn.reset(body, body.length);
+            ReadResponse response = ReadResponse.serializer().deserialize(bufIn);
+            if (response.row() != null)
+                rows.add(response.row());
+            commandIndex++;
         }
-        DataInputBuffer bufIn = new DataInputBuffer();
-        bufIn.reset(body, body.length);
-        ReadResponse response = ReadResponse.serializer().deserialize(bufIn);
-        return response.row();
+        return rows;
     }
 
     /**
      * Performs the actual reading of a row out of the StorageService, fetching
      * a specific set of column names from a given column family.
      */
-    public static Row readProtocol(ReadCommand command, int consistency_level)
+    public static List<Row> readProtocol(List<ReadCommand> commands, int consistency_level)
     throws IOException, TimeoutException, InvalidRequestException
     {
         long startTime = System.currentTimeMillis();
 
-        Row row;
-        EndPoint[] endpoints = StorageService.instance().getNStorageEndPoint(command.key);
+        List<Row> rows = new ArrayList<Row>();
 
         if (consistency_level == ConsistencyLevel.ONE)
         {
-            boolean foundLocal = Arrays.asList(endpoints).contains(StorageService.getLocalStorageEndPoint());
-            //TODO: Throw InvalidRequest if we're in bootstrap mode?
-            if (foundLocal && !StorageService.instance().isBootstrapMode())
-            {
-                row = weakReadLocal(command);
-            }
-            else
+            List<ReadCommand> localCommands = new ArrayList<ReadCommand>();
+            List<ReadCommand> remoteCommands = new ArrayList<ReadCommand>();
+
+            for (ReadCommand command: commands)
             {
-                row = weakReadRemote(command);
+                EndPoint[] endpoints = StorageService.instance().getNStorageEndPoint(command.key);
+                boolean foundLocal = Arrays.asList(endpoints).contains(StorageService.getLocalStorageEndPoint());
+                //TODO: Throw InvalidRequest if we're in bootstrap mode?
+                if (foundLocal && !StorageService.instance().isBootstrapMode())
+                {
+                    localCommands.add(command);
+                }
+                else
+                {
+                    remoteCommands.add(command);
+                }
             }
+            if (localCommands.size() > 0)
+                rows.addAll(weakReadLocal(localCommands));
+
+            if (remoteCommands.size() > 0)
+                rows.addAll(weakReadRemote(remoteCommands));
         }
         else
         {
             assert consistency_level == ConsistencyLevel.QUORUM;
-            row = strongRead(command);
+            rows = strongRead(commands);
         }
 
         readStats.add(System.currentTimeMillis() - startTime);
 
-        return row;
-    }
-
-    public static Map<String, Row> readProtocol(String[] keys, ReadCommand readCommand, StorageService.ConsistencyLevel consistencyLevel) throws Exception
-    {
-        Map<String, Row> rows = new HashMap<String, Row>();        
-        switch ( consistencyLevel )
-        {
-            case WEAK:
-                rows = weakReadProtocol(keys, readCommand);
-                break;
-                
-            case STRONG:
-                rows = strongReadProtocol(keys, readCommand);
-                break;
-                
-            default:
-                rows = weakReadProtocol(keys, readCommand);
-                break;
-        }
-        return rows;
-    }
-
-    /**
-     * This is a multiget version of the above method.
-     */
-    public static Map<String, Row> strongReadProtocol(String[] keys, ReadCommand readCommand) throws IOException, TimeoutException
-    {       
-        Map<String, Row> rows;
-        // TODO: throw a thrift exception if we do not have N nodes
-        Map<String, ReadCommand[]> readMessages = new HashMap<String, ReadCommand[]>();
-        for (String key : keys )
-        {
-            ReadCommand[] readParameters = new ReadCommand[2];
-            readParameters[0] = readCommand.copy();
-            readParameters[1] = readCommand.copy();
-            readParameters[1].setDigestQuery(true);
-            readMessages.put(key, readParameters);
-        }        
-        rows = doStrongReadProtocol(readMessages);         
         return rows;
     }
 
@@ -418,80 +348,100 @@ public class StorageProxy implements StorageProxyMBean
          * 7. else carry out read repair by getting data from all the nodes.
         // 5. return success
      */
-    private static Row strongRead(ReadCommand command) throws IOException, TimeoutException, InvalidRequestException
+    private static List<Row> strongRead(List<ReadCommand> commands) throws IOException, TimeoutException, InvalidRequestException
     {
-        // TODO: throw a thrift exception if we do not have N nodes
-        assert !command.isDigestQuery();
-        ReadCommand readMessageDigestOnly = command.copy();
-        readMessageDigestOnly.setDigestQuery(true);
-
-        Row row = null;
-        Message message = command.makeReadMessage();
-        Message messageDigestOnly = readMessageDigestOnly.makeReadMessage();
-
-        IResponseResolver<Row> readResponseResolver = new ReadResponseResolver();
-        QuorumResponseHandler<Row> quorumResponseHandler = new QuorumResponseHandler<Row>(
-                DatabaseDescriptor.getQuorum(),
-                readResponseResolver);
-        EndPoint dataPoint = StorageService.instance().findSuitableEndPoint(command.key);
-        List<EndPoint> endpointList = new ArrayList<EndPoint>(Arrays.asList(StorageService.instance().getNStorageEndPoint(command.key)));
-        /* Remove the local storage endpoint from the list. */
-        endpointList.remove(dataPoint);
-        EndPoint[] endPoints = new EndPoint[endpointList.size() + 1];
-        Message messages[] = new Message[endpointList.size() + 1];
+        List<QuorumResponseHandler<Row>> quorumResponseHandlers = new ArrayList<QuorumResponseHandler<Row>>();
+        List<EndPoint[]> commandEndPoints = new ArrayList<EndPoint[]>();
+        List<Row> rows = new ArrayList<Row>();
 
-        /*
-         * First message is sent to the node that will actually get
-         * the data for us. The other two replicas are only sent a
-         * digest query.
-        */
-        endPoints[0] = dataPoint;
-        messages[0] = message;
-        if (logger.isDebugEnabled())
-            logger.debug("strongread reading data for " + command + " from " + message.getMessageId() + "@" + dataPoint);
-        for (int i = 1; i < endPoints.length; i++)
-        {
-            EndPoint digestPoint = endpointList.get(i - 1);
-            endPoints[i] = digestPoint;
-            messages[i] = messageDigestOnly;
-            if (logger.isDebugEnabled())
-                logger.debug("strongread reading digest for " + command + " from " + messageDigestOnly.getMessageId() + "@" + digestPoint);
-        }
+        int commandIndex = 0;
 
-        try
+        for (ReadCommand command: commands)
         {
-            MessagingService.getMessagingInstance().sendRR(messages, endPoints, quorumResponseHandler);
+            // TODO: throw a thrift exception if we do not have N nodes
+            assert !command.isDigestQuery();
+            ReadCommand readMessageDigestOnly = command.copy();
+            readMessageDigestOnly.setDigestQuery(true);
 
-            long startTime2 = System.currentTimeMillis();
-            row = quorumResponseHandler.get();
+            Message message = command.makeReadMessage();
+            Message messageDigestOnly = readMessageDigestOnly.makeReadMessage();
+
+            IResponseResolver<Row> readResponseResolver = new ReadResponseResolver();
+            QuorumResponseHandler<Row> quorumResponseHandler = new QuorumResponseHandler<Row>(
+                    DatabaseDescriptor.getQuorum(),
+                    readResponseResolver);
+            EndPoint dataPoint = StorageService.instance().findSuitableEndPoint(command.key);
+            List<EndPoint> endpointList = new ArrayList<EndPoint>(Arrays.asList(StorageService.instance().getNStorageEndPoint(command.key)));
+            /* Remove the local storage endpoint from the list. */
+            endpointList.remove(dataPoint);
+            EndPoint[] endPoints = new EndPoint[endpointList.size() + 1];
+            Message messages[] = new Message[endpointList.size() + 1];
+
+            /*
+             * First message is sent to the node that will actually get
+             * the data for us. The other two replicas are only sent a
+             * digest query.
+            */
+            endPoints[0] = dataPoint;
+            messages[0] = message;
             if (logger.isDebugEnabled())
-                logger.debug("quorumResponseHandler: " + (System.currentTimeMillis() - startTime2) + " ms.");
+                logger.debug("strongread reading data for " + command + " from " + message.getMessageId() + "@" + dataPoint);
+            for (int i = 1; i < endPoints.length; i++)
+            {
+                EndPoint digestPoint = endpointList.get(i - 1);
+                endPoints[i] = digestPoint;
+                messages[i] = messageDigestOnly;
+                if (logger.isDebugEnabled())
+                    logger.debug("strongread reading digest for " + command + " from " + messageDigestOnly.getMessageId() + "@" + digestPoint);
+            }
+            MessagingService.getMessagingInstance().sendRR(messages, endPoints, quorumResponseHandler);
+            quorumResponseHandlers.add(quorumResponseHandler);
+            commandEndPoints.add(endPoints);
         }
-        catch (DigestMismatchException ex)
+
+        for (QuorumResponseHandler<Row> quorumResponseHandler: quorumResponseHandlers)
         {
-            if ( DatabaseDescriptor.getConsistencyCheck())
+            Row row = null;
+            ReadCommand command = commands.get(commandIndex);
+            try
             {
-                IResponseResolver<Row> readResponseResolverRepair = new ReadResponseResolver();
-                QuorumResponseHandler<Row> quorumResponseHandlerRepair = new QuorumResponseHandler<Row>(
-                        DatabaseDescriptor.getQuorum(),
-                        readResponseResolverRepair);
-                logger.info("DigestMismatchException: " + command.key);
-                Message messageRepair = command.makeReadMessage();
-                MessagingService.getMessagingInstance().sendRR(messageRepair, endPoints,
-                                                               quorumResponseHandlerRepair);
-                try
-                {
-                    row = quorumResponseHandlerRepair.get();
-                }
-                catch (DigestMismatchException e)
+                long startTime2 = System.currentTimeMillis();
+                row = quorumResponseHandler.get();
+                if (row != null)
+                    rows.add(row);
+
+                if (logger.isDebugEnabled())
+                    logger.debug("quorumResponseHandler: " + (System.currentTimeMillis() - startTime2) + " ms.");
+            }
+            catch (DigestMismatchException ex)
+            {
+                if ( DatabaseDescriptor.getConsistencyCheck())
                 {
-                    // TODO should this be a thrift exception?
-                    throw new RuntimeException("digest mismatch reading key " + command.key, e);
+                    IResponseResolver<Row> readResponseResolverRepair = new ReadResponseResolver();
+                    QuorumResponseHandler<Row> quorumResponseHandlerRepair = new QuorumResponseHandler<Row>(
+                            DatabaseDescriptor.getQuorum(),
+                            readResponseResolverRepair);
+                    logger.info("DigestMismatchException: " + command.key);
+                    Message messageRepair = command.makeReadMessage();
+                    MessagingService.getMessagingInstance().sendRR(messageRepair, commandEndPoints.get(commandIndex),
+                            quorumResponseHandlerRepair);
+                    try
+                    {
+                        row = quorumResponseHandlerRepair.get();
+                        if (row != null)
+                            rows.add(row);
+                    }
+                    catch (DigestMismatchException e)
+                    {
+                        // TODO should this be a thrift exception?
+                        throw new RuntimeException("digest mismatch reading key " + command.key, e);
+                    }
                 }
             }
+            commandIndex++;
         }
 
-        return row;
+        return rows;
     }
 
     private static Map<String, Message[]> constructReplicaMessages(Map<String, ReadCommand[]> readMessages) throws IOException
@@ -557,69 +507,6 @@ public class StorageProxy implements StorageProxyMBean
         MessagingService.getMessagingInstance().sendRR(msgList, epList, quorumResponseHandlers);
         return quorumResponseHandlers;
     }
-    
-    /**
-    *  This method performs the read from the replicas for a bunch of keys.
-    *  @param readMessages map of key --> readMessage[] of two entries where 
-    *         the first entry is the readMessage for the data and the second
-    *         is the entry for the digest 
-    *  @return map containing key ---> Row
-    *  @throws IOException, TimeoutException
-   */
-    private static Map<String, Row> doStrongReadProtocol(Map<String, ReadCommand[]> readMessages) throws IOException
-    {        
-        Map<String, Row> rows = new HashMap<String, Row>();
-        /* Construct the messages to be sent to the replicas */
-        Map<String, Message[]> replicaMessages = constructReplicaMessages(readMessages);
-        /* Dispatch the messages to the different replicas */
-        MultiQuorumResponseHandler cb = dispatchMessagesMulti(readMessages, replicaMessages);
-        try
-        {
-            Row[] rows2 = cb.get();
-            for ( Row row : rows2 )
-            {
-                rows.put(row.key(), row);
-            }
-        }
-        catch (TimeoutException e)
-        {
-            throw new RuntimeException("timeout reading keys " + StringUtils.join(rows.keySet(), ", "), e);
-        }
-        return rows;
-    }
-
-    /**
-     * This version is used when results for multiple keys needs to be
-     * retrieved.
-     * 
-     * @return a mapping of key --> Row
-     * @throws Exception
-     */
-    public static Map<String, Row> weakReadProtocol(String[] keys, ReadCommand readCommand) throws Exception
-    {
-        Row row = null;
-        Map<String, ReadCommand> readMessages = new HashMap<String, ReadCommand>();
-        for ( String key : keys )
-        {
-            ReadCommand readCmd = readCommand.copy();
-            readMessages.put(key, readCmd);
-        }
-        /* Performs the multiget in parallel */
-        Map<String, Row> rows = doReadProtocol(readMessages);
-        /*
-         * Do the consistency checks for the keys that are being queried
-         * in the background.
-        */
-        for ( String key : keys )
-        {
-            List<EndPoint> endpoints = StorageService.instance().getNLiveStorageEndPoint(key);
-            /* Remove the local storage endpoint from the list. */
-            endpoints.remove( StorageService.getLocalStorageEndPoint() );
-            if ( endpoints.size() > 0 && DatabaseDescriptor.getConsistencyCheck())
-                StorageService.instance().doConsistencyCheck(row, endpoints, readMessages.get(key));
-        }
-        return rows;
-    }
 
     /*
     * This function executes the read protocol locally and should be used only if consistency is not a concern.
@@ -627,25 +514,33 @@ public class StorageProxy implements StorageProxyMBean
     * one of the other replicas (in the same data center if possible) till we get the data. In the event we get
     * the data we perform consistency checks and figure out if any repairs need to be done to the replicas.
     */
-    private static Row weakReadLocal(ReadCommand command) throws IOException
+    private static List<Row> weakReadLocal(List<ReadCommand> commands) throws IOException
     {
-        if (logger.isDebugEnabled())
-            logger.debug("weakreadlocal reading " + command);
-        List<EndPoint> endpoints = StorageService.instance().getNLiveStorageEndPoint(command.key);
-        /* Remove the local storage endpoint from the list. */
-        endpoints.remove(StorageService.getLocalStorageEndPoint());
-        // TODO: throw a thrift exception if we do not have N nodes
+        List<Row> rows = new ArrayList<Row>();
+        for (ReadCommand command: commands)
+        {
+            List<EndPoint> endpoints = StorageService.instance().getNLiveStorageEndPoint(command.key);
+            /* Remove the local storage endpoint from the list. */
+            endpoints.remove(StorageService.getLocalStorageEndPoint());
+            // TODO: throw a thrift exception if we do not have N nodes
+
+            if (logger.isDebugEnabled())
+                logger.debug("weakreadlocal reading " + command);
+
+            Table table = Table.open(command.table);
+            Row row = command.getRow(table);
+            if (row != null)
+                rows.add(row);
+            /*
+            * Do the consistency checks in the background and return the
+            * non NULL row.
+            */
+            if (endpoints.size() > 0 && DatabaseDescriptor.getConsistencyCheck())
+                StorageService.instance().doConsistencyCheck(row, endpoints, command);
 
-        Table table = Table.open(command.table);
-        Row row = command.getRow(table);
+        }
 
-        /*
-           * Do the consistency checks in the background and return the
-           * non NULL row.
-           */
-        if (endpoints.size() > 0 && DatabaseDescriptor.getConsistencyCheck())
-            StorageService.instance().doConsistencyCheck(row, endpoints, command);
-        return row;
+        return rows;
     }
 
     static List<String> getKeyRange(RangeCommand rawCommand) throws IOException
diff --git a/test/system/test_server.py b/test/system/test_server.py
index a6ddd57..e7ca544 100644
--- a/test/system/test_server.py
+++ b/test/system/test_server.py
@@ -35,14 +35,22 @@ _SUPER_COLUMNS = [SuperColumn(name='sc1', columns=[Column(_i64(4), 'value4', 0)]
                                                    Column(_i64(6), 'value6', 0)])]
 
 def _insert_simple(block=True):
+   return _insert_multi(['key1'], block)
+
+def _insert_batch(block):
+   return _insert_multi_batch(['key1'], block)
+
+def _insert_multi(keys, block=True):
     if block:
         consistencyLevel = ConsistencyLevel.ONE
     else:
         consistencyLevel = ConsistencyLevel.ZERO
-    client.insert('Keyspace1', 'key1', ColumnPath('Standard1', column='c1'), 'value1', 0, consistencyLevel)
-    client.insert('Keyspace1', 'key1', ColumnPath('Standard1', column='c2'), 'value2', 0, consistencyLevel)
 
-def _insert_batch(block):
+    for key in keys:
+        client.insert('Keyspace1', key, ColumnPath('Standard1', column='c1'), 'value1', 0, consistencyLevel)
+        client.insert('Keyspace1', key, ColumnPath('Standard1', column='c2'), 'value2', 0, consistencyLevel)
+
+def _insert_multi_batch(keys, block):
     cfmap = {'Standard1': [ColumnOrSuperColumn(c) for c in _SIMPLE_COLUMNS],
              'Standard2': [ColumnOrSuperColumn(c) for c in _SIMPLE_COLUMNS]}
     if block:
@@ -50,12 +58,17 @@ def _insert_batch(block):
     else:
         consistencyLevel = ConsistencyLevel.ZERO
 
-    client.batch_insert('Keyspace1', BatchMutation(key='key1', cfmap=cfmap), consistencyLevel)
+    for key in keys:
+        client.batch_insert('Keyspace1', BatchMutation(key=key, cfmap=cfmap), consistencyLevel)
 
 def _big_slice(keyspace, key, column_parent):
     p = SlicePredicate(slice_range=SliceRange('', '', False, 1000))
     return client.get_slice(keyspace, key, column_parent, p, ConsistencyLevel.ONE)
 
+def _big_multislice(keyspace, keys, column_parent):
+    p = SlicePredicate(slice_range=SliceRange('', '', False, 1000))
+    return client.multiget_slice(keyspace, keys, column_parent, p, ConsistencyLevel.ONE)
+
 def _verify_batch():
     _verify_simple()
     L = [result.column
@@ -492,3 +505,59 @@ class TestMutations(CassandraTester):
         result = client.get_slice('Keyspace1', 'key1', ColumnParent('Super1', 'sc1'), p, ConsistencyLevel.ONE) 
         assert len(result) == 1
         assert result[0].column.name == _i64(4)
+
+    def test_multiget(self):
+        """Insert multiple keys and retrieve them using the multiget interface"""
+
+        """Generate a list of 10 keys and insert them"""
+        num_keys = 10
+        keys = ['key'+str(i) for i in range(1, num_keys+1)]
+        _insert_multi(keys)
+
+        """Retrieve all 10 keys"""
+        rows = client.multiget('Keyspace1', keys, ColumnPath('Standard1', column='c1'), ConsistencyLevel.ONE)
+        keys1 = rows.keys().sort()
+        keys2 = keys.sort()
+
+        """Validate if the returned rows have the keys requested and if the ColumnOrSuperColumn is what was inserted"""
+        for key in keys:
+            assert rows.has_key(key) == True
+            assert rows[key] == ColumnOrSuperColumn(column=Column(timestamp=0, name='c1', value='value1'))
+
+    def test_multiget_slice(self):
+        """Insert multiple keys and retrieve them using the multiget_slice interface"""
+
+        """Generate a list of 10 keys and insert them"""
+        num_keys = 10
+        keys = ['key'+str(i) for i in range(1, num_keys+1)]
+        _insert_multi(keys)
+
+        """Retrieve all 10 key slices"""
+        rows = _big_multislice('Keyspace1', keys, ColumnParent('Standard1'))
+        keys1 = rows.keys().sort()
+        keys2 = keys.sort()
+
+        columns = [ColumnOrSuperColumn(c) for c in _SIMPLE_COLUMNS]
+        """Validate if the returned rows have the keys requested and if the ColumnOrSuperColumn is what was inserted"""
+        for key in keys:
+            assert rows.has_key(key) == True
+            assert columns == rows[key]
+
+    def test_multiget_count(self):
+        """Insert multiple keys and retrieve them using the multiget_count interface"""
+
+        """Generate a list of 10 keys and insert them"""
+        num_keys = 10
+        keys = ['key'+str(i) for i in range(1, num_keys+1)]
+        _insert_multi(keys)
+
+        """Retrieve all 10 key slices"""
+        rows = client.multiget_count('Keyspace1', keys, ColumnParent('Standard1'), ConsistencyLevel.ONE)
+        keys1 = rows.keys().sort()
+        keys2 = keys.sort()
+
+        columns = [ColumnOrSuperColumn(c) for c in _SIMPLE_COLUMNS]
+        """Validate if the returned rows have the keys requested and if the ColumnOrSuperColumn is what was inserted"""
+        for key in keys:
+            assert rows.has_key(key) == True
+            assert rows[key] == 2
\ No newline at end of file
