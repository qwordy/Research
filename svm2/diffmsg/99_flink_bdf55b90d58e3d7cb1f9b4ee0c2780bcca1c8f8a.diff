commit bdf55b90d58e3d7cb1f9b4ee0c2780bcca1c8f8a
Author: Till Rohrmann <trohrmann@apache.org>
Date:   Wed Mar 30 15:27:21 2016 +0200

    [FLINK-3682] [cep] Assign processing timestamp in CEP operators
    
    This PR fixes the problem that the CEP operators did not assign the wall clock time
    as the timestamp to incoming in StreamRecords if the TimeCharacteristic was set to
    ProcessingTime. Processing element with a Long.MIN_VALUE timestamp can lead to underflows
    in the NFA if a positive window length is subtracted from the timestamp. For this
    underflow a sanity check has been added to notify the user with an exception about it.
    
    This closes #1841.

diff --git a/flink-libraries/flink-cep/src/main/java/org/apache/flink/cep/nfa/NFA.java b/flink-libraries/flink-cep/src/main/java/org/apache/flink/cep/nfa/NFA.java
index 4e4157c..47fc7df 100644
--- a/flink-libraries/flink-cep/src/main/java/org/apache/flink/cep/nfa/NFA.java
+++ b/flink-libraries/flink-cep/src/main/java/org/apache/flink/cep/nfa/NFA.java
@@ -155,6 +155,13 @@ public class NFA<T> implements Serializable {
 			if(windowTime > 0) {
 				long pruningTimestamp = timestamp - windowTime;
 
+				// sanity check to guard against underflows
+				if (pruningTimestamp >= timestamp) {
+					throw new IllegalStateException("Detected an underflow in the pruning timestamp. This indicates that" +
+						" either the window length is too long (" + windowTime + ") or that the timestamp has not been" +
+						" set correctly (e.g. Long.MIN_VALUE).");
+				}
+
 				// remove all elements which are expired with respect to the window length
 				sharedBuffer.prune(pruningTimestamp);
 			}
diff --git a/flink-libraries/flink-cep/src/main/java/org/apache/flink/cep/operator/AbstractCEPPatternOperator.java b/flink-libraries/flink-cep/src/main/java/org/apache/flink/cep/operator/AbstractCEPPatternOperator.java
index a943f0d..6b087e3 100644
--- a/flink-libraries/flink-cep/src/main/java/org/apache/flink/cep/operator/AbstractCEPPatternOperator.java
+++ b/flink-libraries/flink-cep/src/main/java/org/apache/flink/cep/operator/AbstractCEPPatternOperator.java
@@ -66,7 +66,7 @@ public abstract class AbstractCEPPatternOperator<IN>
 		if (isProcessingTime) {
 			// there can be no out of order elements in processing time
 			NFA<IN> nfa = getNFA();
-			processEvent(nfa, element.getValue(), element.getTimestamp());
+			processEvent(nfa, element.getValue(), System.currentTimeMillis());
 		} else {
 			PriorityQueue<StreamRecord<IN>> priorityQueue = getPriorityQueue();
 
diff --git a/flink-libraries/flink-cep/src/test/java/org/apache/flink/cep/CEPITCase.java b/flink-libraries/flink-cep/src/test/java/org/apache/flink/cep/CEPITCase.java
index 40c3c86..0a287a2 100644
--- a/flink-libraries/flink-cep/src/test/java/org/apache/flink/cep/CEPITCase.java
+++ b/flink-libraries/flink-cep/src/test/java/org/apache/flink/cep/CEPITCase.java
@@ -29,6 +29,7 @@ import org.apache.flink.streaming.api.datastream.DataStream;
 import org.apache.flink.streaming.api.environment.StreamExecutionEnvironment;
 import org.apache.flink.streaming.api.functions.AssignerWithPunctuatedWatermarks;
 import org.apache.flink.streaming.api.watermark.Watermark;
+import org.apache.flink.streaming.api.windowing.time.Time;
 import org.apache.flink.streaming.util.StreamingMultipleProgramsTestBase;
 
 import org.junit.After;
@@ -398,4 +399,27 @@ public class CEPITCase extends StreamingMultipleProgramsTestBase {
 
 		env.execute();
 	}
+
+	@Test
+	public void testProcessingTimeWithWindow() throws Exception {
+		StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment();
+		env.setParallelism(1);
+
+		DataStream<Integer> input = env.fromElements(1, 2);
+
+		Pattern<Integer, ?> pattern = Pattern.<Integer>begin("start").followedBy("end").within(Time.days(1));
+
+		DataStream<Integer> result = CEP.pattern(input, pattern).select(new PatternSelectFunction<Integer, Integer>() {
+			@Override
+			public Integer select(Map<String, Integer> pattern) throws Exception {
+				return pattern.get("start") + pattern.get("end");
+			}
+		});
+
+		result.writeAsText(resultPath, FileSystem.WriteMode.OVERWRITE);
+
+		expected = "3";
+
+		env.execute();
+	}
 }
