commit f2ed3e6ce8039d142e4c047fcc9cf09409105243
Author: Scott Mitchell <scott_mitchell@apple.com>
Date:   Wed May 4 22:58:40 2016 -0700

    DefaultPromise LateListener Logic Issues
    
    Motivation:
    The LateListener logic is prone to infinite loops and relies on being processed in the EventExecutor's thread for synchronization, but this EventExecutor may not be constant. An infinite loop can occur if the EventExecutor's execute method does not introduce a context switch in LateListener.run. The EventExecutor can be changed by classes which inherit from DefaultPromise. For example the DefaultChannelPromise will return w/e EventLoop the channel is registered to, but this EventLoop can change (re-registration).
    
    Modifications:
    - Remove the LateListener concept and instead use a single Object to maintain the listeners while still preserving notification order
    - Make the result member variable an atomic variable so it can be outside the synchronized(this) blocks
    - Cleanup/simplify existing state management code
    
    Result:
    Fixes https://github.com/netty/netty/issues/5185

diff --git a/common/src/main/java/io/netty/util/concurrent/DefaultPromise.java b/common/src/main/java/io/netty/util/concurrent/DefaultPromise.java
index bb3eb02..bd08839 100644
--- a/common/src/main/java/io/netty/util/concurrent/DefaultPromise.java
+++ b/common/src/main/java/io/netty/util/concurrent/DefaultPromise.java
@@ -24,47 +24,51 @@ import io.netty.util.internal.StringUtil;
 import io.netty.util.internal.logging.InternalLogger;
 import io.netty.util.internal.logging.InternalLoggerFactory;
 
-import java.util.ArrayDeque;
 import java.util.concurrent.CancellationException;
 import java.util.concurrent.TimeUnit;
+import java.util.concurrent.atomic.AtomicReferenceFieldUpdater;
 
+import static io.netty.util.internal.ObjectUtil.checkNotNull;
 import static java.util.concurrent.TimeUnit.MILLISECONDS;
 
 public class DefaultPromise<V> extends AbstractFuture<V> implements Promise<V> {
-
     private static final InternalLogger logger = InternalLoggerFactory.getInstance(DefaultPromise.class);
     private static final InternalLogger rejectedExecutionLogger =
             InternalLoggerFactory.getInstance(DefaultPromise.class.getName() + ".rejectedExecution");
-
     private static final int MAX_LISTENER_STACK_DEPTH = 8;
+    private static final AtomicReferenceFieldUpdater<DefaultPromise, Object> RESULT_UPDATER;
     private static final Signal SUCCESS = Signal.valueOf(DefaultPromise.class, "SUCCESS");
     private static final Signal UNCANCELLABLE = Signal.valueOf(DefaultPromise.class, "UNCANCELLABLE");
     private static final CauseHolder CANCELLATION_CAUSE_HOLDER = new CauseHolder(new CancellationException());
 
     static {
+        AtomicReferenceFieldUpdater<DefaultPromise, Object> updater =
+                PlatformDependent.newAtomicReferenceFieldUpdater(DefaultPromise.class, "result");
+        RESULT_UPDATER = updater == null ? AtomicReferenceFieldUpdater.newUpdater(DefaultPromise.class,
+                                                                                  Object.class, "result") : updater;
         CANCELLATION_CAUSE_HOLDER.cause.setStackTrace(EmptyArrays.EMPTY_STACK_TRACE);
     }
 
-    private final EventExecutor executor;
-
     private volatile Object result;
-
+    private final EventExecutor executor;
     /**
      * One or more listeners. Can be a {@link GenericFutureListener} or a {@link DefaultFutureListeners}.
      * If {@code null}, it means either 1) no listeners were added yet or 2) all listeners were notified.
+     *
+     * Threading - synchronized(this). We must support adding listeners when there is no EventExecutor.
      */
     private Object listeners;
-
     /**
-     * The list of the listeners that were added after the promise is done.  Initially {@code null} and lazily
-     * instantiated when the late listener is scheduled to be notified later.  Also used as a cached {@link Runnable}
-     * that performs the notification of the listeners it contains.
+     * Threading - synchronized(this). We are required to hold the monitor to use Java's underlying wait()/notifyAll().
      */
-    private LateListeners lateListeners;
-
     private short waiters;
 
     /**
+     * Threading - EventExecutor. Only accessed inside the EventExecutor thread while notifying listeners.
+     */
+    private boolean notifyingListeners;
+
+    /**
      * Creates a new instance.
      *
      * It is preferable to use {@link EventExecutor#newPromise()} to create a new promise
@@ -73,10 +77,7 @@ public class DefaultPromise<V> extends AbstractFuture<V> implements Promise<V> {
      *        the {@link EventExecutor} which is used to notify the promise once it is complete
      */
     public DefaultPromise(EventExecutor executor) {
-        if (executor == null) {
-            throw new NullPointerException("executor");
-        }
-        this.executor = executor;
+        this.executor = checkNotNull(executor, "executor");
     }
 
     protected DefaultPromise() {
@@ -84,157 +85,128 @@ public class DefaultPromise<V> extends AbstractFuture<V> implements Promise<V> {
         executor = null;
     }
 
-    protected EventExecutor executor() {
-        return executor;
-    }
-
     @Override
-    public boolean isCancelled() {
-        return isCancelled0(result);
+    public Promise<V> setSuccess(V result) {
+        if (setSuccess0(result)) {
+            notifyListeners();
+            return this;
+        }
+        throw new IllegalStateException("complete already: " + this);
     }
 
-    private static boolean isCancelled0(Object result) {
-        return result instanceof CauseHolder && ((CauseHolder) result).cause instanceof CancellationException;
+    @Override
+    public boolean trySuccess(V result) {
+        if (setSuccess0(result)) {
+            notifyListeners();
+            return true;
+        }
+        return false;
     }
 
     @Override
-    public boolean isCancellable() {
-        return result == null;
+    public Promise<V> setFailure(Throwable cause) {
+        if (setFailure0(cause)) {
+            notifyListeners();
+            return this;
+        }
+        throw new IllegalStateException("complete already: " + this, cause);
     }
 
     @Override
-    public boolean isDone() {
-        return isDone0(result);
+    public boolean tryFailure(Throwable cause) {
+        if (setFailure0(cause)) {
+            notifyListeners();
+            return true;
+        }
+        return false;
     }
 
-    private static boolean isDone0(Object result) {
-        return result != null && result != UNCANCELLABLE;
+    @Override
+    public boolean setUncancellable() {
+        if (RESULT_UPDATER.compareAndSet(this, null, UNCANCELLABLE)) {
+            return true;
+        }
+        Object result = this.result;
+        return !isDone0(result) || !isCancelled0(result);
     }
 
     @Override
     public boolean isSuccess() {
         Object result = this.result;
-        if (result == null || result == UNCANCELLABLE) {
-            return false;
-        }
-        return !(result instanceof CauseHolder);
+        return result != null && result != UNCANCELLABLE && !(result instanceof CauseHolder);
+    }
+
+    @Override
+    public boolean isCancellable() {
+        return result == null;
     }
 
     @Override
     public Throwable cause() {
         Object result = this.result;
-        if (result instanceof CauseHolder) {
-            return ((CauseHolder) result).cause;
-        }
-        return null;
+        return (result instanceof CauseHolder) ? ((CauseHolder) result).cause : null;
     }
 
     @Override
     public Promise<V> addListener(GenericFutureListener<? extends Future<? super V>> listener) {
-        if (listener == null) {
-            throw new NullPointerException("listener");
-        }
+        checkNotNull(listener, "listener");
 
-        if (isDone()) {
-            notifyLateListener(listener);
-            return this;
+        synchronized (this) {
+            addListener0(listener);
         }
 
-        synchronized (this) {
-            if (!isDone()) {
-                if (listeners == null) {
-                    listeners = listener;
-                } else {
-                    if (listeners instanceof DefaultFutureListeners) {
-                        ((DefaultFutureListeners) listeners).add(listener);
-                    } else {
-                        final GenericFutureListener<? extends Future<V>> firstListener =
-                                (GenericFutureListener<? extends Future<V>>) listeners;
-                        listeners = new DefaultFutureListeners(firstListener, listener);
-                    }
-                }
-                return this;
-            }
+        if (isDone()) {
+            notifyListeners();
         }
 
-        notifyLateListener(listener);
         return this;
     }
 
     @Override
     public Promise<V> addListeners(GenericFutureListener<? extends Future<? super V>>... listeners) {
-        if (listeners == null) {
-            throw new NullPointerException("listeners");
-        }
+        checkNotNull(listeners, "listeners");
 
-        for (GenericFutureListener<? extends Future<? super V>> l: listeners) {
-            if (l == null) {
-                break;
+        synchronized (this) {
+            for (GenericFutureListener<? extends Future<? super V>> listener : listeners) {
+                if (listener == null) {
+                    break;
+                }
+                addListener0(listener);
             }
-            addListener(l);
-        }
-        return this;
-    }
-
-    @Override
-    public Promise<V> removeListener(GenericFutureListener<? extends Future<? super V>> listener) {
-        if (listener == null) {
-            throw new NullPointerException("listener");
         }
 
         if (isDone()) {
-            return this;
-        }
-
-        synchronized (this) {
-            if (!isDone()) {
-                if (listeners instanceof DefaultFutureListeners) {
-                    ((DefaultFutureListeners) listeners).remove(listener);
-                } else if (listeners == listener) {
-                    listeners = null;
-                }
-            }
+            notifyListeners();
         }
 
         return this;
     }
 
     @Override
-    public Promise<V> removeListeners(GenericFutureListener<? extends Future<? super V>>... listeners) {
-        if (listeners == null) {
-            throw new NullPointerException("listeners");
-        }
+    public Promise<V> removeListener(final GenericFutureListener<? extends Future<? super V>> listener) {
+        checkNotNull(listener, "listener");
 
-        for (GenericFutureListener<? extends Future<? super V>> l: listeners) {
-            if (l == null) {
-                break;
-            }
-            removeListener(l);
+        synchronized (this) {
+            removeListener0(listener);
         }
-        return this;
-    }
 
-    @Override
-    public Promise<V> sync() throws InterruptedException {
-        await();
-        rethrowIfFailed();
         return this;
     }
 
     @Override
-    public Promise<V> syncUninterruptibly() {
-        awaitUninterruptibly();
-        rethrowIfFailed();
-        return this;
-    }
+    public Promise<V> removeListeners(final GenericFutureListener<? extends Future<? super V>>... listeners) {
+        checkNotNull(listeners, "listeners");
 
-    private void rethrowIfFailed() {
-        Throwable cause = cause();
-        if (cause == null) {
-            return;
+        synchronized (this) {
+            for (GenericFutureListener<? extends Future<? super V>> listener : listeners) {
+                if (listener == null) {
+                    break;
+                }
+                removeListener0(listener);
+            }
         }
 
-        PlatformDependent.throwException(cause);
+        return this;
     }
 
     @Override
@@ -247,9 +219,10 @@ public class DefaultPromise<V> extends AbstractFuture<V> implements Promise<V> {
             throw new InterruptedException(toString());
         }
 
+        checkDeadLock();
+
         synchronized (this) {
             while (!isDone()) {
-                checkDeadLock();
                 incWaiters();
                 try {
                     wait();
@@ -262,26 +235,16 @@ public class DefaultPromise<V> extends AbstractFuture<V> implements Promise<V> {
     }
 
     @Override
-    public boolean await(long timeout, TimeUnit unit)
-            throws InterruptedException {
-        return await0(unit.toNanos(timeout), true);
-    }
-
-    @Override
-    public boolean await(long timeoutMillis) throws InterruptedException {
-        return await0(MILLISECONDS.toNanos(timeoutMillis), true);
-    }
-
-    @Override
     public Promise<V> awaitUninterruptibly() {
         if (isDone()) {
             return this;
         }
 
+        checkDeadLock();
+
         boolean interrupted = false;
         synchronized (this) {
             while (!isDone()) {
-                checkDeadLock();
                 incWaiters();
                 try {
                     wait();
@@ -302,6 +265,16 @@ public class DefaultPromise<V> extends AbstractFuture<V> implements Promise<V> {
     }
 
     @Override
+    public boolean await(long timeout, TimeUnit unit) throws InterruptedException {
+        return await0(unit.toNanos(timeout), true);
+    }
+
+    @Override
+    public boolean await(long timeoutMillis) throws InterruptedException {
+        return await0(MILLISECONDS.toNanos(timeoutMillis), true);
+    }
+
+    @Override
     public boolean awaitUninterruptibly(long timeout, TimeUnit unit) {
         try {
             return await0(unit.toNanos(timeout), false);
@@ -321,89 +294,19 @@ public class DefaultPromise<V> extends AbstractFuture<V> implements Promise<V> {
         }
     }
 
-    private boolean await0(long timeoutNanos, boolean interruptable) throws InterruptedException {
-        if (isDone()) {
-            return true;
-        }
-
-        if (timeoutNanos <= 0) {
-            return isDone();
-        }
-
-        if (interruptable && Thread.interrupted()) {
-            throw new InterruptedException(toString());
-        }
-
-        long startTime = System.nanoTime();
-        long waitTime = timeoutNanos;
-        boolean interrupted = false;
-
-        try {
-            synchronized (this) {
-                if (isDone()) {
-                    return true;
-                }
-
-                if (waitTime <= 0) {
-                    return isDone();
-                }
-
-                checkDeadLock();
-                incWaiters();
-                try {
-                    for (;;) {
-                        try {
-                            wait(waitTime / 1000000, (int) (waitTime % 1000000));
-                        } catch (InterruptedException e) {
-                            if (interruptable) {
-                                throw e;
-                            } else {
-                                interrupted = true;
-                            }
-                        }
-
-                        if (isDone()) {
-                            return true;
-                        } else {
-                            waitTime = timeoutNanos - (System.nanoTime() - startTime);
-                            if (waitTime <= 0) {
-                                return isDone();
-                            }
-                        }
-                    }
-                } finally {
-                    decWaiters();
-                }
-            }
-        } finally {
-            if (interrupted) {
-                Thread.currentThread().interrupt();
-            }
-        }
-    }
-
-    /**
-     * Do deadlock checks
-     */
-    protected void checkDeadLock() {
-        EventExecutor e = executor();
-        if (e != null && e.inEventLoop()) {
-            throw new BlockingOperationException(toString());
-        }
-    }
-
     @Override
-    public Promise<V> setSuccess(V result) {
-        if (setSuccess0(result)) {
-            notifyListeners();
-            return this;
+    public V getNow() {
+        Object result = this.result;
+        if (result instanceof CauseHolder || result == SUCCESS) {
+            return null;
         }
-        throw new IllegalStateException("complete already: " + this);
+        return (V) result;
     }
 
     @Override
-    public boolean trySuccess(V result) {
-        if (setSuccess0(result)) {
+    public boolean cancel(boolean mayInterruptIfRunning) {
+        if (RESULT_UPDATER.compareAndSet(this, null, CANCELLATION_CAUSE_HOLDER)) {
+            checkNotifyWaiters();
             notifyListeners();
             return true;
         }
@@ -411,279 +314,320 @@ public class DefaultPromise<V> extends AbstractFuture<V> implements Promise<V> {
     }
 
     @Override
-    public Promise<V> setFailure(Throwable cause) {
-        if (setFailure0(cause)) {
-            notifyListeners();
-            return this;
-        }
-        throw new IllegalStateException("complete already: " + this, cause);
+    public boolean isCancelled() {
+        return isCancelled0(result);
     }
 
     @Override
-    public boolean tryFailure(Throwable cause) {
-        if (setFailure0(cause)) {
-            notifyListeners();
-            return true;
-        }
-        return false;
+    public boolean isDone() {
+        return isDone0(result);
     }
 
     @Override
-    public boolean cancel(boolean mayInterruptIfRunning) {
-        Object result = this.result;
-        if (isDone0(result) || result == UNCANCELLABLE) {
-            return false;
-        }
-
-        synchronized (this) {
-            // Allow only once.
-            result = this.result;
-            if (isDone0(result) || result == UNCANCELLABLE) {
-                return false;
-            }
-
-            this.result = CANCELLATION_CAUSE_HOLDER;
-            if (hasWaiters()) {
-                notifyAll();
-            }
-        }
-
-        notifyListeners();
-        return true;
+    public Promise<V> sync() throws InterruptedException {
+        await();
+        rethrowIfFailed();
+        return this;
     }
 
     @Override
-    public boolean setUncancellable() {
-        Object result = this.result;
-        if (isDone0(result)) {
-            return !isCancelled0(result);
-        }
-
-        synchronized (this) {
-            // Allow only once.
-            result = this.result;
-            if (isDone0(result)) {
-                return !isCancelled0(result);
-            }
+    public Promise<V> syncUninterruptibly() {
+        awaitUninterruptibly();
+        rethrowIfFailed();
+        return this;
+    }
 
-            this.result = UNCANCELLABLE;
-        }
-        return true;
+    @Override
+    public String toString() {
+        return toStringBuilder().toString();
     }
 
-    private boolean setFailure0(Throwable cause) {
-        if (cause == null) {
-            throw new NullPointerException("cause");
-        }
+    protected StringBuilder toStringBuilder() {
+        StringBuilder buf = new StringBuilder(64)
+                .append(StringUtil.simpleClassName(this))
+                .append('@')
+                .append(Integer.toHexString(hashCode()));
 
-        if (isDone()) {
-            return false;
+        Object result = this.result;
+        if (result == SUCCESS) {
+            buf.append("(success)");
+        } else if (result == UNCANCELLABLE) {
+            buf.append("(uncancellable)");
+        } else if (result instanceof CauseHolder) {
+            buf.append("(failure: ")
+                    .append(((CauseHolder) result).cause)
+                    .append(')');
+        } else if (result != null) {
+            buf.append("(success: ")
+                    .append(result)
+                    .append(')');
+        } else {
+            buf.append("(incomplete)");
         }
 
-        synchronized (this) {
-            // Allow only once.
-            if (isDone()) {
-                return false;
-            }
+        return buf;
+    }
 
-            result = new CauseHolder(cause);
-            if (hasWaiters()) {
-                notifyAll();
-            }
+    protected EventExecutor executor() {
+        return executor;
+    }
+
+    protected void checkDeadLock() {
+        EventExecutor e = executor();
+        if (e != null && e.inEventLoop()) {
+            throw new BlockingOperationException(toString());
         }
-        return true;
     }
 
-    private boolean setSuccess0(V result) {
-        if (isDone()) {
-            return false;
+    /**
+     * Notify a listener that a future has completed.
+     * <p>
+     * This method has a fixed depth of {@link #MAX_LISTENER_STACK_DEPTH} that will limit recursion to prevent
+     * {@link StackOverflowError} and will stop notifying listeners added after this threshold is exceeded.
+     * @param eventExecutor the executor to use to notify the listener {@code l}.
+     * @param future the future that is complete.
+     * @param l the listener to notify.
+     */
+    protected static void notifyListener(
+            EventExecutor eventExecutor, final Future<?> future, final GenericFutureListener<?> l) {
+        if (eventExecutor.inEventLoop()) {
+            final InternalThreadLocalMap threadLocals = InternalThreadLocalMap.get();
+            final int stackDepth = threadLocals.futureListenerStackDepth();
+            if (stackDepth < MAX_LISTENER_STACK_DEPTH) {
+                threadLocals.setFutureListenerStackDepth(stackDepth + 1);
+                try {
+                    notifyListener0(future, l);
+                } finally {
+                    threadLocals.setFutureListenerStackDepth(stackDepth);
+                }
+                return;
+            }
         }
 
-        synchronized (this) {
-            // Allow only once.
-            if (isDone()) {
-                return false;
+        safeExecute(eventExecutor, new OneTimeTask() {
+            @Override
+            public void run() {
+                notifyListener0(future, l);
             }
-            if (result == null) {
-                this.result = SUCCESS;
-            } else {
-                this.result = result;
+        });
+    }
+
+    private void notifyListeners() {
+        // Modifications to listeners should be done in a synchronized block before this, and should be visible here.
+        if (listeners == null) {
+            return;
+        }
+        EventExecutor executor = executor();
+        if (executor.inEventLoop()) {
+            notifyListeners0();
+            return;
+        }
+        safeExecute(executor, new OneTimeTask() {
+            @Override
+            public void run() {
+                notifyListeners0();
             }
-            if (hasWaiters()) {
-                notifyAll();
+        });
+    }
+
+    private void notifyListeners0() {
+        Object listeners;
+        while (!notifyingListeners) {
+            synchronized (this) {
+                if (this.listeners == null) {
+                    return;
+                }
+                listeners = this.listeners;
+                this.listeners = null;
+            }
+            notifyingListeners = true;
+            try {
+                if (listeners instanceof DefaultFutureListeners) {
+                    notifyListeners0((DefaultFutureListeners) listeners);
+                } else {
+                    notifyListener0(this, (GenericFutureListener<? extends Future<V>>) listeners);
+                }
+            } finally {
+                notifyingListeners = false;
             }
         }
-        return true;
     }
 
-    @Override
-    @SuppressWarnings("unchecked")
-    public V getNow() {
-        Object result = this.result;
-        if (result instanceof CauseHolder || result == SUCCESS) {
-            return null;
+    private void notifyListeners0(DefaultFutureListeners listeners) {
+        GenericFutureListener<?>[] a = listeners.listeners();
+        int size = listeners.size();
+        for (int i = 0; i < size; i ++) {
+            notifyListener0(this, a[i]);
         }
-        return (V) result;
     }
 
-    private boolean hasWaiters() {
-        return waiters > 0;
+    @SuppressWarnings({ "unchecked", "rawtypes" })
+    private static void notifyListener0(Future future, GenericFutureListener l) {
+        try {
+            l.operationComplete(future);
+        } catch (Throwable t) {
+            logger.warn("An exception was thrown by {}.operationComplete()", l.getClass().getName(), t);
+        }
+    }
+
+    private void addListener0(GenericFutureListener<? extends Future<? super V>> listener) {
+        if (listeners == null) {
+            listeners = listener;
+        } else if (listeners instanceof DefaultFutureListeners) {
+            ((DefaultFutureListeners) listeners).add(listener);
+        } else {
+            listeners = new DefaultFutureListeners((GenericFutureListener<? extends Future<V>>) listeners, listener);
+        }
+    }
+
+    private void removeListener0(GenericFutureListener<? extends Future<? super V>> listener) {
+        if (listeners instanceof DefaultFutureListeners) {
+            ((DefaultFutureListeners) listeners).remove(listener);
+        } else if (listeners == listener) {
+            listeners = null;
+        }
+    }
+
+    private boolean setSuccess0(V result) {
+        return setValue0(result == null ? SUCCESS : result);
+    }
+
+    private boolean setFailure0(Throwable cause) {
+        return setValue0(new CauseHolder(checkNotNull(cause, "cause")));
+    }
+
+    private boolean setValue0(Object objResult) {
+        if (RESULT_UPDATER.compareAndSet(this, null, objResult) ||
+            RESULT_UPDATER.compareAndSet(this, UNCANCELLABLE, objResult)) {
+            checkNotifyWaiters();
+            return true;
+        }
+        return false;
+    }
+
+    private synchronized void checkNotifyWaiters() {
+        if (waiters > 0) {
+            notifyAll();
+        }
     }
 
     private void incWaiters() {
         if (waiters == Short.MAX_VALUE) {
             throw new IllegalStateException("too many waiters: " + this);
         }
-        waiters ++;
+        ++waiters;
     }
 
     private void decWaiters() {
-        waiters --;
+        --waiters;
     }
 
-    private void notifyListeners() {
-        // This method doesn't need synchronization because:
-        // 1) This method is always called after synchronized (this) block.
-        //    Hence any listener list modification happens-before this method.
-        // 2) This method is called only when 'done' is true.  Once 'done'
-        //    becomes true, the listener list is never modified - see add/removeListener()
-
-        Object listeners = this.listeners;
-        if (listeners == null) {
+    private void rethrowIfFailed() {
+        Throwable cause = cause();
+        if (cause == null) {
             return;
         }
 
-        EventExecutor executor = executor();
-        if (executor.inEventLoop()) {
-            final InternalThreadLocalMap threadLocals = InternalThreadLocalMap.get();
-            final int stackDepth = threadLocals.futureListenerStackDepth();
-            if (stackDepth < MAX_LISTENER_STACK_DEPTH) {
-                threadLocals.setFutureListenerStackDepth(stackDepth + 1);
-                try {
-                    if (listeners instanceof DefaultFutureListeners) {
-                        notifyListeners0(this, (DefaultFutureListeners) listeners);
-                    } else {
-                        final GenericFutureListener<? extends Future<V>> l =
-                                (GenericFutureListener<? extends Future<V>>) listeners;
-                        notifyListener0(this, l);
-                    }
-                } finally {
-                    this.listeners = null;
-                    threadLocals.setFutureListenerStackDepth(stackDepth);
-                }
-                return;
-            }
+        PlatformDependent.throwException(cause);
+    }
+
+    private boolean await0(long timeoutNanos, boolean interruptable) throws InterruptedException {
+        if (isDone()) {
+            return true;
         }
 
-        if (listeners instanceof DefaultFutureListeners) {
-            final DefaultFutureListeners dfl = (DefaultFutureListeners) listeners;
-            safeExecute(executor, new OneTimeTask() {
-                @Override
-                public void run() {
-                    notifyListeners0(DefaultPromise.this, dfl);
-                    DefaultPromise.this.listeners = null;
-                }
-            });
-        } else {
-            final GenericFutureListener<? extends Future<V>> l =
-                    (GenericFutureListener<? extends Future<V>>) listeners;
-            safeExecute(executor, new OneTimeTask() {
-                @Override
-                public void run() {
-                    notifyListener0(DefaultPromise.this, l);
-                    DefaultPromise.this.listeners = null;
-                }
-            });
+        if (timeoutNanos <= 0) {
+            return isDone();
         }
-    }
 
-    private static void notifyListeners0(Future<?> future, DefaultFutureListeners listeners) {
-        final GenericFutureListener<?>[] a = listeners.listeners();
-        final int size = listeners.size();
-        for (int i = 0; i < size; i ++) {
-            notifyListener0(future, a[i]);
+        if (interruptable && Thread.interrupted()) {
+            throw new InterruptedException(toString());
         }
-    }
 
-    /**
-     * Notifies the specified listener which were added after this promise is already done.
-     * This method ensures that the specified listener is not notified until {@link #listeners} becomes {@code null}
-     * to avoid the case where the late listeners are notified even before the early listeners are notified.
-     */
-    private void notifyLateListener(final GenericFutureListener<?> l) {
-        final EventExecutor executor = executor();
-        if (executor.inEventLoop()) {
-            // Execute immediately if late listeners is empty. This allows subsequent late listeners
-            // that are added after completion to be notified immediately and preserver order.
-            if (listeners == null && (lateListeners == null || lateListeners.isEmpty())) {
-                final InternalThreadLocalMap threadLocals = InternalThreadLocalMap.get();
-                final int stackDepth = threadLocals.futureListenerStackDepth();
-                if (stackDepth < MAX_LISTENER_STACK_DEPTH) {
-                    threadLocals.setFutureListenerStackDepth(stackDepth + 1);
+        checkDeadLock();
+
+        long startTime = System.nanoTime();
+        long waitTime = timeoutNanos;
+        boolean interrupted = false;
+        try {
+            for (;;) {
+                synchronized (this) {
+                    incWaiters();
                     try {
-                        notifyListener0(this, l);
+                        wait(waitTime / 1000000, (int) (waitTime % 1000000));
+                    } catch (InterruptedException e) {
+                        if (interruptable) {
+                            throw e;
+                        } else {
+                            interrupted = true;
+                        }
                     } finally {
-                        threadLocals.setFutureListenerStackDepth(stackDepth);
+                        decWaiters();
                     }
-                    return;
                 }
-            } else {
-                LateListeners lateListeners = this.lateListeners;
-                if (lateListeners == null) {
-                    this.lateListeners = lateListeners = new LateListeners();
+                if (isDone()) {
+                    return true;
+                } else {
+                    waitTime = timeoutNanos - (System.nanoTime() - startTime);
+                    if (waitTime <= 0) {
+                        return isDone();
+                    }
                 }
-                lateListeners.add(l);
-                executor.execute(lateListeners);
-                return;
             }
-        }
-
-        // Add the late listener to lateListeners in the executor thread for thread safety.
-        // We could just make LateListeners extend ConcurrentLinkedQueue, but it's an overkill considering
-        // that most asynchronous applications won't execute this code path.
-        executor.execute(new LateListenerNotifier(l));
-    }
-
-    protected static void notifyListener(
-            final EventExecutor eventExecutor, final Future<?> future, final GenericFutureListener<?> l) {
-
-        if (eventExecutor.inEventLoop()) {
-            final InternalThreadLocalMap threadLocals = InternalThreadLocalMap.get();
-            final int stackDepth = threadLocals.futureListenerStackDepth();
-            if (stackDepth < MAX_LISTENER_STACK_DEPTH) {
-                threadLocals.setFutureListenerStackDepth(stackDepth + 1);
-                try {
-                    notifyListener0(future, l);
-                } finally {
-                    threadLocals.setFutureListenerStackDepth(stackDepth);
-                }
-                return;
+        } finally {
+            if (interrupted) {
+                Thread.currentThread().interrupt();
             }
         }
-
-        safeExecute(eventExecutor, new OneTimeTask() {
-            @Override
-            public void run() {
-                notifyListener0(future, l);
-            }
-        });
     }
 
-    private static void safeExecute(EventExecutor executor, Runnable task) {
-        try {
-            executor.execute(task);
-        } catch (Throwable t) {
-            rejectedExecutionLogger.error("Failed to submit a listener notification task. Event loop shut down?", t);
+    /**
+     * Notify all progressive listeners.
+     * <p>
+     * No attempt is made to ensure notification order if multiple calls are made to this method before
+     * the original invocation completes.
+     * <p>
+     * This will do an iteration over all listeners to get all of type {@link GenericProgressiveFutureListener}s.
+     * @param progress the new progress.
+     * @param total the total progress.
+     */
+    @SuppressWarnings("unchecked")
+    void notifyProgressiveListeners(final long progress, final long total) {
+        final Object listeners = progressiveListeners();
+        if (listeners == null) {
+            return;
         }
-    }
 
-    @SuppressWarnings({ "unchecked", "rawtypes" })
-    static void notifyListener0(Future future, GenericFutureListener l) {
-        try {
-            l.operationComplete(future);
-        } catch (Throwable t) {
-            if (logger.isWarnEnabled()) {
-                logger.warn("An exception was thrown by " + l.getClass().getName() + ".operationComplete()", t);
+        final ProgressiveFuture<V> self = (ProgressiveFuture<V>) this;
+
+        EventExecutor executor = executor();
+        if (executor.inEventLoop()) {
+            if (listeners instanceof GenericProgressiveFutureListener[]) {
+                notifyProgressiveListeners0(
+                        self, (GenericProgressiveFutureListener<?>[]) listeners, progress, total);
+            } else {
+                notifyProgressiveListener0(
+                        self, (GenericProgressiveFutureListener<ProgressiveFuture<V>>) listeners, progress, total);
+            }
+        } else {
+            if (listeners instanceof GenericProgressiveFutureListener[]) {
+                final GenericProgressiveFutureListener<?>[] array =
+                        (GenericProgressiveFutureListener<?>[]) listeners;
+                safeExecute(executor, new OneTimeTask() {
+                    @Override
+                    public void run() {
+                        notifyProgressiveListeners0(self, array, progress, total);
+                    }
+                });
+            } else {
+                final GenericProgressiveFutureListener<ProgressiveFuture<V>> l =
+                        (GenericProgressiveFutureListener<ProgressiveFuture<V>>) listeners;
+                safeExecute(executor, new OneTimeTask() {
+                    @Override
+                    public void run() {
+                        notifyProgressiveListener0(self, l, progress, total);
+                    }
+                });
             }
         }
     }
@@ -733,47 +677,6 @@ public class DefaultPromise<V> extends AbstractFuture<V> implements Promise<V> {
         }
     }
 
-    @SuppressWarnings("unchecked")
-    void notifyProgressiveListeners(final long progress, final long total) {
-        final Object listeners = progressiveListeners();
-        if (listeners == null) {
-            return;
-        }
-
-        final ProgressiveFuture<V> self = (ProgressiveFuture<V>) this;
-
-        EventExecutor executor = executor();
-        if (executor.inEventLoop()) {
-            if (listeners instanceof GenericProgressiveFutureListener[]) {
-                notifyProgressiveListeners0(
-                        self, (GenericProgressiveFutureListener<?>[]) listeners, progress, total);
-            } else {
-                notifyProgressiveListener0(
-                        self, (GenericProgressiveFutureListener<ProgressiveFuture<V>>) listeners, progress, total);
-            }
-        } else {
-            if (listeners instanceof GenericProgressiveFutureListener[]) {
-                final GenericProgressiveFutureListener<?>[] array =
-                        (GenericProgressiveFutureListener<?>[]) listeners;
-                safeExecute(executor, new OneTimeTask() {
-                    @Override
-                    public void run() {
-                        notifyProgressiveListeners0(self, array, progress, total);
-                    }
-                });
-            } else {
-                final GenericProgressiveFutureListener<ProgressiveFuture<V>> l =
-                        (GenericProgressiveFutureListener<ProgressiveFuture<V>>) listeners;
-                safeExecute(executor, new OneTimeTask() {
-                    @Override
-                    public void run() {
-                        notifyProgressiveListener0(self, l, progress, total);
-                    }
-                });
-            }
-        }
-    }
-
     private static void notifyProgressiveListeners0(
             ProgressiveFuture<?> future, GenericProgressiveFutureListener<?>[] listeners, long progress, long total) {
         for (GenericProgressiveFutureListener<?> l: listeners) {
@@ -790,96 +693,30 @@ public class DefaultPromise<V> extends AbstractFuture<V> implements Promise<V> {
         try {
             l.operationProgressed(future, progress, total);
         } catch (Throwable t) {
-            if (logger.isWarnEnabled()) {
-                logger.warn("An exception was thrown by " + l.getClass().getName() + ".operationProgressed()", t);
-            }
-        }
-    }
-
-    private static final class CauseHolder {
-        final Throwable cause;
-        CauseHolder(Throwable cause) {
-            this.cause = cause;
+            logger.warn("An exception was thrown by {}.operationProgressed()", l.getClass().getName(), t);
         }
     }
 
-    @Override
-    public String toString() {
-        return toStringBuilder().toString();
+    private static boolean isCancelled0(Object result) {
+        return result instanceof CauseHolder && ((CauseHolder) result).cause instanceof CancellationException;
     }
 
-    protected StringBuilder toStringBuilder() {
-        StringBuilder buf = new StringBuilder(64)
-            .append(StringUtil.simpleClassName(this))
-            .append('@')
-            .append(Integer.toHexString(hashCode()));
-
-        Object result = this.result;
-        if (result == SUCCESS) {
-            buf.append("(success)");
-        } else if (result == UNCANCELLABLE) {
-            buf.append("(uncancellable)");
-        } else if (result instanceof CauseHolder) {
-            buf.append("(failure: ")
-               .append(((CauseHolder) result).cause)
-               .append(')');
-        } else if (result != null) {
-            buf.append("(success: ")
-               .append(result)
-               .append(')');
-        } else {
-            buf.append("(incomplete)");
-        }
-
-        return buf;
+    private static boolean isDone0(Object result) {
+        return result != null && result != UNCANCELLABLE;
     }
 
-    private final class LateListeners extends ArrayDeque<GenericFutureListener<?>> implements Runnable {
-
-        private static final long serialVersionUID = -687137418080392244L;
-
-        LateListeners() {
-            super(2);
-        }
-
-        @Override
-        public void run() {
-            final EventExecutor executor = executor();
-            if (listeners == null || executor == ImmediateEventExecutor.INSTANCE) {
-                for (;;) {
-                    GenericFutureListener<?> l = poll();
-                    if (l == null) {
-                        break;
-                    }
-                    notifyListener0(DefaultPromise.this, l);
-                }
-            } else {
-                // Reschedule until the initial notification is done to avoid the race condition
-                // where the notification is made in an incorrect order.
-                safeExecute(executor, this);
-            }
+    private static final class CauseHolder {
+        final Throwable cause;
+        CauseHolder(Throwable cause) {
+            this.cause = cause;
         }
     }
 
-    private final class LateListenerNotifier implements Runnable {
-        private GenericFutureListener<?> l;
-
-        LateListenerNotifier(GenericFutureListener<?> l) {
-            this.l = l;
-        }
-
-        @Override
-        public void run() {
-            LateListeners lateListeners = DefaultPromise.this.lateListeners;
-            if (l != null) {
-                if (lateListeners == null) {
-                    DefaultPromise.this.lateListeners = lateListeners = new LateListeners();
-                }
-                lateListeners.add(l);
-                l = null;
-            }
-
-            lateListeners.run();
+    private static void safeExecute(EventExecutor executor, Runnable task) {
+        try {
+            executor.execute(task);
+        } catch (Throwable t) {
+            rejectedExecutionLogger.error("Failed to submit a listener notification task. Event loop shut down?", t);
         }
     }
 }
diff --git a/common/src/test/java/io/netty/util/concurrent/DefaultPromiseTest.java b/common/src/test/java/io/netty/util/concurrent/DefaultPromiseTest.java
index ab5d4f0..fa0154d 100644
--- a/common/src/test/java/io/netty/util/concurrent/DefaultPromiseTest.java
+++ b/common/src/test/java/io/netty/util/concurrent/DefaultPromiseTest.java
@@ -84,7 +84,7 @@ public class DefaultPromiseTest {
             p[i].addListener(new FutureListener<Void>() {
                 @Override
                 public void operationComplete(Future<Void> future) throws Exception {
-                    DefaultPromise.notifyListener(ImmediateEventExecutor.INSTANCE, future, new FutureListener<Void>() {
+                    future.addListener(new FutureListener<Void>() {
                         @Override
                         public void operationComplete(Future<Void> future) throws Exception {
                             if (finalI + 1 < p.length) {
@@ -192,8 +192,8 @@ public class DefaultPromiseTest {
      * <ol>
      * <li>A write is done</li>
      * <li>The write operation completes, and the promise state is changed to done</li>
-     * <li>A listener is added to the return from the write. The {@link FutureListener#operationComplete()} updates
-     * state which must be invoked before the response to the previous write is read.</li>
+     * <li>A listener is added to the return from the write. The {@link FutureListener#operationComplete(Future)}
+     * updates state which must be invoked before the response to the previous write is read.</li>
      * <li>The write operation</li>
      * </ol>
      */
diff --git a/transport/src/test/java/io/netty/channel/embedded/EmbeddedChannelTest.java b/transport/src/test/java/io/netty/channel/embedded/EmbeddedChannelTest.java
index 5d35360..658e46b 100644
--- a/transport/src/test/java/io/netty/channel/embedded/EmbeddedChannelTest.java
+++ b/transport/src/test/java/io/netty/channel/embedded/EmbeddedChannelTest.java
@@ -19,6 +19,7 @@ import io.netty.buffer.ByteBuf;
 import io.netty.buffer.Unpooled;
 import io.netty.channel.Channel;
 import io.netty.channel.ChannelFuture;
+import io.netty.channel.ChannelFutureListener;
 import io.netty.channel.ChannelHandler;
 import io.netty.channel.ChannelHandlerAdapter;
 import io.netty.channel.ChannelHandlerContext;
@@ -39,10 +40,27 @@ import java.util.concurrent.CountDownLatch;
 import java.util.concurrent.TimeUnit;
 import java.util.concurrent.atomic.AtomicReference;
 
-import static org.junit.Assert.*;
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertFalse;
+import static org.junit.Assert.assertNull;
+import static org.junit.Assert.assertSame;
+import static org.junit.Assert.assertTrue;
 
 public class EmbeddedChannelTest {
 
+    @Test(timeout = 2000)
+    public void promiseDoesNotInfiniteLoop() throws InterruptedException {
+        EmbeddedChannel channel = new EmbeddedChannel();
+        channel.closeFuture().addListener(new ChannelFutureListener() {
+            @Override
+            public void operationComplete(ChannelFuture future) throws Exception {
+                future.channel().close();
+            }
+        });
+
+        channel.close().syncUninterruptibly();
+    }
+
     @Test
     public void testConstructWithChannelInitializer() {
         final Integer first = 1;
