commit e72b2235fbddd17e13dfefb7bb439dd1ea8538bf
Author: Trustin Lee <t@motd.kr>
Date:   Fri Dec 12 11:47:52 2014 +0900

    Make sure to notify handshake success even if SSLEngine is closed
    
    Related:
    
    e9685ea45aebcb4f9dad0f3a1fc328a06b4932dd
    
    Motivation:
    
    SslHandler.unwrap() does not evaluate the handshake status of
    SSLEngine.unwrap() when the status of SSLEngine.unwrap() is CLOSED.
    
    It is not correct because the status does not reflect the state of the
    handshake currently in progress, accoding to the API documentation of
    SSLEngineResult.Status.
    
    Also, sslCloseFuture can be notified earlier than handshake notification
    because we call sslCloseFuture.trySuccess() before evaluating handshake
    status.
    
    Modifications:
    
    - Notify sslCloseFuture after the unwrap loop is finished
    - Add more assertions to SocketSslEchoTest
    
    Result:
    
    Potentially fix the regression caused by:
    - e9685ea45aebcb4f9dad0f3a1fc328a06b4932dd

diff --git a/handler/src/main/java/io/netty/handler/ssl/SslHandler.java b/handler/src/main/java/io/netty/handler/ssl/SslHandler.java
index ec580a4..cddeab6 100644
--- a/handler/src/main/java/io/netty/handler/ssl/SslHandler.java
+++ b/handler/src/main/java/io/netty/handler/ssl/SslHandler.java
@@ -930,6 +930,7 @@ public class SslHandler extends ByteToMessageDecoder implements ChannelOutboundH
         }
 
         boolean wrapLater = false;
+        boolean notifyClosure = false;
         ByteBuf decodeOut = allocate(ctx, initialOutAppBufCapacity);
         try {
             for (;;) {
@@ -941,8 +942,7 @@ public class SslHandler extends ByteToMessageDecoder implements ChannelOutboundH
 
                 if (status == Status.CLOSED) {
                     // notify about the CLOSED state of the SSLEngine. See #137
-                    sslCloseFuture.trySuccess(ctx.channel());
-                    break;
+                    notifyClosure = true;
                 }
 
                 switch (handshakeStatus) {
@@ -984,6 +984,10 @@ public class SslHandler extends ByteToMessageDecoder implements ChannelOutboundH
             if (wrapLater) {
                 wrap(ctx, true);
             }
+
+            if (notifyClosure) {
+                sslCloseFuture.trySuccess(ctx.channel());
+            }
         } catch (SSLException e) {
             setHandshakeFailure(e);
             throw e;
diff --git a/testsuite/src/test/java/io/netty/testsuite/transport/socket/SocketSslEchoTest.java b/testsuite/src/test/java/io/netty/testsuite/transport/socket/SocketSslEchoTest.java
index 6e6d16e..04cc208 100644
--- a/testsuite/src/test/java/io/netty/testsuite/transport/socket/SocketSslEchoTest.java
+++ b/testsuite/src/test/java/io/netty/testsuite/transport/socket/SocketSslEchoTest.java
@@ -315,8 +315,7 @@ public class SocketSslEchoTest extends AbstractSocketTest {
         }
 
         @Override
-        public void channelActive(ChannelHandlerContext ctx)
-                throws Exception {
+        public void channelActive(ChannelHandlerContext ctx) throws Exception {
             channel = ctx.channel();
         }
 
@@ -345,7 +344,10 @@ public class SocketSslEchoTest extends AbstractSocketTest {
                 counter > data.length / 2 && renegoFuture == null) {
 
                 SslHandler sslHandler = ctx.pipeline().get(SslHandler.class);
+
                 Future<Channel> hf = sslHandler.handshakeFuture();
+                assertThat(hf.isDone(), is(true));
+
                 renegoFuture = sslHandler.renegotiate();
                 assertThat(renegoFuture, is(not(sameInstance(hf))));
                 assertThat(renegoFuture, is(sameInstance(sslHandler.handshakeFuture())));
@@ -366,13 +368,13 @@ public class SocketSslEchoTest extends AbstractSocketTest {
         @Override
         public void userEventTriggered(ChannelHandlerContext ctx, Object evt) throws Exception {
             if (evt instanceof SslHandshakeCompletionEvent) {
+                assertSame(SslHandshakeCompletionEvent.SUCCESS, evt);
                 negoCounter ++;
             }
         }
 
         @Override
-        public void exceptionCaught(ChannelHandlerContext ctx,
-                Throwable cause) throws Exception {
+        public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws Exception {
             if (logger.isWarnEnabled()) {
                 logger.warn(
                         "Unexpected exception from the " +
